<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sasa</name>
    </assembly>
    <members>
        <member name="T:Sasa.IAsync">
            <summary>
            An asynchronous value.
            </summary>
        </member>
        <member name="P:Sasa.IAsync.Operation">
            <summary>
            The async operation currently running, if any.
            </summary>
        </member>
        <member name="T:Sasa.Async`1">
            <summary>
            An asynchronously computed value.
            </summary>
            <typeparam name="T">The type of value.</typeparam>
            <remarks>
            This is a useful abstraction for a simple asynchronous programming
            pattern. If you have a number of long operations that you'd normally
            have to wait for in synchronous code, you can turn it into what's
            essentially an enumerable sequence of <seealso cref="T:Sasa.Either`2"/>.
            
            For instance, the following synchronous code:
            <code>
            public byte[] ReadData(string file)
            {
                var buffer = new byte[32768];
                using (var file = File.Open(file, ...))
                {
                    int read = 0;
                    do {
                        read += file.Read(buffer, read, buffer.Length - read);
                    } while (read &lt; buffer.Length);
                }
                return buffer;
            }
            </code>
            which you would call like so:
            <code>
            byte[] data = ReadData("/some/file/path");
            </code>
            must wait until the entire buffer is full. If this sort of operation
            were frequent on a server processing thousands of connections, it would
            quickly consume all system resources with threads and their stacks.
            
            Using Async&lt;T&gt; and IEnumerable&lt;T&gt; however, the above code
            can change to:
            <code>
            public IEnumerable&lt;Async&lt;byte[]&gt;&gt; ReadData(string file)
            {
                var buffer = new byte[32768];
                using (var file = File.Open(file, ...))
                {
                    int read = 0;
                    IAsyncResult sync;
                    do {
                        sync = file.BeginRead(buffer, read, buffer.Length - read, null, null);
                        yield return new Async&lt;byte[]&gt;(sync);
                        read += file.EndRead(sync);
                    } while (read &lt; buffer.Length);
                }
                yield return new Async&lt;byte[]&gt;(buffer);
            }
            </code>
            and called like so:
            <code>
            byte[] data;
            foreach (var x in ReadData("/some/file/path"))
            {
                if (x.TryGetValue(out data))
                    // do something with data
            }
            </code>
            Or in this case, you could also simply do:
            <code>
            byte[] data = ReadData("/some/file/path").Last().Value;
            </code>
            This arrangement is done so that you have access to the intermediate
            <seealso cref="T:System.IAsyncResult"/> values and their associated wait handles.
            With the wait handle, we can call <seealso cref="!:WaitHandle.WaitAny"/>
            on a whole set of such handles, and the thread will only resume once
            there is actual data ready. Since I/O operations take so long to 
            complete relative to CPU time, we so shouldn't take up valuable
            threading resources just blocking on reads and writes.
            
            So only a few threads can service thousands of I/O requests of this
            sort, assuming the <see cref="T:System.IAsyncResult"/> is propagated up to
            the top-level event loop.
            </remarks>
        </member>
        <member name="M:Sasa.Async`1.#ctor(`0)">
            <summary>
            A concrete value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Async`1.#ctor(System.IAsyncResult)">
            <summary>
            A deferral because value is not yet ready.
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:Sasa.Async`1.#ctor(System.Exception)">
            <summary>
            A deferral because value is not yet ready.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Sasa.Async`1.Operation">
            <summary>
            The hand for the async operation currently in progress.
            </summary>
        </member>
        <member name="P:Sasa.Async`1.Error">
            <summary>
            Any errors that might have occurred.
            </summary>
        </member>
        <member name="P:Sasa.Async`1.HasValue">
            <summary>
            True if this instance currently has a value, false otherwise.
            </summary>
        </member>
        <member name="P:Sasa.Async`1.Value">
            <summary>
            The current value, if any.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if called when <seealso cref="P:Sasa.Async`1.HasValue"/> is false.</exception>
        </member>
        <member name="M:Sasa.Async`1.TryGetValue(`0@)">
            <summary>
            Check if there's a value.
            </summary>
            <param name="value">The contained value.</param>
            <returns>True if there's a value, false otherwise.</returns>
        </member>
        <member name="T:Sasa.Async">
            <summary>
            Asynchronous helpers.
            </summary>
        </member>
        <member name="M:Sasa.Async.AsAsync``1(``0)">
            <summary>
            Construct an async value.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Sasa.Async.AsAsync``1(System.IAsyncResult)">
            <summary>
            Construct an async value.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="T:Sasa.Collections.ISeq`2">
            <summary>
            The interface describing a purely functional collection.
            </summary>
            <typeparam name="TCollection">The type of the collection.</typeparam>
            <typeparam name="TItem">The type of the elements contained within the collection</typeparam>
            <remarks>
            The precise semantics of the collection is implementation-specific. A sequence of Add and Remove
            calls may return items in an arbitrary sequence depending on the type collection.
            </remarks>
        </member>
        <member name="P:Sasa.Collections.ISeq`2.IsEmpty">
            <summary>
            Returns true if the collection is empty.
            </summary>
        </member>
        <member name="M:Sasa.Collections.ISeq`2.Add(`1)">
            <summary>
            Adds an item to the collection.
            </summary>
            <param name="value">The item to add.</param>
            <returns>A new collection with the new item.</returns>
        </member>
        <member name="M:Sasa.Collections.ISeq`2.Remove(`1@)">
            <summary>
            Removes an item from the collection.
            </summary>
            <param name="value">The item removed.</param>
            <returns>A new collection without the item.</returns>
        </member>
        <member name="M:Sasa.Collections.ISeq`2.Remove">
            <summary>
            Remove an item from the collection
            </summary>
            <returns>A pair of a new collection without the item, and the item that was removed.</returns>
        </member>
        <member name="T:Sasa.Collections.Lifo`1">
            <summary>
            A purely functional stack.
            </summary>
            <remarks>
            "null" is also a valid sequence value that can be used to
            construct lists (see example).
            </remarks>
            <example>
            <code>Seq&lt;T&gt; list = value1 &amp; value2 &amp; null;</code>
            </example>
            <typeparam name="T">The type of the sequence elements.</typeparam>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.#ctor(`0,Sasa.Collections.Lifo{`0})">
            <summary>
            Construct a new sequence from a new head value and an existing list.
            </summary>
            <param name="value">The new value at the head of the list.</param>
            <param name="tail">The remainder of the list.</param>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.#ctor(`0)">
            <summary>
            Construct a new single-element sequence.
            </summary>
            <param name="value">The new value at the head of the list.</param>
        </member>
        <member name="P:Sasa.Collections.Lifo`1.Empty">
            <summary>
            Returns an empty stack.
            </summary>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.GetEnumerator">
            <summary>
            Returns an enumerator over the given list.
            </summary>
            <returns>An enumeration over the list.</returns>
        </member>
        <member name="P:Sasa.Collections.Lifo`1.IsEmpty">
            <summary>
            Returns true if the sequence is empty.
            </summary>
        </member>
        <member name="P:Sasa.Collections.Lifo`1.Value">
            <summary>
            Gets the current element of the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the collection is empty.</exception>
        </member>
        <member name="P:Sasa.Collections.Lifo`1.Next">
            <summary>
            Returns the next element in the sequence.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the collection is empty.</exception>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Equals(Sasa.Collections.Lifo{`0})">
            <summary>
            Tests structural equality of two sequences.
            </summary>
            <param name="other">The other sequence to compare to.</param>
            <returns>True if the sequences are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Equals(System.Object)">
            <summary>
            Compares two objects for equality.
            </summary>
            <param name="obj">The other object to compare to.</param>
            <returns>Returns true if the objects are equal.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.GetHashCode">
            <summary>
            Returns the hash code for the current sequence.
            </summary>
            <returns>The integer hash code.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Peek">
            <summary>
            Peeks at the current value in the sequence.
            </summary>
            <returns>The value at the head of the sequence.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the sequence is empty.</exception>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Pop(`0@)">
            <summary>
            Pops the first element off the sequence.
            </summary>
            <param name="value">The value in the first element of the sequence.</param>
            <returns>The remaining sequence.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the sequence is empty.</exception>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Pop">
            <summary>
            Pops the first element off the sequence.
            </summary>
            <returns>A pair consisting of the new sequence and the current element of the sequence.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the sequence is empty.</exception>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Push(`0)">
            <summary>
            Push an element on to the front of the sequence.
            </summary>
            <param name="value">The new head of the sequence.</param>
            <returns>A new sequence.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Contains(`0)">
            <summary>
            Checks whether a value is in the sequence.
            </summary>
            <param name="value">The value to test.</param>
            <returns>True if the element is in the sequence, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Reverse">
            <summary>
            Reverse a sequence.
            </summary>
            <returns>A reversed sequence.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Append(Sasa.Collections.Lifo{`0})">
            <summary>
            Append the given sequence after the current sequence.
            </summary>
            <param name="other">The elements to append.</param>
            <returns>A new sequence constructed from the given parameters.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.ReverseAppend(Sasa.Collections.Lifo{`0})">
            <summary>
            Reverses the current sequence and appends another sequence to the end.
            </summary>
            <param name="append">The sequence to append.</param>
            <returns>A combined sequence.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.ReversePush(Sasa.Collections.Lifo{`0})">
            <summary>
            Reverses the current sequence and appends it after other sequence.
            </summary>
            <param name="other">The sequence to append.</param>
            <returns>A combined sequence.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Select``1(``0,System.Func{`0,Sasa.Collections.Lifo{`0},``0})">
            <summary>
            Apply an operation to a deconstructed list.
            </summary>
            <typeparam name="TResult">The type of return value.</typeparam>
            <param name="otherwise">The value to return if the sequence is empty.</param>
            <param name="cons">The function to invoke with the deconstructed head of the list.</param>
            <returns>Returns cons(head, tail), or otherwise if the sequence is empty.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Select(`0)">
            <summary>
            Return the value at the head of the list.
            </summary>
            <param name="otherwise">The value to return if the sequence is empty.</param>
            <returns>Returns the value at the head of the list, or 'otherwise' if the sequence is empty.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Set(Sasa.Collections.Lifo{`0}@)">
            <summary>
            Perform an atomic set of a stack value.
            </summary>
            <param name="slot">The reference at which to place the new head.</param>
            <returns>Returns true if the swap succeeded.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Remove(`0)">
            <summary>
            Remove an element from the sequence.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>A new sequence without the element.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.Do(System.Action{`0})">
            <summary>
            Apply an operation over a sequence.
            </summary>
            <param name="func">The function to apply.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.ToString">
            <summary>
            Return a string representation of the given list.
            </summary>
            <returns>String represetation of the list.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.op_BitwiseAnd(Sasa.Collections.Lifo{`0},`0)">
            <summary>
            The sequence 'cons'/add operation, to construct a sequence from a new value and an existing list.
            </summary>
            <param name="right">The new value at the head of the list.</param>
            <param name="left">The remainder of the list.</param>
            <returns>A new sequence constructed from the given parameters.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.op_BitwiseAnd(Sasa.Collections.Lifo{`0},Sasa.Collections.Lifo{`0})">
            <summary>
            The sequence 'cons'/add operation, to construct a sequence from two lists.
            </summary>
            <param name="left">The new value at the head of the list.</param>
            <param name="right">The remainder of the list.</param>
            <returns>A new sequence constructed from the given parameters.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.op_BitwiseOr(Sasa.Collections.Lifo{`0},`0)">
            <summary>
            Returns the value at the head of the sequence o, if o is not empty, or t otherwise. This is
            the sequence equivalent of the ?? operator for null values.
            </summary>
            <param name="left">The sequence value to return if not empty.</param>
            <param name="right">The value to return otherwise.</param>
            <returns>Either the head of the list, or t.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.op_Equality(Sasa.Collections.Lifo{`0},Sasa.Collections.Lifo{`0})">
            <summary>
            Test two sequences for equality.
            </summary>
            <param name="left">The left sequence.</param>
            <param name="right">The right sequence.</param>
            <returns>Returns true if they are equal.</returns>
        </member>
        <member name="M:Sasa.Collections.Lifo`1.op_Inequality(Sasa.Collections.Lifo{`0},Sasa.Collections.Lifo{`0})">
            <summary>
            Test two sequences for inequality.
            </summary>
            <param name="left">The left sequence.</param>
            <param name="right">The right sequence.</param>
            <returns>Returns true if they are not equal.</returns>
        </member>
        <member name="T:Sasa.Collections.Arrays">
            <summary>
            Array extensions.
            </summary>
        </member>
        <member name="M:Sasa.Collections.Arrays.Concat``1(``0[],``0[])">
            <summary>
            Combine the values of two arrays into a new array.
            </summary>
            <typeparam name="T">The type in the array.</typeparam>
            <param name="first">The first array.</param>
            <param name="second">The second array.</param>
            <returns>Returns a new array with the values of <paramref name="first"/>, followed by the values in <paramref name="second"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="first"/> or <paramref name="second"/> are null.</exception>
            <remarks>
            <see cref="M:Sasa.Collections.Arrays.Concat``1(``0[],``0[])"/> operates much like <see cref="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>, but returns an array instead of
            an <see cref="T:System.Collections.Generic.IEnumerable`1"/>:
            <code>
            var array = new[] { 1, 2, 3 }.Concat(4, 5);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 2, 3, 4, 5, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Append``1(``0[],``0)">
            <summary>
            Combine the values of two arrays into a new array.
            </summary>
            <typeparam name="T">The type in the array.</typeparam>
            <param name="array">The first array.</param>
            <param name="last">The second array.</param>
            <returns>Returns a new array with the values of <paramref name="array"/>, followed by <paramref name="last"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method creates a new array with <paramref name="last"/> appended to the end:
            <code>
            var array = new[] { 1, 2, 3 }.Append(4);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 2, 3, 4, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Set``1(``0[],System.Int32,``0)">
            <summary>
            Sets the index of the array.
            </summary>
            <typeparam name="T">The type of array element.</typeparam>
            <param name="array">The array to set.</param>
            <param name="index">The index to set.</param>
            <param name="value">The value to set.</param>
            <returns>A new array with the slot</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if index is outside the array bounds.</exception>
            <remarks>
            This extension method creates a new array with the given index initialized to the given value:
            <code>
            var orig = new[] { 1, 2, 3 };
            var array = orig.Set(index: 1, value: 99);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 99, 3, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Insert``1(``0[],System.Int32,``0)">
            <summary>
            Insert a new element into an array.
            </summary>
            <typeparam name="T">The type of array element.</typeparam>
            <param name="array">The array to expand.</param>
            <param name="index">The index at which to insert the element.</param>
            <param name="value">The value to insert.</param>
            <returns>Returns a new array with the values of <paramref name="array"/>, followed by <paramref name="value"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if index is outside the array bounds.</exception>
            <remarks>
            This extension method creates a new array with the given element inserted at the given index:
            <code>
            var orig = new[] { 1, 2, 3 };
            var array = orig.Insert(index: 1, value: 99);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 99, 2, 3, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Remove``1(``0[],System.Int32)">
            <summary>
            Remove an element from an array.
            </summary>
            <typeparam name="T">The type of array element.</typeparam>
            <param name="array">The array to contract.</param>
            <param name="index">The index of the element to remove.</param>
            <returns>Returns a new array with the value at <paramref name="index"/> removed from <paramref name="array"/></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if index is outside the array bounds.</exception>
            <remarks>
            This extension method creates a new array with the element at the given index removed:
            <code>
            var orig = new[] { 1, 99, 2, 3 };
            var array = orig.Remove(1);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 2, 3, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Create``1(``0[])">
            <summary>
            A syntactic shortcut to create arrays of values leveraging type inference.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="values">The values to create.</param>
            <returns>An array of the provided values.</returns>
            <remarks>
            This is a simple convenience method for constructing arrays:
            <code>
            var array = Arrays.Create(1, 2, 3, 4);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 2, 3, 4, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.ToArray``2(System.Collections.Generic.IEnumerable{``1},``0@,System.Int32[],System.Int32[])">
            <summary>
            Converts a stream of values to an arbitrary dimension array.
            </summary>
            <typeparam name="TArray">The array type.</typeparam>
            <typeparam name="TElement">The array element type.</typeparam>
            <param name="array">The newly created array.</param>
            <param name="elements">The stream of elements.</param>
            <param name="lowerBounds">The array lower bounds of the array indices.</param>
            <param name="lengths">The array index lengths.</param>
            <returns>An arbitrary dimension array populated from <paramref name="elements"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if any indices are outside the array bounds.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if any arguments are null.</exception>
            <remarks>
            This extension method copies an enumerable sequence into a new array created given the lower bounds
            and lengths:
            <code>
            var source = new[] { 1, 2, 3, 4 };
            var twoDim = source.ToArray&lt;int[,], int&gt;(new[] { 0, 0 }, new[] { 2, 2 });
            Console.Write("| {0}, {1} |", twoDim[0,0], twoDim[0,1]);
            Console.Write("| {0}, {1} |", twoDim[1,0], twoDim[1,1]);
            // output:
            // | 1, 2 |
            // | 3, 4 |
            </code>
            This extension attempts to copy the array using the fastest means possible, and only uses
            the slow, generic array indexing interface when the array type has more than 3 indexes.
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.ToArray``2(System.Collections.Generic.IEnumerable{``1},System.Int32[],System.Int32[])">
            <summary>
            Converts a stream of values to an arbitrary dimension array.
            </summary>
            <typeparam name="TArray">The array type.</typeparam>
            <typeparam name="TElement">The array element type.</typeparam>
            <param name="elements">The stream of elements.</param>
            <param name="lowerBounds">The array lower bounds of the array indices.</param>
            <param name="lengths">The array index lengths.</param>
            <returns>An arbitrary dimension array populated from <paramref name="elements"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if any indices are outside the array bounds.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if any arguments are null.</exception>
            <remarks>
            This extension method copies an enumerable sequence into a new array created given the lower bounds
            and lengths:
            <code>
            var source = new[] { 1, 2, 3, 4 };
            var twoDim = source.ToArray&lt;int[,], int&gt;(new[] { 0, 0 }, new[] { 2, 2 });
            Console.Write("| {0}, {1} |", twoDim[0,0], twoDim[0,1]);
            Console.Write("| {0}, {1} |", twoDim[1,0], twoDim[1,1]);
            // output:
            // | 1, 2 |
            // | 3, 4 |
            </code>
            This extension attempts to copy the array using the fastest means possible, and only uses
            the slow, generic array indexing interface when the array type has more than 3 indexes.
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Slice``1(``0[],System.Int32,System.Int32)">
            <summary>
            Return a slice of an array delineated by the start and end indices.
            </summary>
            <typeparam name="T">The type of the array elements.</typeparam>
            <param name="array">The array to slice.</param>
            <param name="start">The starting index of the slice.</param>
            <param name="end">The first index not included in the slice.</param>
            <returns>The array slice.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if indices are outside the array bounds.</exception>
            <remarks>
            This extension method extracts a sub-array from the given array delimited by a
            <paramref name="start"/> and <paramref name="end"/> index:
            <code>
            var array = new[] { 1, 2, 3, 4, 5, 6, 7, 8 }
                        .Slice(start: 2, end: 5);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 3, 4, 5, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.At``1(``0[],System.Int32)">
            <summary>
            Attempts to access the array by index.
            </summary>
            <typeparam name="T">The type of array items.</typeparam>
            <param name="items">The array to access.</param>
            <param name="index">The array index to access.</param>
            <returns>
            The value at the given index is returned if <paramref name="index"/> is within the array
            bounds, otherwise <see cref="P:Sasa.Option`1.None"/> is returned.
            </returns>
        </member>
        <member name="M:Sasa.Collections.Arrays.TryGetValue``1(``0[],System.Int32,``0@)">
            <summary>
            Attempts to access the array by index.
            </summary>
            <typeparam name="T">The type of array items.</typeparam>
            <param name="items">The array to access.</param>
            <param name="index">The array index to access.</param>
            <param name="value">The value at the array index.</param>
            <returns>
            True if the value was successfully accessed, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Collections.Arrays.Repeat``1(``0[],System.Int32)">
            <summary>
            Repeats all entries in <paramref name="array"/> up to <paramref name="start"/>
            as many times as will fit.
            </summary>
            <typeparam name="T">The type of the array elements.</typeparam>
            <param name="array">The array to slice.</param>
            <param name="start">The index at which to start duplicating elements.</param>
            <returns>Returns <paramref name="array"/> after the update.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if index is outside the array bounds.</exception>
            <remarks>
            This extension method repeats all elements up to the given index as many
            times as will fit in the given array:
            <code>
            var array = new[] { 1, 2, 3, 4, 5 }.Repeat(2);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 2, 1, 2, 1, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Fill``1(``0[],``0,System.Int32,System.Int32)">
            <summary>
            Populates the given array with <paramref name="item"/>, starting at the given index
            for <paramref name="count"/> entries.
            </summary>
            <typeparam name="T">The type of the array elements.</typeparam>
            <param name="array">The array.</param>
            <param name="item">The item with which to fill the array.</param>
            <param name="start">The index to start filling.</param>
            <param name="count">The number of entries to set.</param>
            <returns>Returns <paramref name="array"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if index is outside the array bounds.</exception>
            <remarks>
            This extension method fills the given array with a given value between certain bounds:
            <code>
            var array = new int[4];
            array.Fill(item: 1, start: 0, count: 2);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 1, 0, 0, 
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Dup``1(``0[])">
            <summary>
            Duplicates a given array.
            </summary>
            <typeparam name="T">The type of the array elements.</typeparam>
            <param name="array">The array.</param>
            <returns>A duplicate of the given array.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method creates an exact duplicate of the given array:
            <code>
            var orig = new[] { 1, 2, 3 };
            var dup = orig.Dup();
            Console.WriteLine(orig == dup);
            Console.WriteLine(orig.SequenceEqual(dup));
            // output:
            // false
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.Bound``1(``0[],System.Int32)">
            <summary>
            Returns an array with the given length, seeded with the values from
            <paramref name="array"/>.
            </summary>
            <typeparam name="T">The type of the array elements.</typeparam>
            <param name="array">The array.</param>
            <param name="count">The number of items in the returned array.</param>
            <returns>An array of length <paramref name="count"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="count"/> is outside the array bounds.</exception>
            <remarks>
            If <paramref name="count"/> equals a.Length, then the same array
            is returned. If <paramref name="count"/> is greater than a.Length, then
            a new array is created and seeded with the original values in <paramref name="array"/>
            with the remainder of the array remaining uninitialized:
            <code>
            var array = new[] { 1, 2, 3, 4 }.Bound(2);
            foreach (var x in array)
                Console.Write("{0}, ", x);
            // output:
            // 1, 2, 
            </code>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when <paramref name="count"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Collections.Arrays.IndexOf``1(``0[],System.Predicate{``0})">
            <summary>
            Searches the array for a matching index.
            </summary>
            <typeparam name="T">The type of array elements.</typeparam>
            <param name="array">The array to index.</param>
            <param name="match">The predicate to apply.</param>
            <returns>The index of the first matching element.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method searches an array from beginning to end and returns the first item that
            matches a predicate, or -1 if no item matches:
            <code>
            var array = new[] { 1, 2, 3, 4 };
            var i = array.IndexOf(x =&gt; x &gt; 2);
            Console.WriteLine(i);
            // output:
            // 2
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Arrays.CopyTo``2(System.Collections.Generic.IEnumerable{``0},``1[],System.Int32,System.Int32,System.Func{``0,``1})">
            <summary>
            Copies <paramref name="count"/> entries from <paramref name="source"/> to <paramref name="target"/> array while performing a conversion.
            </summary>
            <typeparam name="T0">The source type.</typeparam>
            <typeparam name="T1">The target type.</typeparam>
            <param name="source">The source stream.</param>
            <param name="target">The target array.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of items to copy.</param>
            <param name="selector">The conversion function.</param>
            <returns>The number of items that were copied.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if index is outside the array bounds.</exception>
        </member>
        <member name="M:Sasa.Collections.Arrays.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,``1})">
            <summary>
            Converts a stream to an array while performing a conversion.
            </summary>
            <typeparam name="T0">The source type.</typeparam>
            <typeparam name="T1">The target type.</typeparam>
            <param name="source">The source stream.</param>
            <param name="count">The maximum number of items to copy.</param>
            <param name="selector">The conversion function.</param>
            <returns>An array of max size <paramref name="count"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="count"/> is outside the array bounds.</exception>
        </member>
        <member name="M:Sasa.Collections.Arrays.ConvertAll``2(``0[],System.Converter{``0,``1})">
            <summary>
            Convert array items to another type.
            </summary>
            <typeparam name="T0">The source type.</typeparam>
            <typeparam name="T1">The target type.</typeparam>
            <param name="source">The source array.</param>
            <param name="selector">The conversion function.</param>
            <returns>The new array.</returns>
        </member>
        <member name="T:Sasa.Collections.Dictionaries">
            <summary>
            Useful extensions to <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
        </member>
        <member name="M:Sasa.Collections.Dictionaries.FindOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Returns the value named by <paramref name="key"/>, or <see cref="P:Sasa.Option`1.None"/> if not present.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dict">The dictionary.</param>
            <param name="key">The dictionary key.</param>
            <returns>The value bound by the key, or <see cref="P:Sasa.Option`1.None"/> if key is unbound.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method checks for the presence of a key, and if not present, returns
            <see cref="P:Sasa.Option`1.None"/>:
            <code>
            var dict = new Dictionary&lt;string, int&gt;
            {
              { "foo",          0 },
              { "hello world!", 9 },
            };
            var hasBar = dict.FindOrDefault("bar")
                      || 666;
            Console.WriteLine(hasBar);
            // output:
            // 666
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Dictionaries.FindOrOtherwise``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Returns the value named by <paramref name="key"/>, or
            <paramref name="value"/> if key not present.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dict">The dictionary.</param>
            <param name="key">The dictionary key.</param>
            <param name="value">The value to return if key does not exist.</param>
            <returns>The value bound by the key, or <paramref name="value"/> if key is unbound.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Collections.Dictionaries.InsertDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Adds the value to the dictionary if it does not already exist.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dict">The dictionary.</param>
            <param name="key">The dictionary key.</param>
            <param name="value">The value to insert.</param>
            <returns>True if the item was inserted, false if the key already exists.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method inserts a default value only if the key is currently unbound:
            <code>
            var dict = new Dictionary&lt;string, int&gt;
            {
              { "foo",          0 },
              { "hello world!", 9 },
            };
            dict.InsertDefault("bar", 666);
            dict.InsertDefault("foo", () =&gt; 1234);
            
            Console.WriteLine(dict["foo"]);
            Console.WriteLine(dict["bar"]);
            // output:
            // 0
            // 666
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Collections.Dictionaries.InsertDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>
            Adds the value to the dictionary if it does not already exist.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dict">The dictionary.</param>
            <param name="key">The dictionary key.</param>
            <param name="value">The function to generate the value to insert.</param>
            <returns>True if the item was inserted, false if the key already exists.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method inserts a default value only if the key is currently unbound:
            <code>
            var dict = new Dictionary&lt;string, int&gt;
            {
              { "foo",          0 },
              { "hello world!", 9 },
            };
            dict.InsertDefault("bar", 666);
            dict.InsertDefault("foo", () =&gt; 1234);
            
            Console.WriteLine(dict["foo"]);
            Console.WriteLine(dict["bar"]);
            // output:
            // 0
            // 666
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Collections.IAtomic`1">
            <summary>
            A value type that can be updated atomically.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="M:Sasa.Collections.IAtomic`1.Set(`0@)">
            <summary>
            The update operation.
            </summary>
            <param name="slot">The slot to update atomically.</param>
            <returns>True if the slot was set, false otherwise.</returns>
        </member>
        <member name="T:Sasa.Concurrency.RWLock">
            <summary>
            A truly slim read-write lock.
            </summary>
            <remarks>
            This is a truly slim read/write lock, amounting to only an integer field to
            track the number of active readers. Write locks require the client to
            provide a shared object upon which all writers sync.
            
            Note that you cannot "upgrade" a read lock into a write lock. If you try
            to acquire a write lock inside a read lock, or a read lock inside a write
            lock, your program will deadlock.
            
            Recursive read locks are safe. Recursive write locks are not permitted.
            Attempting to acquire a recursive write lock will throw <see cref="T:System.Threading.LockRecursionException"/>.
            
            The only exception to this rule are the TryEnterReadLock and
            TryEnterWriteLock methods. These will never block or deadlock under any
            circumstances.
            </remarks>
        </member>
        <member name="M:Sasa.Concurrency.RWLock.EnterReadLock">
            <summary>
            Block until a read lock is acquired.
            </summary>
        </member>
        <member name="M:Sasa.Concurrency.RWLock.ExitReadLock">
            <summary>
            Release a read lock.
            </summary>
        </member>
        <member name="M:Sasa.Concurrency.RWLock.TryEnterReadLock">
            <summary>
            Attempt to enter a read lock.
            </summary>
            <returns>True if read lock safely acquired, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Concurrency.RWLock.EnterWriteLock(System.Object)">
            <summary>
            Acquire a write lock.
            </summary>
            <param name="sync">The object writers use to synchronize.</param>
        </member>
        <member name="M:Sasa.Concurrency.RWLock.TryEnterWriteLock(System.Object)">
            <summary>
            Attempt to acquire a write lock.
            </summary>
            <param name="sync">The object writers use to synchronize.</param>
            <returns>True if write lock acquired, false otherwise.</returns>
            <remarks>
            This method does not block under any circumstances. Either the write lock is acquired
            immediately and it returns true, or it returns false.
            </remarks>
        </member>
        <member name="M:Sasa.Concurrency.RWLock.ExitWriteLock(System.Object)">
            <summary>
            Release a write lock.
            </summary>
            <param name="sync">The object writers use to synchronize.</param>
        </member>
        <member name="M:Sasa.Concurrency.RWLock.Check(System.Int32,System.Boolean)">
            <summary>
            Check the lock's invariants.
            </summary>
            <param name="readers"></param>
            <param name="writeLock"></param>
        </member>
        <member name="T:Sasa.Concurrency.LockSet">
            <summary>
            Obtains locks on a set of objects in hashcode order.
            </summary>
        </member>
        <member name="M:Sasa.Concurrency.LockSet.Acquire``2(``0,``1)">
            <summary>
            Acquire locks on two objects.
            </summary>
            <typeparam name="T0">The type of the first object to lock.</typeparam>
            <typeparam name="T1">The type of the second object to lock.</typeparam>
            <param name="obj0">The first object to lock.</param>
            <param name="obj1">The second object to lock.</param>
        </member>
        <member name="M:Sasa.Concurrency.LockSet.Release``2(``0,``1)">
            <summary>
            Release locks on two objects.
            </summary>
            <typeparam name="T0">The type of the first locked object.</typeparam>
            <typeparam name="T1">The type of the second locked object locked.</typeparam>
            <param name="obj0">The first object to lock.</param>
            <param name="obj1">The second object to lock.</param>
        </member>
        <member name="M:Sasa.Concurrency.LockSet.Acquire``3(``0,``1,``2)">
            <summary>
            Acquire locks on three objects.
            </summary>
            <typeparam name="T0">The type of the first locked object.</typeparam>
            <typeparam name="T1">The type of the second locked object locked.</typeparam>
            <typeparam name="T2">The third object type to lock.</typeparam>
            <param name="obj0">The first object to lock.</param>
            <param name="obj1">The second object to lock.</param>
            <param name="obj2">The third object to lock.</param>
        </member>
        <member name="M:Sasa.Concurrency.LockSet.Release``3(``0,``1,``2)">
            <summary>
            Release locks on three objects.
            </summary>
            <typeparam name="T0">The type of the first locked object.</typeparam>
            <typeparam name="T1">The type of the second locked object locked.</typeparam>
            <typeparam name="T2">The third object type to lock.</typeparam>
            <param name="obj0">The first object to release.</param>
            <param name="obj1">The second object to release.</param>
            <param name="obj2">The third object to release.</param>
        </member>
        <member name="M:Sasa.Concurrency.LockSet.Scoped(System.Object[])">
            <summary>
            Return a disposable LockSet encapsulating the locks taken.
            </summary>
            <param name="objects">The list of objects to lock.</param>
            <returns>A disposable, remembered set of locked objects.</returns>
        </member>
        <member name="M:Sasa.Concurrency.LockSet.Dispose">
            <summary>
            Dispose of any locks taken in reverse order.
            </summary>
        </member>
        <member name="T:Sasa.Concurrency.LockSet.HashCodeComparer">
            <summary>
            Used to order objects by their hashcode.
            </summary>
        </member>
        <member name="T:Sasa.ImmutableAttribute">
            <summary>
            This declares a class or struct as immutable.
            </summary>
        </member>
        <member name="T:Sasa.ISlot`2">
            <summary>
            A slot that references a member of type <typeparamref name="T"/> in an object of type <typeparamref name="TObj"/>.
            </summary>
            <typeparam name="TObj">The object type containing the slot.</typeparam>
            <typeparam name="T">The type of value in the slot.</typeparam>
        </member>
        <member name="M:Sasa.ISlot`2.Get(`0)">
            <summary>
            Obtain the current slot value from <typeparamref name="TObj"/>.
            </summary>
            <param name="obj">The object to inspect.</param>
            <returns>The value of the slot within <typeparamref name="TObj"/>.</returns>
        </member>
        <member name="M:Sasa.ISlot`2.Set(`0,`1)">
            <summary>
            Assign the slot given the object and a new value.
            </summary>
            <param name="obj">The object whose slot to update.</param>
            <param name="value">The new value of the slot.</param>
            <returns>The new slot value.</returns>
        </member>
        <member name="T:Sasa.ISlotVisitor">
            <summary>
            A visitor for slots.
            </summary>
        </member>
        <member name="M:Sasa.ISlotVisitor.Array``1(Sasa.Slot.Array{``0})">
            <summary>
            The slot indexes arrays.
            </summary>
            <typeparam name="T">The array element type.value.</typeparam>
            <param name="arraySlot">The array slot.</param>
        </member>
        <member name="M:Sasa.ISlotVisitor.Member``2(Sasa.Slot.Member{``0,``1})">
            <summary>
            The slot references object members.
            </summary>
            <typeparam name="TObj">The object type to inspect.</typeparam>
            <typeparam name="T">The member type.</typeparam>
            <param name="memberSlot">The slot accessor for an object member.</param>
        </member>
        <member name="T:Sasa.Slot">
            <summary>
            Base class for slots.
            </summary>
        </member>
        <member name="M:Sasa.Slot.Visit(Sasa.ISlotVisitor)">
            <summary>
            Dispatch to the visitor case for a slot.
            </summary>
            <param name="visitor">The visitor to dispatch to.</param>
        </member>
        <member name="T:Sasa.Slot.Member`2">
            <summary>
            A slot that references an object member.
            </summary>
            <typeparam name="TObj">The object type containing the member.</typeparam>
            <typeparam name="T">The member type.</typeparam>
        </member>
        <member name="F:Sasa.Slot.Member`2.Get">
            <summary>
            The getter delegate for the member.
            </summary>
        </member>
        <member name="F:Sasa.Slot.Member`2.Set">
            <summary>
            The setter delegate for the member.
            </summary>
        </member>
        <member name="M:Sasa.Slot.Member`2.#ctor(System.Func{`0,`1},System.Action{`0,`1})">
            <summary>
            Construct a member slot.
            </summary>
            <param name="mget">The member getter delegate.</param>
            <param name="mset">The member setter delegate.</param>
        </member>
        <member name="M:Sasa.Slot.Member`2.Visit(Sasa.ISlotVisitor)">
            <summary>
            Dispatch to the visitor case for members.
            </summary>
            <param name="visitor">The visitor to dispatch to.</param>
        </member>
        <member name="T:Sasa.Slot.Array`1">
            <summary>
            A slot that references an array index.
            </summary>
            <typeparam name="T">The array type.</typeparam>
        </member>
        <member name="F:Sasa.Slot.Array`1.Index">
            <summary>
            The array index.
            </summary>
        </member>
        <member name="M:Sasa.Slot.Array`1.#ctor(System.Int32)">
            <summary>
            Construct an array slot.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Sasa.Slot.Array`1.Get(`0[])">
            <summary>
            Obtain the array slot value.
            </summary>
            <param name="obj">The array to index.</param>
            <returns>The array slot value.</returns>
        </member>
        <member name="M:Sasa.Slot.Array`1.Set(`0[],`0)">
            <summary>
            Assign the array slot.
            </summary>
            <param name="obj">The slot to assign.</param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Sasa.Slot.Array`1.Visit(Sasa.ISlotVisitor)">
            <summary>
            Dispatch to the visitor case for arrays.
            </summary>
            <param name="visitor">The visitor to dispatch to.</param>
        </member>
        <member name="M:Sasa.Slot.Create``2(System.Func{``0,``1},System.Action{``0,``1})">
            <summary>
            Create a reference into an object.
            </summary>
            <typeparam name="TObj">The object type of that has the slot.</typeparam>
            <typeparam name="T">The type of the reference's value.</typeparam>
            <param name="get">The property getter.</param>
            <param name="set">The property setter.</param>
            <returns>A first-class reference to an object's property.</returns>
        </member>
        <member name="M:Sasa.Slot.Create``1(System.Int32)">
            <summary>
            Create a reference into an array.
            </summary>
            <typeparam name="T">The type of the array slots.</typeparam>
            <param name="index">The array index.</param>
            <returns>A first-class slot for arrays.</returns>
        </member>
        <member name="M:Sasa.Slot.Create``2(System.Reflection.MemberInfo)">
            <summary>
            Construct a reference for a field.
            </summary>
            <typeparam name="TObj">The object type being referenced.</typeparam>
            <typeparam name="T">The field type being referenced.</typeparam>
            <param name="member">The field being referenced.</param>
            <returns>A reference offering direct access to a field.</returns>
        </member>
        <member name="M:Sasa.Slot.Create``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Construct a reference for a field.
            </summary>
            <typeparam name="TObj">The object type being referenced.</typeparam>
            <typeparam name="T">The field type being referenced.</typeparam>
            <param name="member">The field being referenced.</param>
            <returns>A reference offering direct access to a field.</returns>
        </member>
        <member name="T:Sasa.Changeable`1">
            <summary>
            A changeable value that notifies listeners of any changes.
            </summary>
            <typeparam name="T">The type of encapsulated value.</typeparam>
        </member>
        <member name="P:Sasa.Changeable`1.Value">
            <summary>
            The encapsulated value.
            </summary>
        </member>
        <member name="M:Sasa.Changeable`1.Update(System.String,`0,System.ComponentModel.PropertyChangingEventHandler,System.ComponentModel.PropertyChangedEventHandler)">
            <summary>
            Update the encapsulated value and notify listeners of any changes.
            </summary>
            <param name="name">The property name.</param>
            <param name="value">The new value to assign.</param>
            <param name="onChanging">The <seealso cref="T:System.ComponentModel.PropertyChangingEventHandler"/> listeners.</param>
            <param name="onChanged">The <seealso cref="T:System.ComponentModel.PropertyChangedEventHandler"/> listeners.</param>
            <returns>True if the property changed, false otherwise.</returns>
        </member>
        <member name="T:Sasa.Runtime.Handle`1">
            <summary>
            Exposes a strongly typed interface to an encapsulated <seealso cref="T:System.Runtime.InteropServices.GCHandle"/>.
            </summary>
            <typeparam name="T">The type of the object in the WeakReference.</typeparam>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.#ctor(System.Runtime.InteropServices.GCHandle)">
            <summary>
            Construct a typed pointer reference from the given WeakReference.
            </summary>
            <param name="handle">The WeakReference to encapsulate.</param>
            <exception cref="T:System.InvalidCastException">If the provided WeakReference does not point
            to an object of type T.</exception>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.#ctor(`0)">
            <summary>
            Encapsulate the given object in a Weak ref.
            </summary>
            <param name="value">The object to encapsulate in a Weak reference.</param>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.#ctor(`0,System.Runtime.InteropServices.GCHandleType)">
            <summary>
            Encapsulate the given object in a Weak ref.
            </summary>
            <param name="value">The object to encapsulate in a Weak reference.</param>
            <param name="handleType">The type of handle tracking.</param>
        </member>
        <member name="P:Sasa.Runtime.Handle`1.Value">
            <summary>
            Access the underlying value, if it still exists.
            </summary>
            <remarks>
            This property obtains the current value encapsulated in the pointer reference, or null if the object has been collected:
            <code>
            string original = new string("hello world!".ToCharArray());
            Weak&lt;string&gt; foo = original;
            Console.WriteLine(foo.Value);
            
            // lose all live references and run collection
            original = null;
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Console.WriteLine(foo.Value ?? "&lt;null&gt;");
            
            // outputs:
            // hello world!
            // &lt;null&gt;
            </code>
            This property also fulfills the requirements for the <see cref="T:Sasa.IValue`1"/> interface.
            </remarks>
        </member>
        <member name="P:Sasa.Runtime.Handle`1.IsAlive">
            <summary>
            True if the reference is still alive.
            </summary>
            <remarks>
            This property checks whether the target of the pointer reference has yet to be collected:
            <code>
            string original = new string("hello world!".ToCharArray());
            Weak&lt;string&gt; foo = original;
            Console.WriteLine(foo.IsAlive);
            
            // lose all live references and run collection
            original = null;
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Console.WriteLine(foo.IsAlive);
            
            // outputs:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Runtime.Handle`1.HasValue">
            <summary>
            True if the reference is still alive.
            </summary>
            <remarks>
            This property has the same purpose as <see cref="P:Sasa.Weak`1.IsAlive"/>, but fulfills the requirements to
            satisfy the <see cref="T:Sasa.IResolvable`1"/> interface:
            <code>
            string original = new string("hello world!".ToCharArray());
            Weak&lt;string&gt; foo = original;
            Console.WriteLine(foo.HasValue);
            
            // lose all live references and run collection
            original = null;
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Console.WriteLine(foo.HasValue);
            
            // outputs:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.TryGetValue(`0@)">
            <summary>
            Extract the value behind the pointer reference.
            </summary>
            <param name="value">The underlying value.</param>
            <returns>True if the value is alive, false otherwise.</returns>
            <remarks>
            This method checks whether a pointer reference to a target is alive, and returns a live reference to that target in one step:
            <code>
            string original = new string("hello world!".ToCharArray());
            Weak&lt;string&gt; foo = original;
            Console.WriteLine(foo.TryGetValue(out original));
            Console.WriteLine(original);
            
            // lose all live references and run collection
            original = null;
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Console.WriteLine(foo.TryGetValue(out original));
            Console.WriteLine(original ?? "&lt;null&gt;");
            
            // outputs:
            // true
            // hello world!
            // false
            // &lt;null&gt;
            </code>
            This method also satisfies the requirements for the <see cref="T:Sasa.IVolatile`1"/> interface.
            </remarks>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.Equals(`0)">
            <summary>
            Compares the given object for equality.
            </summary>
            <param name="other">The object to compare against.</param>
            <returns>True if the underlying object is equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.Equals(Sasa.Runtime.Handle{`0})">
            <summary>
            Compares the given object for equality.
            </summary>
            <param name="other">The object to compare against.</param>
            <returns>True if the underlying object is equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.Equals(System.Object)">
            <summary>
            Equality test.
            </summary>
            <param name="obj">The object to compare for equality.</param>
            <returns>True if the objects are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.GetHashCode">
            <summary>
            Hashcode override.
            </summary>
            <returns>The integer hash code.</returns>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.Free">
            <summary>
            Frees the GC handle.
            </summary>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.op_Implicit(Sasa.Runtime.Handle{`0})~`0">
            <summary>
            Implicitly extract the value encapsulated in the Weak ref.
            </summary>
            <param name="pointer">The Weak reference from which to extract the value.</param>
            <returns>The value encapsulated in the Weak ref.</returns>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.op_Equality(Sasa.Runtime.Handle{`0},Sasa.Runtime.Handle{`0})">
            <summary>
            Compares two pointer references for equality.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Runtime.Handle`1.op_Inequality(Sasa.Runtime.Handle{`0},Sasa.Runtime.Handle{`0})">
            <summary>
            Compares two pointer references for inequality.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="T:Sasa.Linq._">
            <summary>
            A placeholder type.
            </summary>
        </member>
        <member name="T:Sasa.Linq.Arity">
            <summary>
            A call-site that overloads the number of generic parameters.
            </summary>
        </member>
        <member name="P:Sasa.Linq.Arity.Item(System.Type[])">
            <summary>
            Resolve the method based on the arity and the type parameters.
            </summary>
            <param name="types">The type parameters for the method.</param>
            <returns>The fully resolved overloaded method.</returns>
        </member>
        <member name="P:Sasa.Linq.Arity.Item(System.Int32,System.Type[])">
            <summary>
            Resolve the method based on the arity and the type parameters.
            </summary>
            <param name="arity">The generic parameter arity of the method.</param>
            <param name="types">The type parameters for the method.</param>
            <returns>The fully resolved overloaded method.</returns>
        </member>
        <member name="M:Sasa.Linq.Arity.Declare``1(``0[])">
            <summary>
            Declare a list of overloaded generic delegates.
            </summary>
            <typeparam name="TFunc">The delegate types.</typeparam>
            <param name="delegates">The available dispatch targets overloaded by arity.</param>
            <returns>An <see cref="T:Sasa.Linq.Arity"/> instance that dispatches to the correct overload.</returns>
        </member>
        <member name="T:Sasa.Linq.ChangeType">
            <summary>
            Describes the type of change that was made.
            </summary>
        </member>
        <member name="F:Sasa.Linq.ChangeType.Add">
            <summary>
            An item was added at the given position.
            </summary>
        </member>
        <member name="F:Sasa.Linq.ChangeType.Remove">
            <summary>
            An item was removed at the given position.
            </summary>
        </member>
        <member name="T:Sasa.Linq.Change`1">
            <summary>
            Describes a change to a collection.
            </summary>
            <typeparam name="T">The collection item type.</typeparam>
        </member>
        <member name="P:Sasa.Linq.Change`1.ChangeType">
            <summary>
            The change made at the given position.
            </summary>
        </member>
        <member name="P:Sasa.Linq.Change`1.Values">
            <summary>
            The set of values added or removed from the given position.
            </summary>
        </member>
        <member name="P:Sasa.Linq.Change`1.Position">
            <summary>
            The position in the sequence where the change took place.
            </summary>
        </member>
        <member name="M:Sasa.Linq.Change`1.ToString">
            <summary>
            Generate a string representation of this change.
            </summary>
            <returns>A string representation of this change.</returns>
        </member>
        <member name="M:Sasa.Linq.Change`1.Equals(Sasa.Linq.Change{`0})">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="other">The object to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Linq.Change`1.Equals(System.Object)">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Linq.Change`1.GetHashCode">
            <summary>
            Computes the hash code for the object.
            </summary>
            <returns>The integer hash code.</returns>
        </member>
        <member name="M:Sasa.Linq.Change`1.op_Equality(Sasa.Linq.Change{`0},Sasa.Linq.Change{`0})">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="left">The left object to compare.</param>
            <param name="right">The right object to compare.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Linq.Change`1.op_Inequality(Sasa.Linq.Change{`0},Sasa.Linq.Change{`0})">
            <summary>
            Compares struct for inequality.
            </summary>
            <param name="left">The left object to compare.</param>
            <param name="right">The right object to compare.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="T:Sasa.Linq.Enumerables">
            <summary>
            Extension on <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
            <summary>
            Extensions to IEnumerable.
            </summary>
            <remarks>
            The release of .NET 3.5 and LINQ to Objects was one of the greatest productivity and safety
            enhancements to .NET since its inception. It enabled the concise expression of highly generic
            algorithms depending solely on the simple notion of an iterable stream,
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>. You could then specify semantics for duplicates, ordering,
            and grouping constraints over streams with a nice query syntax or a simple first-class
            function syntax.
            
            The advent of extension methods allowed such extensions to be packaged into a neat, consistent
            framework under <see cref="T:System.Linq.Enumerable"/>. <see cref="T:Sasa.Linq.Enumerables"/>
            extends the functionality for <see cref="T:System.Collections.Generic.IEnumerable`1"/> even further.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Difference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Compute the set of differences between two sequences.
            </summary>
            <typeparam name="T">The type of sequence items.</typeparam>
            <param name="original">The original sequence.</param>
            <param name="updated">The updated sequence to compare to.</param>
            <returns>The smallest sequence of changes to transform <paramref name="original"/> into <paramref name="updated"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on IEnumerable&lt;T&gt; that produces a stream of <see cref="T:Sasa.Linq.Change`1"/> values
            indicating the changes needed to transform one stream into another:
            <code>
            IEnumerable&lt;int&gt; first = new[] { 3, 99, 8, -5, 12, -9 };
            IEnumerable&lt;int&gt; second = new[] { 3, 99, -5, 12, 66, 234, -9 };
            IEnumerable&lt;ChangeType&lt;int&gt;&gt; diff = first.Difference(second);
            foreach (var x in diff)
            {
                Console.WriteLine(x);
            }
            // output:
            // -1:99
            // +1:99,8
            // +5:66, 234
            </code>
            Basically, the 'diff' stream in the above sample describes the changes you have to make to 'first'
            in order to transform it into the stream 'second'. This is fully described by the output which
            specifies a subtraction at position 1 of the value 99, an addition at position 1 of values 99 and 8,
            and the addition of two values at position 5 of 66 and 234.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Difference(System.String,System.String)">
            <summary>
            Compute the set of differences between two sequences.
            </summary>
            <param name="original">The original sequence.</param>
            <param name="updated">The updated sequence to compare to.</param>
            <returns>The smallest sequence of changes to transform <paramref name="original"/> into <paramref name="updated"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on IEnumerable&lt;T&gt; that produces a stream of <see cref="T:Sasa.Linq.Change`1"/> values
            indicating the changes needed to transform one stream into another:
            <code>
            IEnumerable&lt;int&gt; first = new[] { 3, 99, 8, -5, 12, -9 };
            IEnumerable&lt;int&gt; second = new[] { 3, 99, -5, 12, 66, 234, -9 };
            IEnumerable&lt;ChangeType&lt;int&gt;&gt; diff = first.Difference(second);
            foreach (var x in diff)
            {
                Console.WriteLine(x);
            }
            // output:
            // -1:99
            // +1:99,8
            // +5:66, 234
            </code>
            Basically, the 'diff' stream in the above sample describes the changes you have to make to 'first'
            in order to transform it into the stream 'second'. This is fully described by the output which
            specifies a subtraction at position 1 of the value 99, an addition at position 1 of values 99 and 8,
            and the addition of two values at position 5 of 66 and 234.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Difference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compute the set of differences between two sequences.
            </summary>
            <typeparam name="T">The type of sequence items.</typeparam>
            <param name="original">The original sequence.</param>
            <param name="updated">The updated sequence to compare to.</param>
            <param name="comparer">The equality comparer to use.</param>
            <returns>The smallest sequence of changes to transform <paramref name="original"/> into <paramref name="updated"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on IEnumerable&lt;T&gt; that produces a stream of <see cref="T:Sasa.Linq.Change`1"/> values
            indicating the changes needed to transform one stream into another:
            <code>
            IEnumerable&lt;int&gt; first = new[] { 3, 99, 8, -5, 12, -9 };
            IEnumerable&lt;int&gt; second = new[] { 3, 99, -5, 12, 66, 234, -9 };
            IEnumerable&lt;ChangeType&lt;int&gt;&gt; diff = first.Difference(second);
            foreach (var x in diff)
            {
                Console.WriteLine(x);
            }
            // output:
            // -1:99
            // +1:99,8
            // +5:66, 234
            </code>
            Basically, the 'diff' stream in the above sample describes the changes you have to make to 'first'
            in order to transform it into the stream 'second'. This is fully described by the output which
            specifies a subtraction at position 1 of the value 99, an addition at position 1 of values 99 and 8,
            and the addition of two values at position 5 of 66 and 234.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Difference``1(``0[],``0[],System.Func{``0,``0,System.Boolean})">
            <summary>
            Compute the set of differences between two sequences.
            </summary>
            <typeparam name="T">The type of sequence items.</typeparam>
            <param name="n">The original sequence.</param>
            <param name="m">The updated sequence to compare to.</param>
            <param name="comparer">The equality comparer to use.</param>
            <returns>The smallest sequence of changes to transform <paramref name="n"/> into <paramref name="m"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Linq.Enumerables.SingleSelect``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Selects a property of <typeparamref name="TContainer"/> if the source isn't null.
            </summary>
            <typeparam name="TContainer">The container type.</typeparam>
            <typeparam name="TValue">The returned type.</typeparam>
            <param name="source">The enumerable source.</param>
            <param name="selector">The final property getter.</param>
            <returns>The encapsulated value of <paramref name="source"/> has a non-null single result.</returns>
        </member>
        <member name="M:Sasa.Linq.Enumerables.SingleSelect``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Selects a property of <typeparamref name="TContainer"/> if the source isn't null.
            </summary>
            <typeparam name="TContainer">The container type.</typeparam>
            <typeparam name="TValue">The returned type.</typeparam>
            <param name="source">The enumerable source.</param>
            <param name="predicate">The predicate filter.</param>
            <param name="selector">The final property getter.</param>
            <returns>The encapsulated value of <paramref name="source"/> has a non-null single result that matches the predicate.</returns>
        </member>
        <member name="M:Sasa.Linq.Enumerables.FirstSelect``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Selects a property of <typeparamref name="TContainer"/> if the source isn't null.
            </summary>
            <typeparam name="TContainer">The container type.</typeparam>
            <typeparam name="TValue">The returned type.</typeparam>
            <param name="source">The enumerable source.</param>
            <param name="selector">The final property getter.</param>
            <returns>The encapsulated value of <paramref name="source"/> has a non-null first result.</returns>
        </member>
        <member name="M:Sasa.Linq.Enumerables.FirstSelect``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Selects a property of <typeparamref name="TContainer"/> if the source isn't null.
            </summary>
            <typeparam name="TContainer">The container type.</typeparam>
            <typeparam name="TValue">The returned type.</typeparam>
            <param name="source">The enumerable source.</param>
            <param name="predicate">The predicate filter.</param>
            <param name="selector">The final property getter.</param>
            <returns>The encapsulated value of <paramref name="source"/> has a non-null first result that matches the predicate.</returns>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Do``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Consumes a sequence while applying a function to each element.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="source">The enumerator.</param>
            <param name="func">The function to apply.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that fully consumes  a stream while applying a
            function to each element:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 };
            source.Do(Console.WriteLine);
            // output:
            // 2
            // 99
            // 8
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Apply a function to each element of the collection.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="source">The enumerator.</param>
            <param name="func">The function to aplpy.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that applies an Action&lt;T&gt; to every value as the
            stream is being iterated:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 }
                                           .Apply(Console.Write);
            foreach (var x in source)
            {
                Console.WriteLine();
            }
            // output:
            // 2
            // 99
            // 8
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Push``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the given item to the beginning of a sequence.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="head">The new first element of the enumeration.</param>
            <param name="tail">The rest of the enumeration.</param>
            <returns>An enumeration with 'head' as the first value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on pushes an element to the front of an enumerable sequence:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 };
            Console.WriteLine(source.Push(-1).Format(","));
            // output:
            // -1, 2, 99, 8
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Append an item to the end of an enumeration.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="source">The enumeration being modified.</param>
            <param name="last">The element being appended to the enumeration.</param>
            <returns>An enumeration with a new last element.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method on <see cref="T:System.Collections.Generic.IEnumerable`1"/> to add a single element to the end of a sequence:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 };
            IEnumerable&lt;int&gt; sourcePlusOne = source.Append(-10);
            foreach (var x in sourcePlusOne)
            {
                Console.WriteLine(x);
            }
            // output:
            // 2
            // 99
            // 8
            // -10
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.ReplaceElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0)">
            <summary>
            Replaces the element at the specified index.
            </summary>
            <typeparam name="T">The enumerated type.</typeparam>
            <param name="source">The source enumeration.</param>
            <param name="index">The element at this index is replaced.</param>
            <param name="value">The new value to insert.</param>
            <returns>An enumeration with the replaced value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that replaces the element at a specified index with
            a new value:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 }
                                           .ReplaceElementAt(index: 1, value: -1);
            Console.WriteLine(source.Format(","));
            // output:
            // 2, -1, 8
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Flatten``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Flattens a nested enumerable.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="source">The nested enumerable.</param>
            <returns>A flattened stream.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that flattens a nested sequence:
            <code>
            IEnumerable&lt;IEnumerable&lt;int&gt;&gt; source = new int[][]
            {
                new[] { 2, 99 },
                new[] { 8 }
            };
            IEnumerable&lt;int&gt; flat = source.Flatten();
            flat.Do(Console.WriteLine);
            // output:
            // 2
            // 99
            // 8
            </code>
            This is functionally equivalent to:
            <code>
            IEnumerable&lt;int&gt; flat = source.SelectMany(x =&gt; x);
            </code>
            Except the C# compiler won't have to create so many delegates in all the various assemblies
            that flatten sequences.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Format``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Formats each element of the stream with the given separator between them.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="source">The input stream to format.</param>
            <param name="separator">The element separating each element of the stream.</param>
            <returns>A formatted string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            Format is a set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that make it easy to construct
            a string from a sequence. Basically, you provide a sequence and a value separator, like ",", and
            Format will output each value in the sequence spaced with the separator:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 };
            string formatted = source.Format(", ");
            Console.WriteLine(formatted);
            // output:
            // 2, 99, 8
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Format``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>
            Formats each element of the stream with the given separator between them.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="source">The input stream to format.</param>
            <param name="separator">The element separating each element of the stream.</param>
            <param name="toString">The function used to convert each element to a string.</param>
            <returns>A formatted string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            Format is a set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that make it easy to construct
            a string from a sequence. Basically, you provide a sequence and a value separator, like ",", and
            Format will output each value in the sequence spaced with the separator:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 };
            string formatted = source.Format(", ");
            Console.WriteLine(formatted);
            // output:
            // 2, 99, 8
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Format``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Text.StringBuilder)">
            <summary>
            Formats each element of the stream with the given separator between them.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="source">The input stream to format.</param>
            <param name="separator">The element separating each element of the stream.</param>
            <param name="output">The StringBuilder to which the output is written.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            Format is a set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that make it easy to construct
            a string from a sequence. Basically, you provide a sequence and a value separator, like ",", and
            Format will output each value in the sequence spaced with the separator:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 };
            string formatted = source.Format(", ");
            Console.WriteLine(formatted);
            // output:
            // 2, 99, 8
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Format``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Text.StringBuilder,System.Func{``0,System.String})">
            <summary>
            Formats each element of the stream with the given separator between them.
            </summary>
            <typeparam name="T">The type being enumerated.</typeparam>
            <param name="source">The input stream to format.</param>
            <param name="separator">The element separating each element of the stream.</param>
            <param name="output">The StringBuilder to which the output is written.</param>
            <param name="toString">The function used to convert each element to a string.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            Format is a set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that make it easy to construct
            a string from a sequence. Basically, you provide a sequence and a value separator, like ",", and
            Format will output each value in the sequence spaced with the separator:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 2, 99, 8 };
            string formatted = source.Format(", ");
            Console.WriteLine(formatted);
            // output:
            // 2, 99, 8
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.CompareTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Performs an ordered comparison on two sequences.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="first">The first sequence.</param>
            <param name="second">The second sequence.</param>
            <returns>Zero if two sequences are equal, greater than zero if <paramref name="first"/>
            &gt; <paramref name="second"/>, less than zero otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that performs an element-wise comparison between two
            streams in the same vein as the <see cref="T:System.IComparable`1"/> interface:
            <code>
            IEnumerable&lt;int&gt; largest = new[] { 3, 99, 8 };
            IEnumerable&lt;int&gt; larger  = new[] { 2, 99, 8 };
            IEnumerable&lt;int&gt; smaller = new[] { 2, 98, 8 };
            
            Console.WriteLine(largest.CompareTo(larger));
            Console.WriteLine(larger.CompareTo(smaller));
            Console.WriteLine(smaller.CompareTo(largest));
            Console.WriteLine(smaller.CompareTo(smaller));
            // output:
            // 1
            // 1
            // -1
            // 0
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Generate``1(``0,System.Func{``0,Sasa.Option{``0}})">
            <summary>
            Generate a sequence of elements given a generator function.
            </summary>
            <typeparam name="T">The type of sequence elements.</typeparam>
            <param name="seed">The initial seed value.</param>
            <param name="generator">The generator function.</param>
            <returns>A sequence of elements.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This static method is used to construct sequences of values by taking a seed value and a
            generator function:
            <code>
            Func&lt;int, Option&lt;int&gt;&gt; step = x =&gt; x &lt; 3 ? x + 1:
                                                       Option&lt;T&gt;.None;
            IEnumerable&lt;int&gt; source = Enumerables.Generate(0, step);
            Console.WriteLine(source.Format(", "));
            // output:
            // 0, 1, 2, 3
            </code>
            The generator function returns an <see cref="T:Sasa.Option`1"/>, so terminating the generator
            requires simply returning <see cref="P:Sasa.Option`1.None"/>.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.CopyTo``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)">
            <summary>
            Copy the elements of the stream to the given array starting at the given index.
            </summary>
            <typeparam name="T">The type of array elements.</typeparam>
            <param name="source">The source sequence.</param>
            <param name="array">The target array.</param>
            <param name="start">The starting index of the array.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that copies elements from the stream into a pre-allocated array:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 3, 99, 8, -5, 12, -999 };
            int[] buffer = new int[3];
            source.CopyTo(buffer, 0);
            foreach (var x in buffer)
            {
                Console.Write("{0}, ", x);
            }
            // output:
            // 3, 99, 8,
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.CopyTo``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32,System.Int32)">
            <summary>
            Copy the elements of the stream to the given array starting at the given index.
            </summary>
            <typeparam name="T">The type of array elements.</typeparam>
            <param name="source">The source sequence.</param>
            <param name="array">The target array.</param>
            <param name="start">The starting index of the array.</param>
            <param name="count">The number of elements to copy.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if <paramref name="start"/> or <paramref name="count"/> index a location
            outside the bounds of <paramref name="array"/>.
            </exception>
            <remarks>
            This extension on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that copies elements from the stream into a pre-allocated array:
            <code>
            IEnumerable&lt;int&gt; source = new[] { 3, 99, 8, -5, 12, -999 };
            int[] buffer = new int[3];
            source.CopyTo(buffer, 0);
            foreach (var x in buffer)
            {
                Console.Write("{0}, ", x);
            }
            // output:
            // 3, 99, 8,
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Consume``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Consumes the entire sequence.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="source">The source sequence to consume.</param>
            <remarks>
            This extension on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that consumes a whole stream in one go:
            <code>
            static IEnumerable&lt;int&gt; Foo()
            {
                for (int i = 0; i &lt; 3; ++i)
                {
                    Console.WriteLine(i);
                    yield return i;
                }
            }
            ...
            Foo().Consume(); // consume stream and return when done
            // output:
            // 0
            // 1
            // 2
            </code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Transpose``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Swaps the rows and columns of a nested sequence.
            </summary>
            <typeparam name="T">The type of elements in the sequence.</typeparam>
            <param name="source">The source sequence.</param>
            <returns>A sequence whose rows and columns are swapped.</returns>
            <remarks>
            This is an extension on a nested sequence, IEnumerable&lt;IEnumerable&lt;T&gt;&gt; that
            transposes the rows and columns:
            <code>
            IEnumerable&lt;IEnumerable&lt;int&gt;&gt; source = new int[][]
            {
                new[] { 2, 99 },
                new[] { 8, -10 }
            };
            // transpose the rows and columns
            foreach (var row in source.Transpose())
            {
                foreach (var column in row)
                {
                    Console.Write("{0}, ", column);
                }
                Console.WriteLine();
            }
            flat.Do(Console.WriteLine);
            // output:
            // 2, 8
            // 99, -10
            </code>
            Note that this method will handle jagged sequences, but transposing
            twice will not necessarily recover the same sequence as the original
            input. All the jagged entries will be pushed to the last row.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Interleave``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Interleave the elements of a set of sequences.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="first">The first sequence.</param>
            <param name="second">The second sequence</param>
            <returns>An interleave sequence.</returns>
            <remarks>
            This extension produces a sequence that reads from each given sequence in round robin
            order, until all sequences are exhausted:
            <code>
            var interleaved = new[] { 1, 2 }.Interleave(new[] { 3, 4, 5 }, new[] { 6, 7 });
            flat.Do(Console.WriteLine);
            // output:
            // 1, 3, 6, 2, 4, 7, 5
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Interleave``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Interleave the elements of a set of sequences.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="first">The first sequence.</param>
            <param name="second">The second sequence</param>
            <param name="third">The third sequence.</param>
            <returns>An interleave sequence.</returns>
            <remarks>
            This extension produces a sequence that reads from each given sequence in round robin
            order, until all sequences are exhausted:
            <code>
            var interleaved = new[] { 1, 2 }.Interleave(new[] { 3, 4, 5 }, new[] { 6, 7 });
            flat.Do(Console.WriteLine);
            // output:
            // 1, 3, 6, 2, 4, 7, 5
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Interleave``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Interleave the elements of a set of sequences.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="first">The first sequence.</param>
            <param name="second">The second sequence</param>
            <param name="third">The third sequence.</param>
            <param name="fourth">The fourth sequence.</param>
            <returns>An interleave sequence.</returns>
            <remarks>
            This extension produces a sequence that reads from each given sequence in round robin
            order, until all sequences are exhausted:
            <code>
            var interleaved = new[] { 1, 2 }.Interleave(new[] { 3, 4, 5 }, new[] { 6, 7 });
            flat.Do(Console.WriteLine);
            // output:
            // 1, 3, 6, 2, 4, 7, 5
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.ZipWith``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Zip two streams to a user-defined type.
            </summary>
            <typeparam name="T0">The type of the first stream.</typeparam>
            <typeparam name="T1">The type of the second stream.</typeparam>
            <typeparam name="T2">The type of the returned stream.</typeparam>
            <param name="first">The first stream.</param>
            <param name="second">The second stream.</param>
            <param name="selector">The function mapping the given stream values into the return value.</param>
            <returns>A stream of return values.</returns>
            <remarks>
            This set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that combines the elements of streams together element-wise
            using a client-specified function, returning a stream of values. This is known as "zipping" streams, analogously to the operation
            of a physical zipper where the teeth pair up one after another:
            <code>
            IEnumerable&lt;int&gt; source1 = new[] { 2, 99 };
            IEnumerable&lt;int&gt; source2 = new[] { 8, -10 };
            IEnumerable&lt;Pair&lt;int, int&gt;&gt; zipped = source1.ZipWith(source2, (x,y) =&gt; Tuples.Create(x,y));
            
            Console.WriteLine(zipped.Format("\r\n"));
            // output:
            // (2, 8)
            // (99, -10)
            </code>
            Like the Enumerables.Zip extension, ZipWith is defined for zipping up to 4 streams.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.ZipWith``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Zip three streams to a user-defined type.
            </summary>
            <typeparam name="T0">The type of the first stream.</typeparam>
            <typeparam name="T1">The type of the second stream.</typeparam>
            <typeparam name="T2">The type of the third stream.</typeparam>
            <typeparam name="T3">The type of the returned stream.</typeparam>
            <param name="first">The first stream.</param>
            <param name="second">The second stream.</param>
            <param name="third">The third stream.</param>
            <param name="selector">The function mapping the given stream values into the return value.</param>
            <returns>A stream of return values.</returns>
            <remarks>
            This set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that combines the elements of streams together element-wise
            using a client-specified function, returning a stream of values. This is known as "zipping" streams, analogously to the operation
            of a physical zipper where the teeth pair up one after another:
            <code>
            IEnumerable&lt;int&gt; source1 = new[] { 2, 99 };
            IEnumerable&lt;int&gt; source2 = new[] { 8, -10 };
            IEnumerable&lt;Pair&lt;int, int&gt;&gt; zipped = source1.ZipWith(source2, (x,y) =&gt; Tuples.Create(x,y));
            
            Console.WriteLine(zipped.Format("\r\n"));
            // output:
            // (2, 8)
            // (99, -10)
            </code>
            Like the Enumerables.Zip extension, ZipWith is defined for zipping up to 4 streams.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.ZipWith``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Zip four streams to a user-defined type.
            </summary>
            <typeparam name="T0">The type of the first stream.</typeparam>
            <typeparam name="T1">The type of the second stream.</typeparam>
            <typeparam name="T2">The type of the third stream.</typeparam>
            <typeparam name="T3">The type of the fourth stream.</typeparam>
            <typeparam name="T4">The type of the returned stream.</typeparam>
            <param name="first">The first stream.</param>
            <param name="second">The second stream.</param>
            <param name="third">The third stream.</param>
            <param name="fourth">The fourth stream.</param>
            <param name="selector">The function mapping the given stream values into the return value.</param>
            <returns>A stream of return values.</returns>
            <remarks>
            This set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that combines the elements of streams together element-wise
            using a client-specified function, returning a stream of values. This is known as "zipping" streams, analogously to the operation
            of a physical zipper where the teeth pair up one after another:
            <code>
            IEnumerable&lt;int&gt; source1 = new[] { 2, 99 };
            IEnumerable&lt;int&gt; source2 = new[] { 8, -10 };
            IEnumerable&lt;Pair&lt;int, int&gt;&gt; zipped = source1.ZipWith(source2, (x,y) =&gt; Tuples.Create(x,y));
            
            Console.WriteLine(zipped.Format("\r\n"));
            // output:
            // (2, 8)
            // (99, -10)
            </code>
            Like the Enumerables.Zip extension, ZipWith is defined for zipping up to 4 streams.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Pair the elements of two streams.
            </summary>
            <typeparam name="T0">The type of the first stream.</typeparam>
            <typeparam name="T1">The type of the second stream.</typeparam>
            <param name="first">The first stream.</param>
            <param name="second">The second stream.</param>
            <returns>A stream of tupled values.</returns>
            <remarks>
            This set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that combines streams together element-wise,
            returning a stream of Sasa's tuples. This is known as "zipping" streams, analogously to the operation of a
            physical zipper where the teeth pair up one after another:
            <code>
            IEnumerable&lt;int&gt; source1 = new[] { 2, 99 };
            IEnumerable&lt;int&gt; source2 = new[] { 8, -10 };
            IEnumerable&lt;Pair&lt;int, int&gt;&gt; zipped = source1.Zip(source2);
            
            Console.WriteLine(zipped.Format("\r\n"));
            // output:
            // (2, 8)
            // (99, -10)
            </code>
            There is a zip overload for each of Sasa's tuple types, so you can zip up to 4 streams together.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            Zip the elements of three streams.
            </summary>
            <typeparam name="T0">The type of the first stream.</typeparam>
            <typeparam name="T1">The type of the second stream.</typeparam>
            <typeparam name="T2">The type of the third stream.</typeparam>
            <param name="first">The first stream.</param>
            <param name="second">The second stream.</param>
            <param name="third">The third stream.</param>
            <returns>A stream of tupled values.</returns>
            <remarks>
            This set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that combines streams together element-wise,
            returning a stream of Sasa's tuples. This is known as "zipping" streams, analogously to the operation of a
            physical zipper where the teeth pair up one after another:
            <code>
            IEnumerable&lt;int&gt; source1 = new[] { 2, 99 };
            IEnumerable&lt;int&gt; source2 = new[] { 8, -10 };
            IEnumerable&lt;Pair&lt;int, int&gt;&gt; zipped = source1.Zip(source2);
            
            Console.WriteLine(zipped.Format("\r\n"));
            // output:
            // (2, 8)
            // (99, -10)
            </code>
            There is a zip overload for each of Sasa's tuple types, so you can zip up to 4 streams together.
            </remarks>
        </member>
        <member name="M:Sasa.Linq.Enumerables.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})">
            <summary>
            Zip the elements of four streams.
            </summary>
            <typeparam name="T0">The type of the first stream.</typeparam>
            <typeparam name="T1">The type of the second stream.</typeparam>
            <typeparam name="T2">The type of the third stream.</typeparam>
            <typeparam name="T3">The type of the fourth stream.</typeparam>
            <param name="first">The first stream.</param>
            <param name="second">The second stream.</param>
            <param name="third">The third stream.</param>
            <param name="fourth">The fourth stream.</param>
            <returns>A stream of tupled values.</returns>
            <remarks>
            This set of extension method overloads on <see cref="T:System.Collections.Generic.IEnumerable`1"/> that combines streams together element-wise,
            returning a stream of Sasa's tuples. This is known as "zipping" streams, analogously to the operation of a
            physical zipper where the teeth pair up one after another:
            <code>
            IEnumerable&lt;int&gt; source1 = new[] { 2, 99 };
            IEnumerable&lt;int&gt; source2 = new[] { 8, -10 };
            IEnumerable&lt;Pair&lt;int, int&gt;&gt; zipped = source1.Zip(source2);
            
            Console.WriteLine(zipped.Format("\r\n"));
            // output:
            // (2, 8)
            // (99, -10)
            </code>
            There is a zip overload for each of Sasa's tuple types, so you can zip up to 4 streams together.
            </remarks>
        </member>
        <member name="T:Sasa.Atomics">
            <summary>
            Extensions to System.Threading.Interlocked.
            </summary>
            <remarks>
            These atomic operations implement a simpler API than <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>,
            and further provides lightweight contention management for better
            scaling under medium and high loads. Basically, the constant-backoff scheme as
            described in the paper "Lightweight Contention Management for Efficient
            Compare-and-Swap Operations" [1].
            
            This scheme requires no state management and incurs virtually no overhead in low
            contention scenarios, and scales quite well under high contention.
            
            [1] http://arxiv.org/pdf/1305.5800v1.pdf
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Wait">
            <summary>
            Constant-backoff contention manager.
            </summary>
            <returns>Always returns false.</returns>
        </member>
        <member name="M:Sasa.Atomics.Set(System.Int64@,System.Int64,System.Int64)">
            <summary>
            Perform an atomic set.
            </summary>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <param name="comparand">The current value of the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <remarks>
            <code>
            string o = "hello";
            ...
            if (Atomics.Set(ref o, o + " world!", o))
                Console.WriteLine(o);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Set``1(``0@,``0,``0)">
            <summary>
            Perform an atomic set.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <param name="comparand">The current value of the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <remarks>
            <code>
            string o = "hello";
            ...
            if (Atomics.Set(ref o, o + " world!", o))
                Console.WriteLine(o);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Set``1(``0@,``0)">
            <summary>
            Perform an atomic set.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <remarks>
            <code>
            string o = "hello";
            ...
            if (Atomics.Set(ref o, o + " world!", o))
                Console.WriteLine(o);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Set``1(Sasa.Ref{``0},``0,``0)">
            <summary>
            Perform an atomic set.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <param name="comparand">The current value of the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            <code>
            string o = "hello";
            ...
            if (Atomics.Set(ref o, o + " world!", o))
                Console.WriteLine(o);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Set``1(Sasa.Ref{``0},``0)">
            <summary>
            Perform an atomic set.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            <code>
            string o = "hello";
            ...
            if (Atomics.Set(ref o, o + " world!", o))
                Console.WriteLine(o);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.SetFailed``1(``0@,``0,``0)">
            <summary>
            Perform an atomic set.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <param name="comparand">The current value of the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <remarks>
            <code>
            string o = "hello";
            ...
            while (Atomics.SetFailed(ref o, o + " world!", o)) { }
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.SetFailed``1(``0@,``0)">
            <summary>
            Perform an atomic set.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <remarks>
            <code>
            string o = "hello";
            ...
            while (Atomics.SetFailed(ref o, o + " world!", o)) { }
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.SetFailed(System.Int32@,System.Int32,System.Int32)">
            <summary>
            Perform an atomic set.
            </summary>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <param name="comparand">The current value of the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <remarks>
            <code>
            string o = "hello";
            ...
            while (Atomics.SetFailed(ref o, o + " world!", o)) { }
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.SetFailed(System.Int32@,System.Int32)">
            <summary>
            Perform an atomic set.
            </summary>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <remarks>
            <code>
            string o = "hello";
            ...
            while (Atomics.SetFailed(ref o, o + " world!", o)) { }
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.SetFailed``1(Sasa.Ref{``0},``0,``0)">
            <summary>
            Perform an atomic set.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <param name="comparand">The current value of the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            <code>
            string o = "hello";
            ...
            while (Atomics.SetFailed(ref o, o + " world!", o)) { }
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.SetFailed``1(Sasa.Ref{``0},``0)">
            <summary>
            Perform an atomic set.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="slot">The slot in which to place the new value.</param>
            <param name="value">The new value to place in the slot.</param>
            <returns>Returns true if successfully updated, false if another thread updated instead.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            <code>
            string o = "hello";
            ...
            while (Atomics.SetFailed(ref o, o + " world!", o)) { }
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.BeginRead(System.Int32@)">
            <summary>
            Begin the lock-free atomic read protocol.
            </summary>
            <param name="version">A version number used to synchronize with readers.</param>
            <returns>The read version.</returns>
            <remarks>
            This marks the beginning of the lock-free atomic read protocol. If the version returned by
            <seealso cref="M:Sasa.Atomics.EndRead(System.Int32@)"/> matches the version returned this function, the atomic read succeeded:
            <code>
            T value;
            int version;
            ...
            
            int readVersion;
            T readValue;
            do
            {
              readVersion = Atomics.BeginRead(ref version);
              readValue = value;
            } while (readVersion != Atomics.EndRead(ref version));
            // value == readValue
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.EndRead(System.Int32@)">
            <summary>
            Mark the end of the atomic read protocol.
            </summary>
            <param name="version">A version number used to synchronize with readers.</param>
            <returns>The read version.</returns>
            <remarks>
            This marks the end of the atomic read protocol. If the version returned by this function
            matches the version returned be <seealso cref="M:Sasa.Atomics.BeginRead(System.Int32@)"/>, the atomic read succeeded:
            <code>
            T value;
            int version;
            ...
            
            int readVersion;
            T readValue;
            do
            {
              readVersion = Atomics.BeginRead(ref version);
              readValue = value;
            } while (readVersion != Atomics.EndRead(ref version));
            // value == readValue
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.BeginRead(System.Int64@)">
            <summary>
            Begin the lock-free atomic read protocol.
            </summary>
            <param name="version">A version number used to synchronize with readers.</param>
            <returns>The read version.</returns>
            <remarks>
            This marks the beginning of the lock-free atomic read protocol. If the version returned by
            <seealso cref="M:Sasa.Atomics.EndRead(System.Int64@)"/> matches the version returned this function, the atomic read succeeded:
            <code>
            T value;
            long version;
            ...
            
            long readVersion;
            T readValue;
            do
            {
              readVersion = Atomics.BeginRead(ref version);
              readValue = value;
            } while (readVersion != Atomics.EndRead(ref version));
            // value == readValue
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.EndRead(System.Int64@)">
            <summary>
            Mark the end of the atomic read protocol.
            </summary>
            <param name="version">A version number used to synchronize with readers.</param>
            <returns>The read version.</returns>
            <remarks>
            This marks the end of the atomic read protocol. If the version returned by this function
            matches the version returned be <seealso cref="M:Sasa.Atomics.BeginRead(System.Int32@)"/>, the atomic read succeeded:
            <code>
            T value;
            long version;
            ...
            
            long readVersion;
            T readValue;
            do
            {
              readVersion = Atomics.BeginRead(ref version);
              readValue = value;
            } while (readVersion != Atomics.EndRead(ref version));
            // value == readValue
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.BeginWrite(System.Int32@)">
            <summary>
            Begin the atomic write protocol.
            </summary>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <remarks>
            This function marks the beginning of the atomic write protocol. Clients must lock on a shared
            variable first to serialize writes. The <seealso cref="M:Sasa.Atomics.BeginRead(System.Int32@)"/> function
            synchronizes with writes using the version number, without using locks.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.EndWrite(System.Int32@)">
            <summary>
            End an atomic write protocol.
            </summary>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <remarks>
            This function marks the end of the write protocol. Readers wait until this function is called.
            
            <paramref name="version"/> is treated as if it were an unsigned number, ie. it wraps after
            reaching the max.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.BeginWrite(System.Int64@)">
            <summary>
            Begin the atomic write protocol.
            </summary>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <remarks>
            This function marks the beginning of the atomic write protocol. Clients must lock on a shared
            variable first to serialize writes. The <seealso cref="M:Sasa.Atomics.BeginRead(System.Int32@)"/> function
            synchronizes with writes using the version number, without using locks.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.EndWrite(System.Int64@)">
            <summary>
            End an atomic write protocol.
            </summary>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <remarks>
            This function marks the end of the write protocol. Readers wait until this function is called.
            
            <paramref name="version"/> is treated as if it were an unsigned number, ie. it wraps after
            reaching the max.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Read``1(``0@,System.Int32@)">
            <summary>
            An atomic read operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being read.</typeparam>
            <param name="location">The value's location.</param>
            <param name="version">A version number used to synchronize with readers.</param>
            <returns>The struct value.</returns>
            <remarks>
            <seealso cref="M:Sasa.Atomics.Read``1(``0@,System.Int32@)"/> uses a thread-safe, lock-free protocol via the version parameter
            to synchronize with calls to <seealso cref="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int32@,System.Object)"/>
            in order to prevent torn reads. The same <paramref name="version"/> address must be used for
            calls to these two functions.
            
            Readers never synchronize with each other, so read-heavy workloads should be much
            faster than synchronizing all accesses via locks.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Read``1(``0@,System.Int32@,System.Int32@)">
            <summary>
            An atomic read operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being read.</typeparam>
            <param name="location">The value's location.</param>
            <param name="version">A version number used to synchronize with readers.</param>
            <param name="readVersion">The version number of the read value.</param>
            <returns>The struct value.</returns>
            <remarks>
            <seealso cref="M:Sasa.Atomics.Read``1(``0@,System.Int32@,System.Int32@)"/> uses a thread-safe, lock-free protocol via the version parameter
            to synchronize with calls to <seealso cref="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int32@,System.Object)"/>
            in order to prevent torn reads. The same <paramref name="version"/> address must be used for
            calls to these two functions.
            
            Readers never synchronize with each other, so read-heavy workloads should be much
            faster than synchronizing all accesses via locks.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int32@)">
            <summary>
            An atomic write operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being written.</typeparam>
            <param name="value">The value to write.</param>
            <param name="location">The location to write.</param>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <remarks>
            This function performs a write to a location, but requires clients to lock on a shared
            variable first to serialize writes. It further synchronizes with readers to prevent torn
            reads. Readers never block writers, but writers can cause readers to spin in heavy write
            workloads.
            
            <paramref name="version"/> is treated as if it were an unsigned number, ie. it wraps after
            reaching the max.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int32@,System.Int32)">
            <summary>
            An atomic write operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being written.</typeparam>
            <param name="value">The value to write.</param>
            <param name="location">The location to write.</param>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <param name="mask">A bitmask used to handle version number overflow.</param>
            <remarks>
            This function performs a write to a location, but requires clients to lock on a shared
            variable first to serialize writes. It further synchronizes with readers to prevent torn
            reads. Readers never block writers, but writers can cause readers to spin in heavy write
            workloads.
            
            In this particular overload, some number of low-order bits of <paramref name="version"/>
            used for versioning as specified by the <paramref name="mask"/> parameter. The version
            location is then incremented and masked against <paramref name="mask"/> in such a way
            that any bits above the mask are unchanged, but any bits below the mask are zeroed if
            the version increment overflows the bitmask.
            
            This is particularly useful if the higher order bits of the version number location
            are used to hold other information.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int32@,System.Object)">
            <summary>
            An atomic write operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being written.</typeparam>
            <param name="value">The value to write.</param>
            <param name="location">The location to write.</param>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <param name="writeLock">The object to use to serialize writes.</param>
            <remarks>
            This function performs an atomic write to a location by locking on <paramref name="writeLock"/>.
            It further synchronizes with readers to prevent torn reads. Readers never block writers, but
            writers can cause readers to spin in heavy write workloads.
            
            <paramref name="version"/> is treated as if it were an unsigned number, ie. it wraps after
            reaching the max.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Read``1(``0@,System.Int64@)">
            <summary>
            An atomic read operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being read.</typeparam>
            <param name="location">The value's location.</param>
            <param name="version">A version number used to synchronize with readers.</param>
            <returns>The struct value.</returns>
            <remarks>
            <seealso cref="M:Sasa.Atomics.Read``1(``0@,System.Int64@)"/> uses a thread-safe, lock-free protocol via the version parameter
            to synchronize with calls to <seealso cref="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int32@,System.Object)"/>
            in order to prevent torn reads. The same <paramref name="version"/> address must be used for
            calls to these two functions.
            
            Readers never synchronize with each other, so read-heavy workloads should be much
            faster than synchronizing all accesses via locks.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Read``1(``0@,System.Int64@,System.Int64@)">
            <summary>
            An atomic read operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being read.</typeparam>
            <param name="location">The value's location.</param>
            <param name="version">A version number used to synchronize with readers.</param>
            <param name="readVersion">The version number of the returned value.</param>
            <returns>The struct value.</returns>
            <remarks>
            <seealso cref="M:Sasa.Atomics.Read``1(``0@,System.Int64@,System.Int64@)"/> uses a thread-safe, lock-free protocol via the version parameter
            to synchronize with calls to <seealso cref="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int32@,System.Object)"/>
            in order to prevent torn reads. The same <paramref name="version"/> address must be used for
            calls to these two functions.
            
            Readers never synchronize with each other, so read-heavy workloads should be much
            faster than synchronizing all accesses via locks.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int64@)">
            <summary>
            An atomic write operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being written.</typeparam>
            <param name="value">The value to write.</param>
            <param name="location">The location to write.</param>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <remarks>
            This function performs a write to a location, but requires clients to lock on a shared
            variable first, or otherwise mutually exclude writers. It further synchronizes with readers
            to prevent torn reads. Readers never block writers, but writers can cause readers to spin in
            heavy write workloads.
            
            <paramref name="version"/> is treated as if it were an unsigned number, ie. it wraps after
            reaching the max.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int64@,System.Int32)">
            <summary>
            An atomic write operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being written.</typeparam>
            <param name="value">The value to write.</param>
            <param name="location">The location to write.</param>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <param name="mask">A bitmask used to handle version number overflow.</param>
            <remarks>
            This function performs a write to a location, but requires clients to lock on a shared
            variable first, or otherwise mutually exclude writers. It further synchronizes with readers
            to prevent torn reads. Readers never block writers, but writers can cause readers to spin in
            heavy write workloads.
            
            In this particular overload, some number of low-order bits of <paramref name="version"/>
            are used for versioning as specified by the <paramref name="mask"/> parameter. The version
            location is then incremented and masked against <paramref name="mask"/> in such a way
            that any bits above the mask are unchanged, but any bits below the mask are zeroed if
            the version increment overflows the bitmask.
            
            This is particularly useful if the higher order bits of the version number location
            are used to hold other information.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.Write``1(``0@,``0@,System.Int64@,System.Object)">
            <summary>
            An atomic write operation for arbitrarily sized value types.
            </summary>
            <typeparam name="T">The type of value being written.</typeparam>
            <param name="value">The value to write.</param>
            <param name="location">The location to write.</param>
            <param name="version">The location of the version used to synchronize with readers.</param>
            <param name="writeLock">The object to use to serialize writes.</param>
            <remarks>
            This function performs an atomic write to a location by locking on <paramref name="writeLock"/>.
            It further synchronizes with readers to prevent torn reads. Readers never block writers, but
            writers can cause readers to spin in heavy write workloads.
            
            <paramref name="version"/> is treated as if it were an unsigned number, ie. it wraps after
            reaching the max.
            </remarks>
        </member>
        <member name="M:Sasa.Atomics.LoadLinked``1(``0@,System.Int32@,System.Int32@)">
            <summary>
            A load-linked operation.
            </summary>
            <typeparam name="T">The type of value being read.</typeparam>
            <param name="location">The value's location.</param>
            <param name="version">The current version number.</param>
            <param name="readVersion">The version number of the read value.</param>
            <returns>The value at <paramref name="location"/>.</returns>
        </member>
        <member name="M:Sasa.Atomics.StoreConditional``1(``0@,``0,``0,System.Int32@,System.Int32)">
            <summary>
            A store-conditional operation.
            </summary>
            <typeparam name="T">The type of value being written.</typeparam>
            <param name="location">The location being written.</param>
            <param name="value">The value being written to that location.</param>
            <param name="original">The original value that shoud be at that location for this operation to succeed.</param>
            <param name="version">The version number associated with <paramref name="location"/>.</param>
            <param name="readVersion">The version number associated with <paramref name="original"/>.</param>
            <returns>True if the location was unchanged since the corresponding <seealso cref="M:Sasa.Atomics.LoadLinked``1(``0@,System.Int32@,System.Int32@)"/> operation.</returns>
        </member>
        <member name="M:Sasa.Atomics.LoadLinked(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            A load-linked operation.
            </summary>
            <param name="location">The value's location.</param>
            <param name="version">The current version number.</param>
            <param name="readVersion">The version number of the read value.</param>
            <returns>The value at <paramref name="location"/>.</returns>
        </member>
        <member name="M:Sasa.Atomics.StoreConditional(System.Int32@,System.Int32,System.Int32,System.Int32@,System.Int32)">
            <summary>
            A store-conditional operation.
            </summary>
            <param name="location">The location being written.</param>
            <param name="value">The value being written to that location.</param>
            <param name="original">The original value that shoud be at that location for this operation to succeed.</param>
            <param name="version">The version number associated with <paramref name="location"/>.</param>
            <param name="readVersion">The version number associated with <paramref name="original"/>.</param>
            <returns>True if the location was unchanged since the corresponding <seealso cref="M:Sasa.Atomics.LoadLinked``1(``0@,System.Int32@,System.Int32@)"/> operation.</returns>
        </member>
        <member name="T:Sasa.Either">
            <summary>
            Static methods on either types.
            </summary>
            <remarks>
            This static class provides convenient static methods for constructing sums.
            </remarks>
        </member>
        <member name="M:Sasa.Either.Coalesce``2(``0,``1)">
            <summary>
            Coalescing operation.
            </summary>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <param name="first">The first value to check.</param>
            <param name="second">The value to return if <paramref name="first"/> is null.</param>
            <returns>A sum encapsulating either a <typeparamref name="T0"/> or a <typeparamref name="T1"/>.</returns>
            <remarks>
            The ?? null coalescing operator only works on values of the same type. <see cref="M:Sasa.Either.Coalesce``2(``0,``1)"/>
            can work on values of disparate types, and returns an <see cref="T:Sasa.Either`2"/> encapsulating
            the returned value:
            <code>
            var sum = Either.Coalesce&lt;string, float&gt;(null, 3.0F);
            Console.WriteLine(sum);
            // output:
            // 3.0
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.Coalesce``3(``0,``1,``2)">
            <summary>
            Coalescing operation.
            </summary>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <param name="first">The first value to check.</param>
            <param name="second">The value to return if <paramref name="first"/> is null.</param>
            <param name="third">The value to return if both <paramref name="first"/> and <paramref name="second"/> are null.</param>
            <returns>A sum encapsulating either a <typeparamref name="T0"/> or a <typeparamref name="T1"/> or a <typeparamref name="T2"/>.</returns>
            <remarks>
            The ?? null coalescing operator only works on values of the same type. <see cref="M:Sasa.Either.Coalesce``3(``0,``1,``2)"/>
            can work on values of disparate types, and returns an <see cref="T:Sasa.Either`3"/> encapsulating
            the returned value:
            <code>
            var sum = Either.Coalesce&lt;int?, string, float&gt;(null, null, 3.0F);
            Console.WriteLine(sum);
            // output:
            // 3.0
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.Coalesce``4(``0,``1,``2,``3)">
            <summary>
            Coalescing operation.
            </summary>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <typeparam name="T3">Type of the fourth case.</typeparam>
            <param name="first">The first value to check.</param>
            <param name="second">The value to return if <paramref name="first"/> is null.</param>
            <param name="third">The value to return if both <paramref name="first"/> and <paramref name="second"/> are null.</param>
            <param name="fourth">The value to return if <paramref name="first"/>, <paramref name="second"/> and <paramref name="third"/> are all null.</param>
            <returns>
            A sum encapsulating either a <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>
            or a <typeparamref name="T3"/>.
            </returns>
            <remarks>
            The ?? null coalescing operator only works on values of the same type. <see cref="M:Sasa.Either.Coalesce``4(``0,``1,``2,``3)"/>
            can work on values of disparate types, and returns an <see cref="T:Sasa.Either`4"/> encapsulating
            the returned value:
            <code>
            var sum = Either.Coalesce&lt;object, string, int?, float&gt;(null, null, null, 3.0F);
            Console.WriteLine(sum);
            // output:
            // 3.0
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.First``2(``0)">
            <summary>
            Create a two-sum for the first case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T0"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string&gt;(3);
            Console.WriteLine(x);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.First``3(``0)">
            <summary>
            Create a three-sum for the first case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T0"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal&gt;(3);
            Console.WriteLine(x);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.First``4(``0)">
            <summary>
            Create a four-sum for the first case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <typeparam name="T3">Type of the fourth case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T0"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, Thread&gt;(3);
            Console.WriteLine(x);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.Second``2(``1)">
            <summary>
            Create a two-sum for the second case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T0"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T1"/>:
            <code>
            var x = Either.Second&lt;int, string&gt;("hello world!");
            Console.WriteLine(x);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.Second``3(``1)">
            <summary>
            Create a three-sum for the second case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T1"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T1"/>:
            <code>
            var x = Either.Second&lt;int, string, decimal&gt;("hello world!");
            Console.WriteLine(x);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.Second``4(``1)">
            <summary>
            Create a four-sum for the second case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <typeparam name="T3">Type of the fourth case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T1"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T1"/>:
            <code>
            var x = Either.Second&lt;int, string, decimal, Thread&gt;("hello world!");
            Console.WriteLine(x);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.Third``3(``2)">
            <summary>
            Create a three-sum for the third case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T2"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T2"/>:
            <code>
            var x = Either.Third&lt;int, string, decimal&gt;(1234M);
            Console.WriteLine(x);
            // output:
            // 1234
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.Third``4(``2)">
            <summary>
            Create a four-sum for the third case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <typeparam name="T3">Type of the fourth case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T2"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T2"/>:
            <code>
            var x = Either.Third&lt;int, string, decimal, Thread&gt;(1234M);
            Console.WriteLine(x);
            // output:
            // 1234
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either.Fourth``4(``3)">
            <summary>
            Create a four-sum for the fourth case.
            </summary>
            <param name="value">The value to encapsulate.</param>
            <typeparam name="T0">Type of the first case.</typeparam>
            <typeparam name="T1">Type of the second case.</typeparam>
            <typeparam name="T2">Type of the third case.</typeparam>
            <typeparam name="T3">Type of the fourth case.</typeparam>
            <returns>A sum encapsulating a <typeparamref name="T3"/>.</returns>
            <remarks>
            Constructs a sum encapsulating a value of type <typeparamref name="T2"/>:
            <code>
            var x = Either.Fourth&lt;int, string, decimal, Thread&gt;(Thread.CurrentThread);
            Console.WriteLine(x);
            // output:
            // 1234
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Either`2">
            <summary>
            This type encapsulates either a value of type <typeparamref name="T0"/>,
            or <typeparamref name="T1"/>.
            </summary>
            <typeparam name="T0">Possible 'First' type.</typeparam>
            <typeparam name="T1">Possible 'Second' type.</typeparam>
            <remarks>
            Tuples are a pretty common necessity while programming, and every programmer has run into the need
            to return multiple values from a method, as but one example. The algebraic description of a tuple is
            what's known as a "product", and the logical analogue is the "conjunction", ie. a product/tuple is
            type T0 AND T1 AND T2 AND ...
            
            Given any abstraction, it's dual will often also be necessary. Imagine programming only with the
            logical AND operator without OR! Analogously, we also need the algebraic analogue of products
            which are known as "sums", ie. type T0 OR T1 OR T2 OR ...:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            The need for this may not be so obvious to CLR programmers because inheritance provides a kind of sum.
            For instance, the above code snippet could be modelled with an explicit class hierarchy:
            <code>
            abstract class IntOrString
            {
                public static implicit operator IntOrString(int i)
                {
                    return new IntCase { value = i };
                }
                public static implicit operator IntOrString(string s)
                {
                    return new StringCase { value = s };
                }
            }
            sealed class IntCase : IntOrString
            {
                int value;
                public override string ToString() { return value.ToString(); }
            }
            sealed class StringCase : IntOrString
            {
                string value;
                public override string ToString() { return value; }
            }
            ...
            IntOrString foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            However, just like with tuples, when you're only dealing with a small number of possibilities you don't
            want to go through the hassle of creating a whole new set of types just to represent a few possibilities.
            
            Alternately, you can just use the implicit supertype of all CLR types, <see cref="T:System.Object" /> instead of
            creating a class hierarchy, but in a very real sense this is TOO permissive, since it allows more than just
            <see cref="T:System.Int32"/> and <see cref="T:System.String"/>:
            <code>
            object foo = new Action(() => throw new Exception("Fooled you!"));
            Console.WriteLine(foo);
            // output:
            // System.Action ...
            </code>
            <see cref="T:Sasa.Either`2"/>, <see cref="T:Sasa.Either`3"/> and <see cref="T:Sasa.Either`4"/>
            are generic sum types that provide this functionality for you, along with a few convenience operations
            to make programming with sums easier. For instance, ToString is overloaded to return the string representation
            of the underlying value, there are implicit conversions into the corresponding sum type, equality is structural
            over the various cases, and value extraction from sums is done via a simple pattern matching scheme:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`2.#ctor(`0)">
            <summary>
            Construct a new instance for <typeparamref name="T0"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`2.#ctor(`1)">
            <summary>
            Construct a new instance for <typeparamref name="T1"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`2.op_Implicit(`0)~Sasa.Either{`0,`1}">
            <summary>
            A value of type <typeparamref name="T0"/> can be implicitly converted to First.
            </summary>
            <param name="first">The value to implicitly convert.</param>
            <returns>A new Either initialized to First.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T0"/> into a sum:
            <code>
            Either&lt;int, string&gt; x = 3;
            Console.WriteLine(x.IsFirst);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`2.op_Implicit(`1)~Sasa.Either{`0,`1}">
            <summary>
            A value of type <typeparamref name="T1"/> can be implicitly converted to Second.
            </summary>
            <param name="value">The value to implicitly convert.</param>
            <returns>A new Either initialized to Second.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T1"/> into a sum:
            <code>
            Either&lt;int, string&gt; x = "hello!";
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`2.IsFirst">
            <summary>
            True if encapsulated type is of type <typeparamref name="T0"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string&gt;(3);
            Console.WriteLine(x.IsFirst);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`2.IsSecond">
            <summary>
            True if encapsulated type is of type <typeparamref name="T1"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;("hello!");
            Console.WriteLine(x.IsFirst);
            Console.WriteLine(x.IsSecond);
            // output:
            // false
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`2.TryFirst(`0@)">
            <summary>
            Attempt to extract the value
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if Either is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T0"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`2.TrySecond(`1@)">
            <summary>
            Attempt to extract the value
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if Either is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T1"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`2.First">
            <summary>
            Attempt to extract the value as <typeparamref name="T0"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T0"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo.First || 123);
            // output:
            // 123
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`2.Second">
            <summary>
            Attempt to extract the value as <typeparamref name="T1"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T1"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string&gt; foo = 123;
            Console.WriteLine(foo.Second || "hello!");
            // output:
            // hello!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`2.Equals(Sasa.Either{`0,`1})">
            <summary>
            Compare for equality.
            </summary>
            <param name="other">Other type to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`2.Equals(System.Object)">
            <summary>
            Compare for equality.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True of equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`2.GetHashCode">
            <summary>
            Compute hash code.
            </summary>
            <returns>Integer hash code.</returns>
        </member>
        <member name="M:Sasa.Either`2.op_Equality(Sasa.Either{`0,`1},Sasa.Either{`0,`1})">
            <summary>
            Compare for equality.
            </summary>
            <param name="left">Left hand side.</param>
            <param name="right">Right hand side.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`2.op_Inequality(Sasa.Either{`0,`1},Sasa.Either{`0,`1})">
            <summary>
            Compare for inequality.
            </summary>
            <param name="left">Left hand side.</param>
            <param name="right">Right hand side.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`2.ToString">
            <summary>
            The string representation of the underlying value.
            </summary>
            <returns>A string representation of the underlying value.</returns>
        </member>
        <member name="T:Sasa.Either`3">
            <summary>
            This type encapsulates either a value of type <typeparamref name="T0"/>,
            <typeparamref name="T1"/>, or <typeparamref name="T2"/>.
            </summary>
            <typeparam name="T0">Type of first case.</typeparam>
            <typeparam name="T1">Type of second case.</typeparam>
            <typeparam name="T2">Type of third case.</typeparam>
            <remarks>
            Tuples are a pretty common necessity while programming, and every programmer has run into the need
            to return multiple values from a method, as but one example. The algebraic description of a tuple is
            what's known as a "product", and the logical analogue is the "conjunction", ie. a product/tuple is
            type T0 AND T1 AND T2 AND ...
            
            Given any abstraction, it's dual will often also be necessary. Imagine programming only with the
            logical AND operator without OR! Analogously, we also need the algebraic analogue of products
            which are known as "sums", ie. type T0 OR T1 OR T2 OR ...:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            The need for this may not be so obvious to CLR programmers because inheritance provides a kind of sum.
            For instance, the above code snippet could be modelled with an explicit class hierarchy:
            <code>
            abstract class IntOrString
            {
                public static implicit operator IntOrString(int i)
                {
                    return new IntCase { value = i };
                }
                public static implicit operator IntOrString(string s)
                {
                    return new StringCase { value = s };
                }
            }
            sealed class IntCase : IntOrString
            {
                int value;
                public override string ToString() { return value.ToString(); }
            }
            sealed class StringCase : IntOrString
            {
                string value;
                public override string ToString() { return value; }
            }
            ...
            IntOrString foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            However, just like with tuples, when you're only dealing with a small number of possibilities you don't
            want to go through the hassle of creating a whole new set of types just to represent a few possibilities.
            
            Alternately, you can just use the implicit supertype of all CLR types, <see cref="T:System.Object" /> instead of
            creating a class hierarchy, but in a very real sense this is TOO permissive, since it allows more than just
            <see cref="T:System.Int32"/> and <see cref="T:System.String"/>:
            <code>
            object foo = new Action(() => throw new Exception("Fooled you!"));
            Console.WriteLine(foo);
            // output:
            // System.Action ...
            </code>
            <see cref="T:Sasa.Either`2"/>, <see cref="T:Sasa.Either`3"/> and <see cref="T:Sasa.Either`4"/>
            are generic sum types that provide this functionality for you, along with a few convenience operations
            to make programming with sums easier. For instance, ToString is overloaded to return the string representation
            of the underlying value, there are implicit conversions into the corresponding sum type, equality is structural
            over the various cases, and value extraction from sums is done via a simple pattern matching scheme:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`3.#ctor(`0)">
            <summary>
            Construct a new instance for <typeparamref name="T0"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`3.#ctor(`1)">
            <summary>
            Construct a new instance for <typeparamref name="T1"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`3.#ctor(`2)">
            <summary>
            Construct a new instance for <typeparamref name="T2"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`3.op_Implicit(`0)~Sasa.Either{`0,`1,`2}">
            <summary>
            A value of type <typeparamref name="T0"/> can be implicitly converted to First.
            </summary>
            <returns>A new Either initialized to First.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T0"/> into a sum:
            <code>
            Either&lt;int, string, decimal&gt; x = 3;
            Console.WriteLine(x.IsFirst);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`3.op_Implicit(`1)~Sasa.Either{`0,`1,`2}">
            <summary>
            A value of type <typeparamref name="T1"/> can be implicitly converted to Second.
            </summary>
            <param name="value">The value to implicitly convert.</param>
            <returns>A new Either initialized to Second.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T1"/> into a sum:
            <code>
            Either&lt;int, string, decimal&gt; x = "hello!";
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`3.op_Implicit(`2)~Sasa.Either{`0,`1,`2}">
            <summary>
            A value of type <typeparamref name="T2"/> can be implicitly converted to Third.
            </summary>
            <param name="value">The value to implicitly convert.</param>
            <returns>A new Either initialized to Third.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T2"/> into a sum:
            <code>
            Either&lt;int, string, decimal, DateTime&gt; x = 3.0M;
            Console.WriteLine(x.IsThird);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`3.IsFirst">
            <summary>
            True if encapsulated type is of type <typeparamref name="T0"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;(3);
            Console.WriteLine(x.IsFirst);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`3.IsSecond">
            <summary>
            True if encapsulated type is of type <typeparamref name="T1"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;("hello!");
            Console.WriteLine(x.IsFirst);
            Console.WriteLine(x.IsSecond);
            // output:
            // false
            // true
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`3.IsThird">
            <summary>
            True if encapsulated type is of type <typeparamref name="T2"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;(99.0M);
            Console.WriteLine(x.IsThird);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`3.TryFirst(`0@)">
            <summary>
            Attempt to extract the value
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if Either is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T0"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`3.TrySecond(`1@)">
            <summary>
            Attempt to extract the value
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if Either is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T1"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`3.TryThird(`2@)">
            <summary>
            Attempt to extract the value
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if Either is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T2"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`3.First">
            <summary>
            Attempt to extract the value as <typeparamref name="T0"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T0"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo.First || 123);
            // output:
            // 123
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`3.Second">
            <summary>
            Attempt to extract the value as <typeparamref name="T1"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T1"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string&gt; foo = 123;
            Console.WriteLine(foo.Second || "hello!");
            // output:
            // hello!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`3.Third">
            <summary>
            Attempt to extract the value as <typeparamref name="T2"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T2"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string, DateTime&gt; foo = DateTime.MinValue;
            Console.WriteLine(foo.Third || DateTime.MaxValue);
            // output:
            // DateTime.MinValue
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`3.Equals(Sasa.Either{`0,`1,`2})">
            <summary>
            Compare for equality.
            </summary>
            <param name="other">Other type to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`3.Equals(System.Object)">
            <summary>
            Compare for equality.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True of equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`3.GetHashCode">
            <summary>
            Compute hash code.
            </summary>
            <returns>Integer hash code.</returns>
        </member>
        <member name="M:Sasa.Either`3.op_Equality(Sasa.Either{`0,`1,`2},Sasa.Either{`0,`1,`2})">
            <summary>
            Compare for equality.
            </summary>
            <param name="left">Left hand side.</param>
            <param name="right">Right hand side.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`3.op_Inequality(Sasa.Either{`0,`1,`2},Sasa.Either{`0,`1,`2})">
            <summary>
            Compare for inequality.
            </summary>
            <param name="left">Left hand side.</param>
            <param name="right">Right hand side.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`3.ToString">
            <summary>
            The string representation of the underlying value.
            </summary>
            <returns>A string representation of the underlying value.</returns>
        </member>
        <member name="T:Sasa.Either`4">
            <summary>
            This type encapsulates either a value of type <typeparamref name="T0"/>,
            <typeparamref name="T1"/>, <typeparamref name="T2"/> or
            <typeparamref name="T3"/>.
            </summary>
            <typeparam name="T0">Type of first case.</typeparam>
            <typeparam name="T1">Type of second case.</typeparam>
            <typeparam name="T2">Type of third case.</typeparam>
            <typeparam name="T3">Type of fourth case.</typeparam>
            <remarks>
            Tuples are a pretty common necessity while programming, and every programmer has run into the need
            to return multiple values from a method, as but one example. The algebraic description of a tuple is
            what's known as a "product", and the logical analogue is the "conjunction", ie. a product/tuple is
            type T0 AND T1 AND T2 AND ...
            
            Given any abstraction, it's dual will often also be necessary. Imagine programming only with the
            logical AND operator without OR! Analogously, we also need the algebraic analogue of products
            which are known as "sums", ie. type T0 OR T1 OR T2 OR ...:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            The need for this may not be so obvious to CLR programmers because inheritance provides a kind of sum.
            For instance, the above code snippet could be modelled with an explicit class hierarchy:
            <code>
            abstract class IntOrString
            {
                public static implicit operator IntOrString(int i)
                {
                    return new IntCase { value = i };
                }
                public static implicit operator IntOrString(string s)
                {
                    return new StringCase { value = s };
                }
            }
            sealed class IntCase : IntOrString
            {
                int value;
                public override string ToString() { return value.ToString(); }
            }
            sealed class StringCase : IntOrString
            {
                string value;
                public override string ToString() { return value; }
            }
            ...
            IntOrString foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            However, just like with tuples, when you're only dealing with a small number of possibilities you don't
            want to go through the hassle of creating a whole new set of types just to represent a few possibilities.
            
            Alternately, you can just use the implicit supertype of all CLR types, <see cref="T:System.Object" /> instead of
            creating a class hierarchy, but in a very real sense this is TOO permissive, since it allows more than just
            <see cref="T:System.Int32"/> and <see cref="T:System.String"/>:
            <code>
            object foo = new Action(() => throw new Exception("Fooled you!"));
            Console.WriteLine(foo);
            // output:
            // System.Action ...
            </code>
            <see cref="T:Sasa.Either`2"/>, <see cref="T:Sasa.Either`3"/> and <see cref="T:Sasa.Either`4"/>
            are generic sum types that provide this functionality for you, along with a few convenience operations
            to make programming with sums easier. For instance, ToString is overloaded to return the string representation
            of the underlying value, there are implicit conversions into the corresponding sum type, equality is structural
            over the various cases, and value extraction from sums is done via a simple pattern matching scheme:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.#ctor(`0)">
            <summary>
            Construct a new instance for <typeparamref name="T0"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`4.#ctor(`1)">
            <summary>
            Construct a new instance for <typeparamref name="T1"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`4.#ctor(`2)">
            <summary>
            Construct a new instance for <typeparamref name="T2"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`4.#ctor(`3)">
            <summary>
            Construct a new instance for <typeparamref name="T3"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sasa.Either`4.op_Implicit(`0)~Sasa.Either{`0,`1,`2,`3}">
            <summary>
            A value of type <typeparamref name="T0"/> can be implicitly converted to First.
            </summary>
            <param name="value">The value to implicitly convert.</param>
            <returns>A new Either initialized to First.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T0"/> into a sum:
            <code>
            Either&lt;int, string, decimal, DateTime&gt; x = 3;
            Console.WriteLine(x.IsFirst);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.op_Implicit(`1)~Sasa.Either{`0,`1,`2,`3}">
            <summary>
            A value of type <typeparamref name="T1"/> can be implicitly converted to Second.
            </summary>
            <param name="value">The value to implicitly convert.</param>
            <returns>A new Either initialized to Second.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T1"/> into a sum:
            <code>
            Either&lt;int, string, decimal, DateTime&gt; x = "hello!";
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.op_Implicit(`2)~Sasa.Either{`0,`1,`2,`3}">
            <summary>
            A value of type <typeparamref name="T2"/> can be implicitly converted to Third.
            </summary>
            <param name="value">The value to implicitly convert.</param>
            <returns>A new Either initialized to Third.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T2"/> into a sum:
            <code>
            Either&lt;int, string, decimal, DateTime&gt; x = 3.0M;
            Console.WriteLine(x.IsThird);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.op_Implicit(`3)~Sasa.Either{`0,`1,`2,`3}">
            <summary>
            A value of type <typeparamref name="T3"/> can be implicitly converted to Fourth.
            </summary>
            <param name="value">The value to implicitly convert.</param>
            <returns>A new Either initialized to Third.</returns>
            <remarks>
            This implicitly converts a value of type <typeparamref name="T3"/> into a sum:
            <code>
            Either&lt;int, string, decimal, DateTime&gt; x = DateTime.Now;
            Console.WriteLine(x.IsFourth);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`4.IsFirst">
            <summary>
            True if encapsulated type is of type <typeparamref name="T0"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;(3);
            Console.WriteLine(x.IsFirst);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`4.IsSecond">
            <summary>
            True if encapsulated type is of type <typeparamref name="T1"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;("hello!");
            Console.WriteLine(x.IsFirst);
            Console.WriteLine(x.IsSecond);
            // output:
            // false
            // true
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`4.IsThird">
            <summary>
            True if encapsulated type is of type <typeparamref name="T2"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;(99.0M);
            Console.WriteLine(x.IsThird);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`4.IsFourth">
            <summary>
            True if encapsulated type is of type <typeparamref name="T3"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;(DateTime.Today);
            Console.WriteLine(x.IsFourth);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.TryFirst(`0@)">
            <summary>
            Attempt to extract the value.
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if sum is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T0"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.TrySecond(`1@)">
            <summary>
            Attempt to extract the value.
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if Either is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T1"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.TryThird(`2@)">
            <summary>
            Attempt to extract the value.
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if Either is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T2"/>:
            <code>
            Either&lt;int, string, decimal&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            string dcase;
            if (foo.TryThird(out dcase))
            {
                Console.WriteLine("decimal: " + dcase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.TryFourth(`3@)">
            <summary>
            Attempt to extract the value.
            </summary>
            <param name="value">The encapsulated value.</param>
            <returns>True if Either is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T3"/>:
            <code>
            Either&lt;int, string, decimal&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            string dcase;
            if (foo.TryThird(out dcase))
            {
                Console.WriteLine("decimal: " + dcase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`4.First">
            <summary>
            Attempt to extract the value as <typeparamref name="T0"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T0"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo.First || 123);
            // output:
            // 123
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`4.Second">
            <summary>
            Attempt to extract the value as <typeparamref name="T1"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T1"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string&gt; foo = 123;
            Console.WriteLine(foo.Second || "hello!");
            // output:
            // hello!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`4.Third">
            <summary>
            Attempt to extract the value as <typeparamref name="T2"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T2"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string, DateTime&gt; foo = DateTime.MinValue;
            Console.WriteLine(foo.Third || DateTime.MaxValue);
            // output:
            // DateTime.MinValue
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Either`4.Fourth">
            <summary>
            Attempt to extract the value as <typeparamref name="T3"/>.
            </summary>
            <returns>An option indicating whether the value is of type <typeparamref name="T3"/>.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string, DateTime, decimal&gt; foo = "foo";
            Console.WriteLine(foo.Fourth || 99M);
            // output:
            // 99M
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Either`4.Equals(Sasa.Either{`0,`1,`2,`3})">
            <summary>
            Compare for equality.
            </summary>
            <param name="other">Other type to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`4.Equals(System.Object)">
            <summary>
            Compare for equality.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True of equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`4.GetHashCode">
            <summary>
            Compute hash code.
            </summary>
            <returns>Integer hash code.</returns>
        </member>
        <member name="M:Sasa.Either`4.op_Equality(Sasa.Either{`0,`1,`2,`3},Sasa.Either{`0,`1,`2,`3})">
            <summary>
            Compare for equality.
            </summary>
            <param name="left">Left hand side.</param>
            <param name="right">Right hand side.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`4.op_Inequality(Sasa.Either{`0,`1,`2,`3},Sasa.Either{`0,`1,`2,`3})">
            <summary>
            Compare for inequality.
            </summary>
            <param name="left">Left hand side.</param>
            <param name="right">Right hand side.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Either`4.ToString">
            <summary>
            The string representation of the underlying value.
            </summary>
            <returns>A string representation of the underlying value.</returns>
        </member>
        <member name="T:Sasa.Enums">
            <summary>
            Extensions for System.Enum.
            </summary>
            <remarks>
            This static class provides a statically typed API for working with enums, analogous to the dynamically typed 
            <see cref="T:System.Enum"/>. Every method call in <see cref="T:System.Enum"/> that accepts a <see cref="T:System.Type"/>
            representing the enum type, here accepts a type parameter that is constrained to be of type enum.
            </remarks>
        </member>
        <member name="M:Sasa.Enums.ToEnum``1(System.String)">
            <summary>
            Parses an enumeration value from the string representation.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The string representation of the enum.</param>
            <returns>The enum corresponding to the string representation.</returns>
            <remarks>
            This extension method provides simple enum parsing:
            <code>
            enum Foo
            {
              Bar,
              Other,
            }
            Foo bar = "Bar".ToEnum&lt;Foo&gt;();
            if (bar == Foo.Bar)
              Console.WriteLine(bar);
            // output:
            // Bar
            </code>
            An exception is thrown if the provided string is not a valid enum name.
            </remarks>
        </member>
        <member name="M:Sasa.Enums.ToEnum``1(System.String,System.Boolean)">
            <summary>
            Parses an enumeration value from the string representation.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The string representation of the enum.</param>
            <param name="ignoreCase">Indicates whether the parse is case-sensitive.</param>
            <returns>The enum corresponding to the string representation.</returns>
            <remarks>
            This extension method provides simple enum parsing:
            <code>
            enum Foo
            {
              Bar,
              Other,
            }
            Foo bar = "Bar".ToEnum&lt;Foo&gt;();
            if (bar == Foo.Bar)
              Console.WriteLine(bar);
            // output:
            // Bar
            </code>
            An exception is thrown if the provided string is not a valid enum name.
            </remarks>
        </member>
        <member name="M:Sasa.Enums.IsDefined``1(``0)">
            <summary>
            Returns true if the value is valid for the given enum type.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The enum value to test.</param>
            <returns>Returns true if the value is valid for the enum.</returns>
            <remarks>
            This extension method checks whether the given enum value is valid:
            <code>
            enum Foo
            {
                Bar,
            }
            var defined = Foo.Bar;
            Console.WriteLine(defined.IsDefined());
            
            var undefined = (Foo)10;
            Console.WriteLine(undefined.IsDefined());
            
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Enums.Values``1">
            <summary>
            Retrieves a sequence of the values of the constants in a specified enumeration.
            </summary>
            <typeparam name="TEnum">An enumeration type.</typeparam>
            <returns>A typed sequence of the enumeration constants.</returns>
            <remarks>
            This static method provides all the underlying values of the given enum type. Like the
            <see cref="M:Sasa.Enums.Names``1" /> method, it returns a cached immutable sequence so it
            avoids the overhead of allocating arrays for every call:
            <code>
            enum Foo
            {
              Bar,
              Other,
            }
            foreach (var x in Enums.Values&lt;Foo&gt;())
            {
              Console.WriteLine(x);
            }
            // output:
            // Bar
            // Other
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Enums.Names``1">
            <summary>
            Retrieves a sequence of the values of the constants in a specified enumeration.
            </summary>
            <typeparam name="TEnum">An enumeration type.</typeparam>
            <returns>A sequence of the string representations of the enumeration constants.</returns>
            <remarks>
            This static method provides a enumerable sequence of strings corresponding to the enum's descriptive names.
            Essentially, this is the equivalent of <see cref="M:System.Enum.GetNames(System.Type)" />, except it's statically typed
            with an enum constraint, and it returns an immutable sequence so it doesn't have to allocate an array every
            time:
            <code>
            enum Foo
            {
              Bar,
              Other,
            }
            foreach (var x in Enums.Names&lt;Foo&gt;())
            {
              Console.WriteLine(x);
            }
            // output:
            // Bar
            // Other
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Enums.TryParse``1(System.String,``0@)">
            <summary>
            Attempt to parse the given string as an enum.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The string representation of the num.</param>
            <param name="output">The enum corresponding to the string representation if
            successful, or the default value otherwise.</param>
            <returns>True if the parse succeeded, false otherwise.</returns>
            <remarks>
            This extension method implements non exception-throwing pattern of parsing enums:
            <code>
            enum Foo
            {
                Bar,
                Other,
            }
            Foo bar;
            if ("Bar".TryParse&lt;Foo&gt;(out bar);)
                Console.WriteLine(bar);
            // output:
            // Bar
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Enums.TryParse``1(System.String,System.Boolean,``0@)">
            <summary>
            Attempt to parse the given string as an enum.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The string representation of the num.</param>
            <param name="ignoreCase">Indicates whether the parse is case-sensitive.</param>
            <param name="output">The enum corresponding to the string representation if
            successful, or the default value otherwise.</param>
            <returns>True if the parse succeeded, false otherwise.</returns>
            <remarks>
            This extension method implements non exception-throwing pattern of parsing enums:
            <code>
            enum Foo
            {
                Bar,
                Other,
            }
            Foo bar;
            if ("Bar".TryParse&lt;Foo&gt;(out bar);)
                Console.WriteLine(bar);
            // output:
            // Bar
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Enums.IsSet``1(``0,``0)">
            <summary>
            Checks for presence of flag.
            </summary>
            <typeparam name="TEnum">The enum type.</typeparam>
            <param name="value">The enum value.</param>
            <param name="flag">The flag to check.</param>
            <returns>True if the flag is set, false otherwise.</returns>
            <remarks>
            For enumerations that have the [Flags] attribute applied, this
            extension method provides a convenient means of checking whether
            a particular flag is set:
            <code>
            [Flags]
            enum Foo
            {
                Bar = 1,
                Other = 2,
            }
            var value = Foo.Bar | Foo.Other;
            Console.WriteLine(value.Enabled(Foo.Bar))
            Console.WriteLine(Foo.Other.Enabled(Foo.Bar))
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Enums`1">
            <summary>
            Exposes static properties of a given enum type.
            </summary>
            <typeparam name="TEnum">The enum type.</typeparam>
        </member>
        <member name="P:Sasa.Enums`1.IsSet">
            <summary>
            A delegate that checks whether an enum contains a flag.
            </summary>
            <returns>A delegate that checks a flag.</returns>
        </member>
        <member name="P:Sasa.Enums`1.Values">
            <summary>
            Retrieves a sequence of the values of the constants in a specified enumeration.
            </summary>
            <returns>A typed sequence of the enumeration constants.</returns>
            <remarks>
            This static method provides all the underlying values of the given enum type. Like the
            <see cref="M:Sasa.Enums.Names``1" /> method, it returns a cached immutable sequence so it
            avoids the overhead of allocating arrays for every call:
            <code>
            enum Foo
            {
              Bar,
              Other,
            }
            foreach (var x in Enums.Values&lt;Foo&gt;())
            {
              Console.WriteLine(x);
            }
            // output:
            // Bar
            // Other
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Enums`1.Names">
            <summary>
            Retrieves a sequence of the values of the constants in a specified enumeration.
            </summary>
            <returns>A sequence of the string representations of the enumeration constants.</returns>
            <remarks>
            This static method provides a enumerable sequence of strings corresponding to the enum's descriptive names.
            Essentially, this is the equivalent of <see cref="M:System.Enum.GetNames(System.Type)" />, except it's statically typed
            with an enum constraint, and it returns an immutable sequence so it doesn't have to allocate an array every
            time:
            <code>
            enum Foo
            {
              Bar,
              Other,
            }
            foreach (var x in Enums.Names&lt;Foo&gt;())
            {
              Console.WriteLine(x);
            }
            // output:
            // Bar
            // Other
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Enums`1.IsSequential">
            <summary>
            Checks whether an enum type consists of only sequential values.
            </summary>
            <returns>True if all values are sequential, false otherwise.</returns>
        </member>
        <member name="P:Sasa.Enums`1.Flags">
            <summary>
            True if <typeparamref name="TEnum"/> has the <see cref="T:System.FlagsAttribute"/> applied.
            </summary>
        </member>
        <member name="P:Sasa.Enums`1.MinValue">
            <summary>
            The minimum enum value.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if the <see cref="P:Sasa.Enums`1.Flags"/> is true.</exception>
        </member>
        <member name="P:Sasa.Enums`1.MaxValue">
            <summary>
            The maximum enum value.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if the <see cref="P:Sasa.Enums`1.Flags"/> is true.</exception>
        </member>
        <member name="T:Sasa.VFunc`2">
            <summary>
            Type used for open instance delegates to value types.
            </summary>
            <typeparam name="T0">The type of the 'this' parameter.</typeparam>
            <typeparam name="T1">The type of the instance method's first argument.</typeparam>
            <param name="arg0">The 'this' parameter.</param>
            <returns>The instance method return value.</returns>
        </member>
        <member name="T:Sasa.VFunc`3">
            <summary>
            Type used for open instance delegates to value types.
            </summary>
            <typeparam name="T0">The type of the 'this' parameter.</typeparam>
            <typeparam name="T1">The type of the instance method's first argument.</typeparam>
            <typeparam name="T2">The type of the instance method's second argument.</typeparam>
            <param name="arg0">The 'this' parameter.</param>
            <param name="arg1">The first argument of the instance method.</param>
            <returns>The instance method return value.</returns>
        </member>
        <member name="T:Sasa.VFunc`4">
            <summary>
            Type used for open instance delegates to value types.
            </summary>
            <typeparam name="T0">The type of the 'this' parameter.</typeparam>
            <typeparam name="T1">The type of the instance method's first argument.</typeparam>
            <typeparam name="T2">The type of the instance method's second argument.</typeparam>
            <typeparam name="T3">The type of the instance method's return value.</typeparam>
            <param name="arg0">The 'this' parameter.</param>
            <param name="arg1">The first argument of the instance method.</param>
            <param name="arg2">The second argument of the instance method.</param>
            <returns>The instance method return value.</returns>
        </member>
        <member name="T:Sasa.VFunc`5">
            <summary>
            Type used for open instance delegates to value types.
            </summary>
            <typeparam name="T0">The type of the 'this' parameter.</typeparam>
            <typeparam name="T1">The type of the instance method's first argument.</typeparam>
            <typeparam name="T2">The type of the instance method's second argument.</typeparam>
            <typeparam name="T3">The type of the instance method's third argument.</typeparam>
            <typeparam name="T4">The type of the instance method's return value.</typeparam>
            <param name="arg0">The 'this' parameter.</param>
            <param name="arg1">The first argument of the instance method.</param>
            <param name="arg2">The second argument of the instance method.</param>
            <param name="arg3">The third argument of the instance method.</param>
            <returns>The instance method return value.</returns>
        </member>
        <member name="T:Sasa.VAction`1">
            <summary>
            Type used for open instance delegates to value types.
            </summary>
            <typeparam name="T0">The type of the 'this' parameter.</typeparam>
            <param name="arg0">The 'this' parameter.</param>
        </member>
        <member name="T:Sasa.VAction`2">
            <summary>
            Type used for open instance delegates to value types.
            </summary>
            <typeparam name="T0">The type of the 'this' parameter.</typeparam>
            <typeparam name="T1">The type of the instance method's first argument.</typeparam>
            <param name="arg0">The 'this' parameter.</param>
            <param name="arg1">The first argument of the instance method.</param>
        </member>
        <member name="T:Sasa.VAction`3">
            <summary>
            Type used for open instance delegates to value types.
            </summary>
            <typeparam name="T0">The type of the 'this' parameter.</typeparam>
            <typeparam name="T1">The type of the instance method's first argument.</typeparam>
            <typeparam name="T2">The type of the instance method's second argument.</typeparam>
            <param name="arg0">The 'this' parameter.</param>
            <param name="arg1">The first argument of the instance method.</param>
            <param name="arg2">The second argument of the instance method.</param>
        </member>
        <member name="T:Sasa.VAction`4">
            <summary>
            Type used for open instance delegates to value types.
            </summary>
            <typeparam name="T0">The type of the 'this' parameter.</typeparam>
            <typeparam name="T1">The type of the instance method's first argument.</typeparam>
            <typeparam name="T2">The type of the instance method's second argument.</typeparam>
            <typeparam name="T3">The type of the instance method's third argument.</typeparam>
            <param name="arg0">The 'this' parameter.</param>
            <param name="arg1">The first argument of the instance method.</param>
            <param name="arg2">The second argument of the instance method.</param>
            <param name="arg3">The third argument of the instance method.</param>
        </member>
        <member name="T:Sasa.Func">
            <summary>
            Typed delegate extension methods.
            </summary>
        </member>
        <member name="M:Sasa.Func.Id``1(``0)">
            <summary>
            The identity function.
            </summary>
            <typeparam name="T">The type of value to return.</typeparam>
            <param name="value">The value to return.</param>
            <returns>Simply returns <paramref name="value"/>.</returns>
            <remarks>
            Use this method whenever you need a delegate that simply returns its argument. This is fairly common
            when using the <see cref="N:System.Linq"/> API. Usage:
            <code>
            int[][] nested = new int[][]
            {
               { 0, 1, 2 },
               { 3, 4, 5 }, 
               { 6, 7, 8 },
            };
            IEnumerable&lt;int&gt; flattened = nested.SelectMany(Func.Id);
            
            foreach (var x in flattened) Console.Write(" {0},"x);
            // prints out:
            //  0, 1, 2, 3, 4, 5, 6, 7, 8,
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Operator``1(Sasa.Operator)">
            <summary>
            Extract a delegate for the given operator.
            </summary>
            <typeparam name="TFunc">The delegate type.</typeparam>
            <param name="op">The operator delegate to find.</param>
            <returns>A delegate of type <typeparamref name="TFunc"/> for the given operator, or null if no match found.</returns>
            <remarks>
            This static method searches for the first operator type <paramref name="op"/> that matches
            the signature given in <typeparamref name="TFunc"/>. It then constructs a delegate for that
            operator:
            <code>
            var add = Func.Operator&lt;Func&lt;int, int, int&gt;&gt;(Operator.Add);
            Console.WriteLine(add(1, 2));
            // output:
            // 3
            </code>
            Certain CLR primitives don't actually have methods defined for their operators. In this case,
            this method generates a DynamicMethod that simply executes the primitive instruction.
            </remarks>
        </member>
        <member name="M:Sasa.Func.Fix``2(System.Func{System.Func{``0,``1},System.Func{``0,``1}})">
            <summary>
            Compute the fixpoint of a given function.
            </summary>
            <typeparam name="T0">The argument type.</typeparam>
            <typeparam name="T1">The return type.</typeparam>
            <param name="recurse">The function describing the body of the recursive function.</param>
            <returns>A recursive definition of the given function.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a method used to generate recursive lambdas. Delegates built from lambdas can't refer
            to themselves to make recursive calls. Sasa.Func.Fix addresses this by providing what's known
            as a fixpoint function. Usage:
            <code>
            // equivalent recursive function:
            // int Sum(int x) { return x > 0 ? x + Sum(x-1) : 0; }
            var f1 = Func.Fix&lt;int, int&gt;(
                     f =&gt; x =&gt; x > 0 ? x + f(x - 1) : 0);
            Console.WriteLine(f1(2));
            Console.WriteLine(f1(5));
            // prints
            // 3
            // 15
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Fix``3(System.Func{System.Func{``0,``1,``2},System.Func{``0,``1,``2}})">
            <summary>
            Compute the fixpoint of a given function.
            </summary>
            <typeparam name="T0">The first argument type.</typeparam>
            <typeparam name="T1">The second argument type.</typeparam>
            <typeparam name="T2">The return type.</typeparam>
            <param name="recurse">The function describing the body of the recursive function.</param>
            <returns>A recursive definition of the given function.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a method used to generate recursive lambdas. Delegates built from lambdas can't refer
            to themselves to make recursive calls. Sasa.Func.Fix addresses this by providing what's known
            as a fixpoint function. Usage:
            <code>
            // equivalent recursive function:
            // int Sum(int x) { return x > 0 ? x + Sum(x-1) : 0; }
            var f1 = Func.Fix&lt;int, int&gt;(
                     f =&gt; x =&gt; x > 0 ? x + f(x - 1) : 0);
            Console.WriteLine(f1(2));
            Console.WriteLine(f1(5));
            // prints
            // 3
            // 15
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Open``2(System.Func{``1})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The method return value.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            A delegate designating <see cref="M:System.Object.ToString" /> can take two forms:
            <list>
            <item>
                <term>Closed Instance Delegate</term>
                <description>
                The typical closed delegate has type System.Func&lt;string&gt; and encapsulates the
                reference to the object being converted to a string.
                </description>
            </item>
            <item>
                <item>Open Instance Delegate</item>
                <description>
                The open instance delegate would have type System.Func&lt;object, string&gt;, so the
                object being converted to a string must be passed in each time.
                </description>
            </item>
            </list>
            <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/> methods serve the same purpose,
            namely to create a so-called open instance delegate, where the 'this' parameter is not encapsulated
            within the delegate itself, but is itself the first parameter passed to the delegate.
            
            This allows you to reuse the same delegate multiple times on different objects without needing a
            different delegate for each object you want to convert to a string, or whatever other operation
            desired. This is also how efficient dispatch works in <see
            cref="!:http://higherlogics.blogspot.ca/2013/03/sasa-v094-rc2-released-sasadynamics.html">Sasa.Dynamics</see>,
            ie. the cached delegate in Sasa.Dynamics.Type&lt;T&gt;.Reduce(Sasa.Dynamics.IReduce, T) is
            a statically computed, cached open instance delegate to the method that handles type T in
            the IReduce interface.
            
            Usage:
            <code>
            class Foo
            {
                public int Value { get; set; }
                public int Bar() { return Value; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Func&lt;int&gt; closed = foo.Bar;
            Func&lt;Foo, int&gt; open = Func.Open&lt;Foo, int&gt;(closed);
            var foo2 = new Foo { Value = 9999 };
            Console.WriteLine(open(foo));
            Console.WriteLine(open(foo2));
            // prints:
            // 3
            // 9999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Open``3(System.Func{``1,``2})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The method return value.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            A delegate designating <see cref="M:System.Object.ToString" /> can take two forms:
            <list>
            <item>
                <term>Closed Instance Delegate</term>
                <description>
                The typical closed delegate has type System.Func&lt;string&gt; and encapsulates the
                reference to the object being converted to a string.
                </description>
            </item>
            <item>
                <item>Open Instance Delegate</item>
                <description>
                The open instance delegate would have type System.Func&lt;object, string&gt;, so the
                object being converted to a string must be passed in each time.
                </description>
            </item>
            </list>
            <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/> methods serve the same purpose,
            namely to create a so-called open instance delegate, where the 'this' parameter is not encapsulated
            within the delegate itself, but is itself the first parameter passed to the delegate.
            
            This allows you to reuse the same delegate multiple times on different objects without needing a
            different delegate for each object you want to convert to a string, or whatever other operation
            desired. This is also how efficient dispatch works in <see
            cref="!:http://higherlogics.blogspot.ca/2013/03/sasa-v094-rc2-released-sasadynamics.html">Sasa.Dynamics</see>,
            ie. the cached delegate in Sasa.Dynamics.Type&lt;T&gt;.Reduce(Sasa.Dynamics.IReduce, T) is
            a statically computed, cached open instance delegate to the method that handles type T in
            the IReduce interface.
            
            Usage:
            <code>
            class Foo
            {
                public int Value { get; set; }
                public int Bar() { return Value; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Func&lt;int&gt; closed = foo.Bar;
            Func&lt;Foo, int&gt; open = Func.Open&lt;Foo, int&gt;(closed);
            var foo2 = new Foo { Value = 9999 };
            Console.WriteLine(open(foo));
            Console.WriteLine(open(foo2));
            // prints:
            // 3
            // 9999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Open``4(System.Func{``1,``2,``3})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The second method argument.</typeparam>
            <typeparam name="T3">The method return value.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            A delegate designating <see cref="M:System.Object.ToString" /> can take two forms:
            <list>
            <item>
                <term>Closed Instance Delegate</term>
                <description>
                The typical closed delegate has type System.Func&lt;string&gt; and encapsulates the
                reference to the object being converted to a string.
                </description>
            </item>
            <item>
                <item>Open Instance Delegate</item>
                <description>
                The open instance delegate would have type System.Func&lt;object, string&gt;, so the
                object being converted to a string must be passed in each time.
                </description>
            </item>
            </list>
            <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/> methods serve the same purpose,
            namely to create a so-called open instance delegate, where the 'this' parameter is not encapsulated
            within the delegate itself, but is itself the first parameter passed to the delegate.
            
            This allows you to reuse the same delegate multiple times on different objects without needing a
            different delegate for each object you want to convert to a string, or whatever other operation
            desired. This is also how efficient dispatch works in <see
            cref="!:http://higherlogics.blogspot.ca/2013/03/sasa-v094-rc2-released-sasadynamics.html">Sasa.Dynamics</see>,
            ie. the cached delegate in Sasa.Dynamics.Type&lt;T&gt;.Reduce(Sasa.Dynamics.IReduce, T) is
            a statically computed, cached open instance delegate to the method that handles type T in
            the IReduce interface.
            
            Usage:
            <code>
            class Foo
            {
                public int Value { get; set; }
                public int Bar() { return Value; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Func&lt;int&gt; closed = foo.Bar;
            Func&lt;Foo, int&gt; open = Func.Open&lt;Foo, int&gt;(closed);
            var foo2 = new Foo { Value = 9999 };
            Console.WriteLine(open(foo));
            Console.WriteLine(open(foo2));
            // prints:
            // 3
            // 9999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Open``5(System.Func{``1,``2,``3,``4})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The second method argument.</typeparam>
            <typeparam name="T3">The third method argument.</typeparam>
            <typeparam name="T4">The method return value.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            A delegate designating <see cref="M:System.Object.ToString" /> can take two forms:
            <list>
            <item>
                <term>Closed Instance Delegate</term>
                <description>
                The typical closed delegate has type System.Func&lt;string&gt; and encapsulates the
                reference to the object being converted to a string.
                </description>
            </item>
            <item>
                <item>Open Instance Delegate</item>
                <description>
                The open instance delegate would have type System.Func&lt;object, string&gt;, so the
                object being converted to a string must be passed in each time.
                </description>
            </item>
            </list>
            <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/> methods serve the same purpose,
            namely to create a so-called open instance delegate, where the 'this' parameter is not encapsulated
            within the delegate itself, but is itself the first parameter passed to the delegate.
            
            This allows you to reuse the same delegate multiple times on different objects without needing a
            different delegate for each object you want to convert to a string, or whatever other operation
            desired. This is also how efficient dispatch works in <see
            cref="!:http://higherlogics.blogspot.ca/2013/03/sasa-v094-rc2-released-sasadynamics.html">Sasa.Dynamics</see>,
            ie. the cached delegate in Sasa.Dynamics.Type&lt;T&gt;.Reduce(Sasa.Dynamics.IReduce, T) is
            a statically computed, cached open instance delegate to the method that handles type T in
            the IReduce interface.
            
            Usage:
            <code>
            class Foo
            {
                public int Value { get; set; }
                public int Bar() { return Value; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Func&lt;int&gt; closed = foo.Bar;
            Func&lt;Foo, int&gt; open = Func.Open&lt;Foo, int&gt;(closed);
            var foo2 = new Foo { Value = 9999 };
            Console.WriteLine(open(foo));
            Console.WriteLine(open(foo2));
            // prints:
            // 3
            // 9999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.VOpen``2(System.Func{``1})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The method return value.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            These methods serve the same purpose as <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/>,
            but they operate directly on structs. As before, the first parameter to a method is always a reference to
            the object being manipulated, but structs aren't reference types, so a method for struct T actually
            accepts a "ref T" as its first argument. Thus, open instance delegates that modify their struct argument
            must have a different signature, namely that of <see cref="T:Sasa.VAction`2"/> or <see cref="T:Sasa.VFunc`3"/>,
            all of which take "ref T" as the first argument.
            
            This overload creates open instance delegates that return values. Usage:
            <code>
            struct Foo
            {
                public int Value { get; set; }
                public void Double() { Value *= 2; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Action closed = foo.Double;
            VAction&lt;Foo&gt; open = Func.VOpen&lt;Foo&gt;(closed);
            var foo2 = new Foo { Value = 444 };
            open(ref foo);
            open(ref foo2);
            Console.WriteLine(foo.Value);
            Console.WriteLine(foo2.Value);
            // prints:
            // 6
            // 888
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.VOpen``3(System.Func{``1,``2})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The method return value.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            These methods serve the same purpose as <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/>,
            but they operate directly on structs. As before, the first parameter to a method is always a reference to
            the object being manipulated, but structs aren't reference types, so a method for struct T actually
            accepts a "ref T" as its first argument. Thus, open instance delegates that modify their struct argument
            must have a different signature, namely that of <see cref="T:Sasa.VAction`2"/> or <see cref="T:Sasa.VFunc`3"/>,
            all of which take "ref T" as the first argument.
            
            This overload creates open instance delegates that return values. Usage:
            <code>
            struct Foo
            {
                public int Value { get; set; }
                public void Double() { Value *= 2; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Action closed = foo.Double;
            VAction&lt;Foo&gt; open = Func.VOpen&lt;Foo&gt;(closed);
            var foo2 = new Foo { Value = 444 };
            open(ref foo);
            open(ref foo2);
            Console.WriteLine(foo.Value);
            Console.WriteLine(foo2.Value);
            // prints:
            // 6
            // 888
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.VOpen``4(System.Func{``1,``2,``3})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The second method argument.</typeparam>
            <typeparam name="T3">The method return value.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            These methods serve the same purpose as <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/>,
            but they operate directly on structs. As before, the first parameter to a method is always a reference to
            the object being manipulated, but structs aren't reference types, so a method for struct T actually
            accepts a "ref T" as its first argument. Thus, open instance delegates that modify their struct argument
            must have a different signature, namely that of <see cref="T:Sasa.VAction`2"/> or <see cref="T:Sasa.VFunc`3"/>,
            all of which take "ref T" as the first argument.
            
            This overload creates open instance delegates that return values. Usage:
            <code>
            struct Foo
            {
                public int Value { get; set; }
                public void Double() { Value *= 2; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Action closed = foo.Double;
            VAction&lt;Foo&gt; open = Func.VOpen&lt;Foo&gt;(closed);
            var foo2 = new Foo { Value = 444 };
            open(ref foo);
            open(ref foo2);
            Console.WriteLine(foo.Value);
            Console.WriteLine(foo2.Value);
            // prints:
            // 6
            // 888
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.VOpen``5(System.Func{``1,``2,``3,``4})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The second method argument.</typeparam>
            <typeparam name="T3">The third method argument.</typeparam>
            <typeparam name="T4">The method return value.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            These methods serve the same purpose as <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/>,
            but they operate directly on structs. As before, the first parameter to a method is always a reference to
            the object being manipulated, but structs aren't reference types, so a method for struct T actually
            accepts a "ref T" as its first argument. Thus, open instance delegates that modify their struct argument
            must have a different signature, namely that of <see cref="T:Sasa.VAction`2"/> or <see cref="T:Sasa.VFunc`3"/>,
            all of which take "ref T" as the first argument.
            
            This overload creates open instance delegates that return values. Usage:
            <code>
            struct Foo
            {
                public int Value { get; set; }
                public void Double() { Value *= 2; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Action closed = foo.Double;
            VAction&lt;Foo&gt; open = Func.VOpen&lt;Foo&gt;(closed);
            var foo2 = new Foo { Value = 444 };
            open(ref foo);
            open(ref foo2);
            Console.WriteLine(foo.Value);
            Console.WriteLine(foo2.Value);
            // prints:
            // 6
            // 888
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.OpenAction``1(System.Action)">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T">The class on which this delegate dispatches.</typeparam>
            <param name="instance"></param>
            <returns>An open instance delegate on <typeparamref name="T"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T"/>.</exception>
            <remarks>
            A delegate designating <see cref="M:System.Object.ToString" /> can take two forms:
            <list>
            <item>
                <term>Closed Instance Delegate</term>
                <description>
                The typical closed delegate has type System.Func&lt;string&gt; and encapsulates the
                reference to the object being converted to a string.
                </description>
            </item>
            <item>
                <item>Open Instance Delegate</item>
                <description>
                The open instance delegate would have type System.Func&lt;object, string&gt;, so the
                object being converted to a string must be passed in each time.
                </description>
            </item>
            </list>
            <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/> methods serve the same purpose,
            namely to create a so-called open instance delegate, where the 'this' parameter is not encapsulated
            within the delegate itself, but is itself the first parameter passed to the delegate.
            
            This allows you to reuse the same delegate multiple times on different objects without needing a
            different delegate for each object you want to convert to a string, or whatever other operation
            desired. This is also how efficient dispatch works in <see
            cref="!:http://higherlogics.blogspot.ca/2013/03/sasa-v094-rc2-released-sasadynamics.html">Sasa.Dynamics</see>,
            ie. the cached delegate in Sasa.Dynamics.Type&lt;T&gt;.Reduce(Sasa.Dynamics.IReduce, T) is
            a statically computed, cached open instance delegate to the method that handles type T in
            the IReduce interface.
            
            Usage:
            <code>
            class Foo
            {
                public int Value { get; set; }
                public int Bar() { return Value; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Func&lt;int&gt; closed = foo.Bar;
            Func&lt;Foo, int&gt; open = Func.Open&lt;Foo, int&gt;(closed);
            var foo2 = new Foo { Value = 9999 };
            Console.WriteLine(open(foo));
            Console.WriteLine(open(foo2));
            // prints:
            // 3
            // 9999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.OpenAction``2(System.Action{``1})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            A delegate designating <see cref="M:System.Object.ToString" /> can take two forms:
            <list>
            <item>
                <term>Closed Instance Delegate</term>
                <description>
                The typical closed delegate has type System.Func&lt;string&gt; and encapsulates the
                reference to the object being converted to a string.
                </description>
            </item>
            <item>
                <item>Open Instance Delegate</item>
                <description>
                The open instance delegate would have type System.Func&lt;object, string&gt;, so the
                object being converted to a string must be passed in each time.
                </description>
            </item>
            </list>
            <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/> methods serve the same purpose,
            namely to create a so-called open instance delegate, where the 'this' parameter is not encapsulated
            within the delegate itself, but is itself the first parameter passed to the delegate.
            
            This allows you to reuse the same delegate multiple times on different objects without needing a
            different delegate for each object you want to convert to a string, or whatever other operation
            desired. This is also how efficient dispatch works in <see
            cref="!:http://higherlogics.blogspot.ca/2013/03/sasa-v094-rc2-released-sasadynamics.html">Sasa.Dynamics</see>,
            ie. the cached delegate in Sasa.Dynamics.Type&lt;T&gt;.Reduce(Sasa.Dynamics.IReduce, T) is
            a statically computed, cached open instance delegate to the method that handles type T in
            the IReduce interface.
            
            Usage:
            <code>
            class Foo
            {
                public int Value { get; set; }
                public int Bar() { return Value; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Func&lt;int&gt; closed = foo.Bar;
            Func&lt;Foo, int&gt; open = Func.Open&lt;Foo, int&gt;(closed);
            var foo2 = new Foo { Value = 9999 };
            Console.WriteLine(open(foo));
            Console.WriteLine(open(foo2));
            // prints:
            // 3
            // 9999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.OpenAction``3(System.Action{``1,``2})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The second method argument.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            A delegate designating <see cref="M:System.Object.ToString" /> can take two forms:
            <list>
            <item>
                <term>Closed Instance Delegate</term>
                <description>
                The typical closed delegate has type System.Func&lt;string&gt; and encapsulates the
                reference to the object being converted to a string.
                </description>
            </item>
            <item>
                <item>Open Instance Delegate</item>
                <description>
                The open instance delegate would have type System.Func&lt;object, string&gt;, so the
                object being converted to a string must be passed in each time.
                </description>
            </item>
            </list>
            <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/> methods serve the same purpose,
            namely to create a so-called open instance delegate, where the 'this' parameter is not encapsulated
            within the delegate itself, but is itself the first parameter passed to the delegate.
            
            This allows you to reuse the same delegate multiple times on different objects without needing a
            different delegate for each object you want to convert to a string, or whatever other operation
            desired. This is also how efficient dispatch works in <see
            cref="!:http://higherlogics.blogspot.ca/2013/03/sasa-v094-rc2-released-sasadynamics.html">Sasa.Dynamics</see>,
            ie. the cached delegate in Sasa.Dynamics.Type&lt;T&gt;.Reduce(Sasa.Dynamics.IReduce, T) is
            a statically computed, cached open instance delegate to the method that handles type T in
            the IReduce interface.
            
            Usage:
            <code>
            class Foo
            {
                public int Value { get; set; }
                public int Bar() { return Value; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Func&lt;int&gt; closed = foo.Bar;
            Func&lt;Foo, int&gt; open = Func.Open&lt;Foo, int&gt;(closed);
            var foo2 = new Foo { Value = 9999 };
            Console.WriteLine(open(foo));
            Console.WriteLine(open(foo2));
            // prints:
            // 3
            // 9999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.OpenAction``4(System.Action{``1,``2,``3})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The second method argument.</typeparam>
            <typeparam name="T3">The third method argument.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            A delegate designating <see cref="M:System.Object.ToString" /> can take two forms:
            <list>
            <item>
                <term>Closed Instance Delegate</term>
                <description>
                The typical closed delegate has type System.Func&lt;string&gt; and encapsulates the
                reference to the object being converted to a string.
                </description>
            </item>
            <item>
                <item>Open Instance Delegate</item>
                <description>
                The open instance delegate would have type System.Func&lt;object, string&gt;, so the
                object being converted to a string must be passed in each time.
                </description>
            </item>
            </list>
            <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/> methods serve the same purpose,
            namely to create a so-called open instance delegate, where the 'this' parameter is not encapsulated
            within the delegate itself, but is itself the first parameter passed to the delegate.
            
            This allows you to reuse the same delegate multiple times on different objects without needing a
            different delegate for each object you want to convert to a string, or whatever other operation
            desired. This is also how efficient dispatch works in <see
            cref="!:http://higherlogics.blogspot.ca/2013/03/sasa-v094-rc2-released-sasadynamics.html">Sasa.Dynamics</see>,
            ie. the cached delegate in Sasa.Dynamics.Type&lt;T&gt;.Reduce(Sasa.Dynamics.IReduce, T) is
            a statically computed, cached open instance delegate to the method that handles type T in
            the IReduce interface.
            
            Usage:
            <code>
            class Foo
            {
                public int Value { get; set; }
                public int Bar() { return Value; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Func&lt;int&gt; closed = foo.Bar;
            Func&lt;Foo, int&gt; open = Func.Open&lt;Foo, int&gt;(closed);
            var foo2 = new Foo { Value = 9999 };
            Console.WriteLine(open(foo));
            Console.WriteLine(open(foo2));
            // prints:
            // 3
            // 9999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.VOpenAction``1(System.Action)">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T">The class on which this delegate dispatches.</typeparam>
            <param name="instance"></param>
            <returns>An open instance delegate on <typeparamref name="T"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T"/>.</exception>
            <remarks>
            These methods serve the same purpose as <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/>,
            but they operate directly on structs. As before, the first parameter to a method is always a reference to
            the object being manipulated, but structs aren't reference types, so a method for struct T actually
            accepts a "ref T" as its first argument. Thus, open instance delegates that modify their struct argument
            must have a different signature, namely that of <see cref="T:Sasa.VAction`2"/> or <see cref="T:Sasa.VFunc`3"/>,
            all of which take "ref T" as the first argument.
            
            This overload creates open instance delegates that return void. Usage:
            <code>
            struct Foo
            {
                public int Value { get; set; }
                public void Double() { Value *= 2; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Action closed = foo.Double;
            VAction&lt;Foo&gt; open = Func.VOpen&lt;Foo&gt;(closed);
            var foo2 = new Foo { Value = 444 };
            open(ref foo);
            open(ref foo2);
            Console.WriteLine(foo.Value);
            Console.WriteLine(foo2.Value);
            // prints:
            // 6
            // 888
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.VOpenAction``2(System.Action{``1})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            These methods serve the same purpose as <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/>,
            but they operate directly on structs. As before, the first parameter to a method is always a reference to
            the object being manipulated, but structs aren't reference types, so a method for struct T actually
            accepts a "ref T" as its first argument. Thus, open instance delegates that modify their struct argument
            must have a different signature, namely that of <see cref="T:Sasa.VAction`2"/> or <see cref="T:Sasa.VFunc`3"/>,
            all of which take "ref T" as the first argument.
            
            This overload creates open instance delegates that return values. Usage:
            <code>
            struct Foo
            {
                public int Value { get; set; }
                public void Double() { Value *= 2; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Action closed = foo.Double;
            VAction&lt;Foo&gt; open = Func.VOpen&lt;Foo&gt;(closed);
            var foo2 = new Foo { Value = 444 };
            open(ref foo);
            open(ref foo2);
            Console.WriteLine(foo.Value);
            Console.WriteLine(foo2.Value);
            // prints:
            // 6
            // 888
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.VOpenAction``3(System.Action{``1,``2})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The second method argument.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            These methods serve the same purpose as <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/>,
            but they operate directly on structs. As before, the first parameter to a method is always a reference to
            the object being manipulated, but structs aren't reference types, so a method for struct T actually
            accepts a "ref T" as its first argument. Thus, open instance delegates that modify their struct argument
            must have a different signature, namely that of <see cref="T:Sasa.VAction`2"/> or <see cref="T:Sasa.VFunc`3"/>,
            all of which take "ref T" as the first argument.
            
            This overload creates open instance delegates that return values. Usage:
            <code>
            struct Foo
            {
                public int Value { get; set; }
                public void Double() { Value *= 2; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Action closed = foo.Double;
            VAction&lt;Foo&gt; open = Func.VOpen&lt;Foo&gt;(closed);
            var foo2 = new Foo { Value = 444 };
            open(ref foo);
            open(ref foo2);
            Console.WriteLine(foo.Value);
            Console.WriteLine(foo2.Value);
            // prints:
            // 6
            // 888
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.VOpenAction``4(System.Action{``1,``2,``3})">
            <summary>
            Create an open instance delegate from a closed delegate.
            </summary>
            <typeparam name="T0">The class on which this delegate dispatches.</typeparam>
            <typeparam name="T1">The first method argument.</typeparam>
            <typeparam name="T2">The second method argument.</typeparam>
            <typeparam name="T3">The third method argument.</typeparam>
            <param name="instance">The current delegate instance.</param>
            <returns>An open instance delegate on <typeparamref name="T0"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="instance"/>'s declaring type is not <typeparamref name="T0"/>.</exception>
            <remarks>
            These methods serve the same purpose as <see cref="M:Sasa.Func.Open``2(System.Func{``1})"/> and <see cref="M:Sasa.Func.OpenAction``1(System.Action)"/>,
            but they operate directly on structs. As before, the first parameter to a method is always a reference to
            the object being manipulated, but structs aren't reference types, so a method for struct T actually
            accepts a "ref T" as its first argument. Thus, open instance delegates that modify their struct argument
            must have a different signature, namely that of <see cref="T:Sasa.VAction`2"/> or <see cref="T:Sasa.VFunc`3"/>,
            all of which take "ref T" as the first argument.
            
            This overload creates open instance delegates that return values. Usage:
            <code>
            struct Foo
            {
                public int Value { get; set; }
                public void Double() { Value *= 2; }
            }
            ...
            var foo = new Foo { Value = 3 };
            Action closed = foo.Double;
            VAction&lt;Foo&gt; open = Func.VOpen&lt;Foo&gt;(closed);
            var foo2 = new Foo { Value = 444 };
            open(ref foo);
            open(ref foo2);
            Console.WriteLine(foo.Value);
            Console.WriteLine(foo2.Value);
            // prints:
            // 6
            // 888
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Getter``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Obtain a getter for a member.
            </summary>
            <typeparam name="TObj">The class type containing the member.</typeparam>
            <typeparam name="TMember">The return type of the property.</typeparam>
            <param name="property">A simple member access expression.</param>
            <returns>A direct delegate to the getter method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            A somewhat recurring pattern in C# programming is generating a delegate to
            access the value of a property. It's a little wasteful to generate a whole new
            delegate that closes over an object instance and then accesses the property,
            considering the object already has a method getter, ie. for property Foo,
            the C# compiler generates a get_Foo method.
            
            This method allows you specify an expression naming a property, and will return
            a delegate to the direct method getter for that property. Usage:
            <code>
            struct Foo
            {
              public int SomeInt { get; set; }
            }
            ...
            var getter = Func.Getter&lt;Foo, int&gt;(x => x.SomeInt);
            var foosInt = getter(someFoo);
            </code>
            At the moment, the whole expression tree is generated every time this method is invoked,
            but a future extension to Sasa's ilrewriter will eliminate this entirely and generate
            direct operations on CIL metadata.
            </remarks>
        </member>
        <member name="M:Sasa.Func.Setter``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Obtain a getter for a member.
            </summary>
            <typeparam name="TObj">The class type containing the member.</typeparam>
            <typeparam name="TMember">The return type of the member.</typeparam>
            <param name="property">A simple member access expression.</param>
            <returns>A direct delegate to the property setter method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            The dual to <see cref="M:Sasa.Func.Getter``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>, this method obtains a delegate for the
            direct setter method of an object. Usage:
            <code>
            struct Foo
            {
              public int SomeInt { get; set; }
            }
            ...
            var setter = Func.Setter&lt;Foo, int&gt;(x => x.SomeInt);
            setter(someFoo, 99);
            </code>
            Similar to <see cref="M:Sasa.Func.Getter``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})" />, this will soon be inlined
            when using Sasa's ilrewriter.
            </remarks>
        </member>
        <member name="M:Sasa.Func.Getter``2(System.Reflection.MemberInfo)">
            <summary>
            Obtain a getter for a property.
            </summary>
            <typeparam name="TObj">The class type containing the member.</typeparam>
            <typeparam name="TMember">The return type of the property.</typeparam>
            <param name="member">A member reference.</param>
            <returns>A direct delegate to the getter method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            A somewhat recurring pattern in C# programming is generating a delegate to
            access the value of a property. It's a little wasteful to generate a whole new
            delegate that closes over an object instance and then accesses the property,
            considering the object already has a method getter, ie. for property Foo,
            the C# compiler generates a get_Foo method.
            
            This method allows you specify an expression naming a property, and will return
            a delegate to the direct method getter for that property. Usage:
            <code>
            struct Foo
            {
              public int SomeInt { get; set; }
            }
            ...
            var getter = Func.Getter&lt;Foo, int&gt;(x => x.SomeInt);
            var foosInt = getter(someFoo);
            </code>
            At the moment, the whole expression tree is generated every time this method is invoked,
            but a future extension to Sasa's ilrewriter will eliminate this entirely and generate
            direct operations on CIL metadata.
            </remarks>
        </member>
        <member name="M:Sasa.Func.Setter``2(System.Reflection.MemberInfo)">
            <summary>
            Obtain a getter for a property.
            </summary>
            <typeparam name="TObj">The class type containing the property.</typeparam>
            <typeparam name="TMember">The return type of the property.</typeparam>
            <param name="member">A member reference.</param>
            <returns>A direct delegate to the property setter method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            The dual to <see cref="M:Sasa.Func.Getter``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>, this method obtains a delegate for the
            direct setter method of an object. Usage:
            <code>
            struct Foo
            {
              public int SomeInt { get; set; }
            }
            ...
            var setter = Func.Setter&lt;Foo, int&gt;(x => x.SomeInt);
            setter(someFoo, 99);
            </code>
            Similar to Sasa.Func.Getter, this will soon be inlined completely when using Sasa's ilrewriter.
            </remarks>
        </member>
        <member name="M:Sasa.Func.Getter``2(System.Reflection.PropertyInfo)">
            <summary>
            Obtain a getter for a property.
            </summary>
            <typeparam name="TObj">The class type containing the property.</typeparam>
            <typeparam name="TProperty">The return type of the property.</typeparam>
            <param name="property">A property reference.</param>
            <returns>A direct delegate to the getter method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            A somewhat recurring pattern in C# programming is generating a delegate to
            access the value of a property. It's a little wasteful to generate a whole new
            delegate that closes over an object instance and then accesses the property,
            considering the object already has a method getter, ie. for property Foo,
            the C# compiler generates a get_Foo method.
            
            This method allows you specify an expression naming a property, and will return
            a delegate to the direct method getter for that property. Usage:
            <code>
            struct Foo
            {
              public int SomeInt { get; set; }
            }
            ...
            var getter = Func.Getter&lt;Foo, int&gt;(x => x.SomeInt);
            var foosInt = getter(someFoo);
            </code>
            At the moment, the whole expression tree is generated every time this method is invoked,
            but a future extension to Sasa's ilrewriter will eliminate this entirely and generate
            direct operations on CIL metadata.
            </remarks>
        </member>
        <member name="M:Sasa.Func.Setter``2(System.Reflection.PropertyInfo)">
            <summary>
            Obtain a getter for a property.
            </summary>
            <typeparam name="TObj">The class type with the getter.</typeparam>
            <typeparam name="TProperty">The return type of the property.</typeparam>
            <param name="property">A simple member access expression.</param>
            <returns>A direct delegate to the property setter method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            The dual to <see cref="M:Sasa.Func.Getter``2(System.Reflection.PropertyInfo)"/>, this method obtains a delegate for the
            direct setter method of an object. Usage:
            <code>
            struct Foo
            {
              public int SomeInt { get; set; }
            }
            ...
            var setter = Func.Setter&lt;Foo, int&gt;(x => x.SomeInt);
            setter(someFoo, 99);
            </code>
            Similar to Sasa.Func.Getter, this will soon be inlined completely when using Sasa's ilrewriter.
            </remarks>
        </member>
        <member name="M:Sasa.Func.Getter``2(System.Reflection.FieldInfo)">
            <summary>
            Obtain a getter for an object field.
            </summary>
            <typeparam name="TObj">The class type containing the field.</typeparam>
            <typeparam name="TField">The field's type.</typeparam>
            <param name="field">The reflection info for the field.</param>
            <returns>A delegate that returns the field value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This method allows you specify an expression naming a field, and will return
            a delegate to return the value of that field. Usage:
            <code>
            struct Foo
            {
              public int SomeInt;
            }
            ...
            var getter = Func.Getter&lt;Foo, int&gt;(x => x.SomeInt);
            var foosInt = getter(someFoo);
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Setter``2(System.Reflection.FieldInfo)">
            <summary>
            Obtain a getter for a property.
            </summary>
            <typeparam name="TObj">The class type containing the field.</typeparam>
            <typeparam name="TField">The return type of the property.</typeparam>
            <param name="field">A field reference.</param>
            <returns>A direct delegate to the property setter method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            The dual to <see cref="M:Sasa.Func.Getter``2(System.Reflection.FieldInfo)"/>, this method obtains a delegate to directly
            set the value of an object's field. Usage:
            <code>
            struct Foo
            {
              public int SomeInt;
            }
            ...
            var setter = Func.Setter&lt;Foo, int&gt;(x => x.SomeInt);
            setter(someFoo, 99);
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Constructor``2">
            <summary>
            Create a delegate from a constructor.
            </summary>
            <typeparam name="T">The type being constructed.</typeparam>
            <typeparam name="TFunc">The type of the delegate to create.</typeparam>
            <returns>A delegate used for constructing types.</returns>
        </member>
        <member name="M:Sasa.Func.Create``1(System.Reflection.MethodInfo)">
            <summary>
            Creates an open instance or static delegate.
            </summary>
            <typeparam name="T">The delegate type.</typeparam>
            <param name="method">The designated method to delegate to.</param>
            <returns>A delegate of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Sasa.Func.Create``1(System.Object,System.Reflection.MethodInfo)">
             <summary>
             Create a delegate.
             </summary>
             <typeparam name="T">The delegate type.</typeparam>
             <param name="target">The delegate target. If null, and <paramref name="method"/> is an instance method, it creates an "open" instance delegate.</param>
             <param name="method">The designated method to delegate to.</param>
             <returns>A delegate of type <typeparamref name="T"/>.</returns>
             <remarks>
             This is a type-safe wrapper for <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />. Usage:
             <code>
             class Foo
             {
                public int Bar(int i);
             }
             ...
             var delegate1 = Func.Create&lt;Func&lt;int, int&gt;&gt;(new Foo(), typeof(Foo).GetMethod("Bar"));
             </code>
             However, <see cref="M:Sasa.Func.Create``1(System.Reflection.MethodInfo)"/> is strictly more powerful than
             <see cref="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
             because it addresses <see cref="!:http://higherlogics.blogspot.ca/2011/08/open-instance-delegate-for-generic.html">certain
             limitations of the CLR I discovered years ago</see>. The following are the CRLs limitations:
             
             Delegate.CreateDelegate failure modes:
             'this'   open generic method     open virtual method
             ----------------------------------------------------
             struct   error                   fine
             class    error                   error
            
             'this'   Func      VFunc
             -------------------------
             struct   error     fine
             class    fine      error
            
             Func.Create makes it:
             'this'   open generic method    open virtual method
             ---------------------------------------------
             struct   fine                   fine
             class    fine                   fine
            
             'this'   Func      VFunc
             -------------------------
             struct   fine      fine
             class    fine      error
            
             It was previously impossible to create an open instance delegate
             to either virtual methods, or to generic interface methods. Func.Create handles both cases by automatically generating
             a small dispatch thunk which wraps the invocation for you, and returns a delegate of the appropriate type.
             
             The example above uses reflection to access the method metadata, but Sasa does provide a type-safe way to obtain the
             <see cref="T:System.Reflection.MethodInfo"/> without reflection via <see cref="T:Sasa.Types"/>.
             </remarks>
        </member>
        <member name="M:Sasa.Func.Combine``1(``0,``0)">
            <summary>
            Combine delegates into a single delegate.
            </summary>
            <typeparam name="T">The type of the delegate.</typeparam>
            <param name="first">The first delegate.</param>
            <param name="second">The second delegate.</param>
            <returns>The combined delegate.</returns>
            <remarks>
            Func.Combine is a type-safe wrapper around <see cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)"/>. Usage:
            <code>
            Action&lt;int&gt; delegate1 = i =&gt; Console.WriteLine("i = {0}", i);
            Action&lt;int&gt; delegate2 = i =&gt; Console.WriteLine("i*2 = {0}", i * 2");
            Action&lt;int&gt; combined = Func.Combine(delegate1, delegate2);
            // invoking combined(3) prints out:
            // i = 3
            // i*2 = 6
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Remove``1(``0,``0)">
            <summary>
            Combine delegates into a single delegate.
            </summary>
            <typeparam name="T">The type of the delegate.</typeparam>
            <param name="first">The first delegate.</param>
            <param name="second">The second delegate.</param>
            <returns>The combined delegate.</returns>
            <remarks>
            This is a type-safe wrapper for <see cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)"/>. Usage:
            <code>
            Action&lt;int&gt; delegate1 = i =&gt; Console.WriteLine("i = {0}", i);
            Action&lt;int&gt; delegate2 = i => Console.WriteLine("i*2 = {0}", i * 2");
            Action&lt;int&gt; combined = Func.Remove(Func.Combine(delegate1, delegate2), delegate2);
            // invoking combined(3) prints out:
            // i = 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Combine``1(``0[])">
            <summary>
            Combine delegates into a single delegate.
            </summary>
            <typeparam name="T">The type of the delegate.</typeparam>
            <param name="delegates">The list of delegates.</param>
            <returns>The combined delegate.</returns>
            <remarks>
            Func.Combine is a type-safe wrapper around <see cref="M:System.Delegate.Combine(System.Delegate[])"/>. Usage:
            <code>
            Action&lt;int&gt; delegate1 = i =&gt; Console.WriteLine("i = {0}", i);
            Action&lt;int&gt; delegate2 = i =&gt; Console.WriteLine("i*2 = {0}", i * 2");
            Action&lt;int&gt; combined = Func.Combine(delegate1, delegate2);
            // invoking combined(3) prints out:
            // i = 3
            // i*2 = 6
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Constant``2(``1)">
            <summary>
            Constructs a function that simply returns a constant value.
            </summary>
            <typeparam name="TInput">The type of input value.</typeparam>
            <typeparam name="TConst">The type of return value.</typeparam>
            <param name="value">The value to return.</param>
            <returns>Simply returns <paramref name="value"/>.</returns>
            <remarks>
            Use this method whenever you need a delegate that always returns a constant value, regardless of
            the parameter passed in. Usage:
            <code>
            int[] numbers = new int[] { 0, 1, 2, 3 };
            var sameNumber = Func.Constant&lt;int, int&gt;(99);
            
            foreach (var x in numbers.Select(sameNumber))
            {
                Console.Write(" {0},", x);
            }
            // prints out
            // 99, 99, 99, 99,
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.AsFunc(System.Action)">
            <summary>
            Wraps an action that returns void into a function that returns Empty.
            </summary>
            <param name="func">The delegate to wrap.</param>
            <returns>A new delegate that returns Empty on invocation.</returns>
            <remarks>
            One somewhat frustrating limitation of the CLR is that <see cref="T:System.Void"/> is not considered a value,
            and so cannot be used as a type parameter that is used in return position. So for instance, you can't create
            a Func&lt;void&gt;. This relegates void to second-class status, where all other types produce values as
            first-class citizens.
            
            This effectively divides the logical space of function types into those that return void
            (<see cref="T:System.Action"/>), and those that return a value (<see cref="T:System.Func`1"/>), and you cannot
            mix the two. Every operation that abstracts over the return type must then be written twice: once for
            functions that return a value, and again for functions that return void.
            
            Func.AsFunc provides a wrapper around the various System.Action delegates, effectively transforming them
            into the corresponding System.Func instance with a return value of
            <see cref="T:Sasa.Empty"/>.
            
            Func.AsFunc is also an extension method on the System.Action overloads, to make this wrapping as concise as possible. Usage:
            <code>
            Action&lt;int&gt; delegate1 = i =&gt; Console.WriteLine("i = {0}", i);
            Func&lt;int, Empty&gt; delegate2 = delegate1.AsFunc();
            // invoking delegate2(3) prints out:
            // i = 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.AsFunc``1(System.Action{``0})">
            <summary>
            Wraps an action that returns void into a function that returns Empty.
            </summary>
            <param name="func">The delegate to wrap.</param>
            <returns>A new delegate that returns Empty on invocation.</returns>
            <remarks>
            One somewhat frustrating limitation of the CLR is that <see cref="T:System.Void"/> is not considered a value,
            and so cannot be used as a type parameter that is used in return position. So for instance, you can't create
            a Func&lt;void&gt;. This relegates void to second-class status, where all other types produce values as
            first-class citizens.
            
            This effectively divides the logical space of function types into those that return void
            (<see cref="T:System.Action"/>), and those that return a value (<see cref="T:System.Func`1"/>), and you cannot
            mix the two. Every operation that abstracts over the return type must then be written twice: once for
            functions that return a value, and again for functions that return void.
            
            Func.AsFunc provides a wrapper around the various System.Action delegates, effectively transforming them
            into the corresponding System.Func instance with a return value of
            <see cref="T:Sasa.Empty"/>.
            
            Func.AsFunc is also an extension method on the System.Action overloads, to make this wrapping as concise as possible. Usage:
            <code>
            Action&lt;int&gt; delegate1 = i =&gt; Console.WriteLine("i = {0}", i);
            Func&lt;int, Empty&gt; delegate2 = delegate1.AsFunc();
            // invoking delegate2(3) prints out:
            // i = 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.AsFunc``2(System.Action{``0,``1})">
            <summary>
            Wraps an action that returns void into a function that returns Empty.
            </summary>
            <param name="func">The delegate to wrap.</param>
            <returns>A new delegate that returns Empty on invocation.</returns>
            <remarks>
            One somewhat frustrating limitation of the CLR is that <see cref="T:System.Void"/> is not considered a value,
            and so cannot be used as a type parameter that is used in return position. So for instance, you can't create
            a Func&lt;void&gt;. This relegates void to second-class status, where all other types produce values as
            first-class citizens.
            
            This effectively divides the logical space of function types into those that return void
            (<see cref="T:System.Action"/>), and those that return a value (<see cref="T:System.Func`1"/>), and you cannot
            mix the two. Every operation that abstracts over the return type must then be written twice: once for
            functions that return a value, and again for functions that return void.
            
            Func.AsFunc provides a wrapper around the various System.Action delegates, effectively transforming them
            into the corresponding System.Func instance with a return value of
            <see cref="T:Sasa.Empty"/>.
            
            Func.AsFunc is also an extension method on the System.Action overloads, to make this wrapping as concise as possible. Usage:
            <code>
            Action&lt;int&gt; delegate1 = i =&gt; Console.WriteLine("i = {0}", i);
            Func&lt;int, Empty&gt; delegate2 = delegate1.AsFunc();
            // invoking delegate2(3) prints out:
            // i = 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.AsFunc``3(System.Action{``0,``1,``2})">
            <summary>
            Wraps an action that returns void into a function that returns Empty.
            </summary>
            <param name="func">The delegate to wrap.</param>
            <returns>A new delegate that returns Empty on invocation.</returns>
            <remarks>
            One somewhat frustrating limitation of the CLR is that <see cref="T:System.Void"/> is not considered a value,
            and so cannot be used as a type parameter that is used in return position. So for instance, you can't create
            a Func&lt;void&gt;. This relegates void to second-class status, where all other types produce values as
            first-class citizens.
            
            This effectively divides the logical space of function types into those that return void
            (<see cref="T:System.Action"/>), and those that return a value (<see cref="T:System.Func`1"/>), and you cannot
            mix the two. Every operation that abstracts over the return type must then be written twice: once for
            functions that return a value, and again for functions that return void.
            
            Func.AsFunc provides a wrapper around the various System.Action delegates, effectively transforming them
            into the corresponding System.Func instance with a return value of
            <see cref="T:Sasa.Empty"/>.
            
            Func.AsFunc is also an extension method on the System.Action overloads, to make this wrapping as concise as possible. Usage:
            <code>
            Action&lt;int&gt; delegate1 = i =&gt; Console.WriteLine("i = {0}", i);
            Func&lt;int, Empty&gt; delegate2 = delegate1.AsFunc();
            // invoking delegate2(3) prints out:
            // i = 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.AsFunc``4(System.Action{``0,``1,``2,``3})">
            <summary>
            Wraps an action that returns void into a function that returns Empty.
            </summary>
            <param name="func">The delegate to wrap.</param>
            <returns>A new delegate that returns Empty on invocation.</returns>
            <remarks>
            One somewhat frustrating limitation of the CLR is that <see cref="T:System.Void"/> is not considered a value,
            and so cannot be used as a type parameter that is used in return position. So for instance, you can't create
            a Func&lt;void&gt;. This relegates void to second-class status, where all other types produce values as
            first-class citizens.
            
            This effectively divides the logical space of function types into those that return void
            (<see cref="T:System.Action"/>), and those that return a value (<see cref="T:System.Func`1"/>), and you cannot
            mix the two. Every operation that abstracts over the return type must then be written twice: once for
            functions that return a value, and again for functions that return void.
            
            Func.AsFunc provides a wrapper around the various System.Action delegates, effectively transforming them
            into the corresponding System.Func instance with a return value of
            <see cref="T:Sasa.Empty"/>.
            
            Func.AsFunc is also an extension method on the System.Action overloads, to make this wrapping as concise as possible. Usage:
            <code>
            Action&lt;int&gt; delegate1 = i =&gt; Console.WriteLine("i = {0}", i);
            Func&lt;int, Empty&gt; delegate2 = delegate1.AsFunc();
            // invoking delegate2(3) prints out:
            // i = 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Coerce``1(System.Delegate)">
            <summary>
            Coerces one delegate type to another.
            </summary>
            <typeparam name="TFunc">The return delegate type</typeparam>
            <param name="func">The source delegate to coerce.</param>
            <returns>A new delegate of the expected type.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if argument is null.</exception>
            <remarks>
            The type language for delegates is somewhat limited compared to the type language for interfaces
            and classes. For instance, interface methods support first-class polymorphism, where delegates
            do not. Combined with the fact that delegates are nominal types in their own right, this causes
            a proliferation of delegate types that are identical in type signature, but differ in nominal type and
            so cannot be substituted for each other. For instance, <see cref="T:System.Predicate`1"/> is equivalent
            to System.Func&gt;T, bool&gt;, but you cannot use a delegate of one type in a place where
            the other delegate type is expected.
            
            This extension method allows you to coerce one delegate type into another equivalent type. Usage:
            <code>
            Predicate&lt;int&gt; isthreep = x =&gt; x == 3;
            Func&lt;int, bool&gt; isthreef = isthreep.Coerce&lt;Func&lt;int, bool&gt;&gt;();
            Console.WriteLine("{0}, {1}", isthreep(3), isthreef(3));
            Console.WriteLine("{0}, {1}", isthreep(4), isthreef(4));
            // prints:
            // true, true
            // false, false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Generate(System.Type,System.Type,System.String,System.Reflection.MethodAttributes,System.Boolean,System.Action{System.Reflection.Emit.ILGenerator})">
            <summary>
            Create a dynamic method.
            </summary>
            <param name="delegateType">The delegate type to create.</param>
            <param name="type">The type to which this delegate should be a member.</param>
            <param name="methodName">The name of the delegate's method.</param>
            <param name="attributes">The method attributes.</param>
            <param name="saveAssembly">Flag indicating whether the generated code should be saved to a dll.</param>
            <param name="generator">A call back that performs the code generation.</param>
            <returns>An dynamically created instance of the given delegate type.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if argument is null.</exception>
            <remarks>
            This method is the real workhorse behind the scenes. It eliminate all the boilerplate in generating
            and debugging a <see cref="T:System.Reflection.Emit.DynamicMethod"/>, and is statically typed in the delegate type to
            generate. The most useful overloads by far are the ones that accept a boolean "saveAssembly"
            parameter. If saveAssembly:true is passed in, then the method is generated in a newly created
            assembly that is written to disk. You can then run peverify on it to check for any verification
            errors in your dynamically generated code. A single change to this variable can switch between
            debugging and production modes.
            
            This method is used throughout Sasa, even in <see cref="T:Sasa.Func"/> to create the thunks to
            dispatch open instance delegates for virtual methods and generic interface methods. Usage:
            <code>
            Func&lt;int, int&gt; addone = Func.Generate&lt;Func&lt;int, int&gt;&gt;(
                                     type: typeof(int),
                                     methodName: typeof(int).Name + "_addone",
                                     generator: il =>
            {
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldc_I4_1);
                il.Emit(OpCodes.Add);
                il.Emit(OpCodes.Ret);
            });
            Console.WriteLine("{0}, {1}, {2}", addone(0), addone(9), addone(998));
            // prints
            // 1, 10, 999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Generate``1(System.Type,System.String,System.Reflection.MethodAttributes,System.Boolean,System.Action{System.Reflection.Emit.ILGenerator})">
            <summary>
            Create a dynamic method.
            </summary>
            <typeparam name="T">The type of the dynamic method to create.</typeparam>
            <param name="type">The type to which this delegate should be a member.</param>
            <param name="methodName">The name of the delegate's method.</param>
            <param name="attributes">The method attributes.</param>
            <param name="saveAssembly">Flag indicating whether the generated code should be saved to a dll.</param>
            <param name="generator">A call back that performs the code generation.</param>
            <returns>An dynamically created instance of the given delegate type.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if argument is null.</exception>
            <remarks>
            This method is the real workhorse behind the scenes. It eliminate all the boilerplate in generating
            and debugging a <see cref="T:System.Reflection.Emit.DynamicMethod"/>, and is statically typed in the delegate type to
            generate. The most useful overloads by far are the ones that accept a boolean "saveAssembly"
            parameter. If saveAssembly:true is passed in, then the method is generated in a newly created
            assembly that is written to disk. You can then run peverify on it to check for any verification
            errors in your dynamically generated code. A single change to this variable can switch between
            debugging and production modes.
            
            This method is used throughout Sasa, even in <see cref="T:Sasa.Func"/> to create the thunks to
            dispatch open instance delegates for virtual methods and generic interface methods. Usage:
            <code>
            Func&lt;int, int&gt; addone = Func.Generate&lt;Func&lt;int, int&gt;&gt;(
                                     type: typeof(int),
                                     methodName: typeof(int).Name + "_addone",
                                     generator: il =>
            {
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldc_I4_1);
                il.Emit(OpCodes.Add);
                il.Emit(OpCodes.Ret);
            });
            Console.WriteLine("{0}, {1}, {2}", addone(0), addone(9), addone(998));
            // prints
            // 1, 10, 999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Generate``1(System.Type,System.String,System.Action{System.Reflection.Emit.ILGenerator})">
            <summary>
            Create a dynamic method.
            </summary>
            <typeparam name="T">The type of the dynamic method to create.</typeparam>
            <param name="type">The type to which this delegate should be a member.</param>
            <param name="methodName">The name of the delegate's method.</param>
            <param name="generator">A call back that performs the code generation.</param>
            <returns>An dynamically created instance of the given delegate type.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if argument is null.</exception>
            <remarks>
            This method is the real workhorse behind the scenes. It eliminate all the boilerplate in generating
            and debugging a <see cref="T:System.Reflection.Emit.DynamicMethod"/>, and is statically typed in the delegate type to
            generate. The most useful overloads by far are the ones that accept a boolean "saveAssembly"
            parameter. If saveAssembly:true is passed in, then the method is generated in a newly created
            assembly that is written to disk. You can then run peverify on it to check for any verification
            errors in your dynamically generated code. A single change to this variable can switch between
            debugging and production modes.
            
            This method is used throughout Sasa, even in <see cref="T:Sasa.Func"/> to create the thunks to
            dispatch open instance delegates for virtual methods and generic interface methods. Usage:
            <code>
            Func&lt;int, int&gt; addone = Func.Generate&lt;Func&lt;int, int&gt;&gt;(
                                     type: typeof(int),
                                     methodName: typeof(int).Name + "_addone",
                                     generator: il =>
            {
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldc_I4_1);
                il.Emit(OpCodes.Add);
                il.Emit(OpCodes.Ret);
            });
            Console.WriteLine("{0}, {1}, {2}", addone(0), addone(9), addone(998));
            // prints
            // 1, 10, 999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Generate``1(System.Type,System.String,System.Boolean,System.Action{System.Reflection.Emit.ILGenerator})">
            <summary>
            Create a dynamic method.
            </summary>
            <typeparam name="T">The type of the dynamic method to create.</typeparam>
            <param name="type">The type to which this delegate should be a member.</param>
            <param name="methodName">The name of the delegate's method.</param>
            <param name="saveAssembly">Flag indicating whether the generated code should be saved to a dll.</param>
            <param name="generator">A call back that performs the code generation.</param>
            <returns>An dynamically created instance of the given delegate type.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if argument is null.</exception>
            <remarks>
            This method is the real workhorse behind the scenes. It eliminate all the boilerplate in generating
            and debugging a <see cref="T:System.Reflection.Emit.DynamicMethod"/>, and is statically typed in the delegate type to
            generate. The most useful overloads by far are the ones that accept a boolean "saveAssembly"
            parameter. If saveAssembly:true is passed in, then the method is generated in a newly created
            assembly that is written to disk. You can then run peverify on it to check for any verification
            errors in your dynamically generated code. A single change to this variable can switch between
            debugging and production modes.
            
            This method is used throughout Sasa, even in <see cref="T:Sasa.Func"/> to create the thunks to
            dispatch open instance delegates for virtual methods and generic interface methods. Usage:
            <code>
            Func&lt;int, int&gt; addone = Func.Generate&lt;Func&lt;int, int&gt;&gt;(
                                     type: typeof(int),
                                     methodName: typeof(int).Name + "_addone",
                                     generator: il =>
            {
                il.Emit(OpCodes.Ldarg_0);
                il.Emit(OpCodes.Ldc_I4_1);
                il.Emit(OpCodes.Add);
                il.Emit(OpCodes.Ret);
            });
            Console.WriteLine("{0}, {1}, {2}", addone(0), addone(9), addone(998));
            // prints
            // 1, 10, 999
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Func.Invoke``1(System.Reflection.MethodBase,System.Object,System.Object[])">
            <summary>
            Dynamically invoke a <see cref="T:System.Reflection.MethodInfo" />, specifying the expected return type.
            </summary>
            <typeparam name="T">The expected return type.</typeparam>
            <param name="method">The method to invoke.</param>
            <param name="self">The object reference for the method, null if it's a static method.</param>
            <param name="args">The method arguments.</param>
            <returns>An object of type <typeparamref name="T"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Throw if argument is null.</exception>
            <remarks>
            This is a simple typed raw method invocation, ie. a typed equivalent of <see cref="M:System.Delegate.DynamicInvoke(System.Object[])" />.
            It's defined as an extension method on MethodInfo for clarity. Usage:
            <code>
            // SomeMethod is of type (string,float) -&gt; int
            MethodInfo someMethod = typeof(Foo).GetMethod("SomeMethod");
            var arg1 = 3.4F;
            var returnInt = someMethod.Invoke&lt;int&gt;("arg0", arg1);
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.IEither`1">
            <summary>
            A sum type holding a single case.
            </summary>
            <typeparam name="T0">The encapsulated type.</typeparam>
            <remarks>
            Tuples are a pretty common necessity while programming, and every programmer has run into the need
            to return multiple values from a method, as but one example. The algebraic description of a tuple is
            what's known as a "product", and the logical analogue is the "conjunction", ie. a product/tuple is
            type T0 AND T1 AND T2 AND ...
            
            Given any abstraction, it's dual will often also be necessary. Imagine programming only with the
            logical AND operator without OR! Analogously, we also need the algebraic analogue of products
            which are known as "sums", ie. type T0 OR T1 OR T2 OR ...:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            The need for this may not be so obvious to CLR programmers because inheritance provides a kind of sum.
            For instance, the above code snippet could be modelled with an explicit class hierarchy:
            <code>
            abstract class IntOrString
            {
                public static implicit operator IntOrString(int i)
                {
                    return new IntCase { value = i };
                }
                public static implicit operator IntOrString(string s)
                {
                    return new StringCase { value = s };
                }
            }
            sealed class IntCase : IntOrString
            {
                int value;
                public override string ToString() { return value.ToString(); }
            }
            sealed class StringCase : IntOrString
            {
                string value;
                public override string ToString() { return value; }
            }
            ...
            IntOrString foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            However, just like with tuples, when you're only dealing with a small number of possibilities you don't
            want to go through the hassle of creating a whole new set of types just to represent a few possibilities.
            
            Alternately, you can just use the implicit supertype of all CLR types, <see cref="T:System.Object" /> instead of
            creating a class hierarchy, but in a very real sense this is TOO permissive, since it allows more than just
            <see cref="T:System.Int32"/> and <see cref="T:System.String"/>:
            <code>
            object foo = new Action(() => throw new Exception("Fooled you!"));
            Console.WriteLine(foo);
            // output:
            // System.Action ...
            </code>
            <see cref="T:Sasa.Either`2"/>, <see cref="T:Sasa.Either`3"/> and <see cref="T:Sasa.Either`4"/>
            are generic sum types that provide this functionality for you, along with a few convenience operations
            to make programming with sums easier. For instance, ToString is overloaded to return the string representation
            of the underlying value, there are implicit conversions into the corresponding sum type, equality is structural
            over the various cases, and value extraction from sums is done via a simple pattern matching scheme:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IEither`1.TryFirst(`0@)">
            <summary>
            Extract the first case.
            </summary>
            <param name="value">The output reference.</param>
            <returns>True if encapsulated value is of type <typeparamref name="T0"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T0"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IEither`1.IsFirst">
            <summary>
            True if the encapsulated value is of type <typeparamref name="T0"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;(3);
            Console.WriteLine(x.IsFirst);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IEither`1.First">
            <summary>
            Access the first case value.
            </summary>
            <returns>An option indicating whether this sum is the first case.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T0"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo.First || 123);
            // output:
            // 123
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.IEither`2">
            <summary>
            A sum with two cases.
            </summary>
            <typeparam name="T0">The type of the first case.</typeparam>
            <typeparam name="T1">The type of the second case.</typeparam>
            <remarks>
            Tuples are a pretty common necessity while programming, and every programmer has run into the need
            to return multiple values from a method, as but one example. The algebraic description of a tuple is
            what's known as a "product", and the logical analogue is the "conjunction", ie. a product/tuple is
            type T0 AND T1 AND T2 AND ...
            
            Given any abstraction, it's dual will often also be necessary. Imagine programming only with the
            logical AND operator without OR! Analogously, we also need the algebraic analogue of products
            which are known as "sums", ie. type T0 OR T1 OR T2 OR ...:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            The need for this may not be so obvious to CLR programmers because inheritance provides a kind of sum.
            For instance, the above code snippet could be modelled with an explicit class hierarchy:
            <code>
            abstract class IntOrString
            {
                public static implicit operator IntOrString(int i)
                {
                    return new IntCase { value = i };
                }
                public static implicit operator IntOrString(string s)
                {
                    return new StringCase { value = s };
                }
            }
            sealed class IntCase : IntOrString
            {
                int value;
                public override string ToString() { return value.ToString(); }
            }
            sealed class StringCase : IntOrString
            {
                string value;
                public override string ToString() { return value; }
            }
            ...
            IntOrString foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            However, just like with tuples, when you're only dealing with a small number of possibilities you don't
            want to go through the hassle of creating a whole new set of types just to represent a few possibilities.
            
            Alternately, you can just use the implicit supertype of all CLR types, <see cref="T:System.Object" /> instead of
            creating a class hierarchy, but in a very real sense this is TOO permissive, since it allows more than just
            <see cref="T:System.Int32"/> and <see cref="T:System.String"/>:
            <code>
            object foo = new Action(() => throw new Exception("Fooled you!"));
            Console.WriteLine(foo);
            // output:
            // System.Action ...
            </code>
            <see cref="T:Sasa.Either`2"/>, <see cref="T:Sasa.Either`3"/> and <see cref="T:Sasa.Either`4"/>
            are generic sum types that provide this functionality for you, along with a few convenience operations
            to make programming with sums easier. For instance, ToString is overloaded to return the string representation
            of the underlying value, there are implicit conversions into the corresponding sum type, equality is structural
            over the various cases, and value extraction from sums is done via a simple pattern matching scheme:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IEither`2.TrySecond(`1@)">
            <summary>
            Extract the second case.
            </summary>
            <param name="value">The output reference.</param>
            <returns>True if encapsulated value is of type <typeparamref name="T1"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T1"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IEither`2.IsSecond">
            <summary>
            True if the encapsulated value is of type <typeparamref name="T1"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;("hello!");
            Console.WriteLine(x.IsFirst);
            Console.WriteLine(x.IsSecond);
            // output:
            // false
            // true
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IEither`2.Second">
            <summary>
            Access the second case value.
            </summary>
            <returns>An option indicating whether this sum is the second case.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string&gt; foo = 123;
            Console.WriteLine(foo.Second || "hello!");
            // output:
            // hello!
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.IEither`3">
            <summary>
            A sum with three cases.
            </summary>
            <typeparam name="T0">The type of the first case.</typeparam>
            <typeparam name="T1">The type of the second case.</typeparam>
            <typeparam name="T2">The type of the third case.</typeparam>
            <remarks>
            Tuples are a pretty common necessity while programming, and every programmer has run into the need
            to return multiple values from a method, as but one example. The algebraic description of a tuple is
            what's known as a "product", and the logical analogue is the "conjunction", ie. a product/tuple is
            type T0 AND T1 AND T2 AND ...
            
            Given any abstraction, it's dual will often also be necessary. Imagine programming only with the
            logical AND operator without OR! Analogously, we also need the algebraic analogue of products
            which are known as "sums", ie. type T0 OR T1 OR T2 OR ...:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            The need for this may not be so obvious to CLR programmers because inheritance provides a kind of sum.
            For instance, the above code snippet could be modelled with an explicit class hierarchy:
            <code>
            abstract class IntOrString
            {
                public static implicit operator IntOrString(int i)
                {
                    return new IntCase { value = i };
                }
                public static implicit operator IntOrString(string s)
                {
                    return new StringCase { value = s };
                }
            }
            sealed class IntCase : IntOrString
            {
                int value;
                public override string ToString() { return value.ToString(); }
            }
            sealed class StringCase : IntOrString
            {
                string value;
                public override string ToString() { return value; }
            }
            ...
            IntOrString foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            However, just like with tuples, when you're only dealing with a small number of possibilities you don't
            want to go through the hassle of creating a whole new set of types just to represent a few possibilities.
            
            Alternately, you can just use the implicit supertype of all CLR types, <see cref="T:System.Object" /> instead of
            creating a class hierarchy, but in a very real sense this is TOO permissive, since it allows more than just
            <see cref="T:System.Int32"/> and <see cref="T:System.String"/>:
            <code>
            object foo = new Action(() => throw new Exception("Fooled you!"));
            Console.WriteLine(foo);
            // output:
            // System.Action ...
            </code>
            <see cref="T:Sasa.Either`2"/>, <see cref="T:Sasa.Either`3"/> and <see cref="T:Sasa.Either`4"/>
            are generic sum types that provide this functionality for you, along with a few convenience operations
            to make programming with sums easier. For instance, ToString is overloaded to return the string representation
            of the underlying value, there are implicit conversions into the corresponding sum type, equality is structural
            over the various cases, and value extraction from sums is done via a simple pattern matching scheme:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IEither`3.TryThird(`2@)">
            <summary>
            Extract the third case.
            </summary>
            <param name="value">The output reference.</param>
            <returns>True if encapsulated value is of type <typeparamref name="T2"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T2"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IEither`3.IsThird">
            <summary>
            True if the encapsulated value is of type <typeparamref name="T2"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;(99.0M);
            Console.WriteLine(x.IsThird);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IEither`3.Third">
            <summary>
            Access the third case value.
            </summary>
            <returns>An option indicating whether this sum is the third case.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string, DateTime&gt; foo = DateTime.MinValue;
            Console.WriteLine(foo.Third || DateTime.MaxValue);
            // output:
            // DateTime.MinValue
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.IEither`4">
            <summary>
            A sum with four cases.
            </summary>
            <typeparam name="T0">The type of the first case.</typeparam>
            <typeparam name="T1">The type of the second case.</typeparam>
            <typeparam name="T2">The type of the third case.</typeparam>
            <typeparam name="T3">The type of the fourth case.</typeparam>
            <remarks>
            Tuples are a pretty common necessity while programming, and every programmer has run into the need
            to return multiple values from a method, as but one example. The algebraic description of a tuple is
            what's known as a "product", and the logical analogue is the "conjunction", ie. a product/tuple is
            type T0 AND T1 AND T2 AND ...
            
            Given any abstraction, it's dual will often also be necessary. Imagine programming only with the
            logical AND operator without OR! Analogously, we also need the algebraic analogue of products
            which are known as "sums", ie. type T0 OR T1 OR T2 OR ...:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            The need for this may not be so obvious to CLR programmers because inheritance provides a kind of sum.
            For instance, the above code snippet could be modelled with an explicit class hierarchy:
            <code>
            abstract class IntOrString
            {
                public static implicit operator IntOrString(int i)
                {
                    return new IntCase { value = i };
                }
                public static implicit operator IntOrString(string s)
                {
                    return new StringCase { value = s };
                }
            }
            sealed class IntCase : IntOrString
            {
                int value;
                public override string ToString() { return value.ToString(); }
            }
            sealed class StringCase : IntOrString
            {
                string value;
                public override string ToString() { return value; }
            }
            ...
            IntOrString foo = "hello world!";
            Console.WriteLine(foo);
            // output:
            // hello world!
            </code>
            However, just like with tuples, when you're only dealing with a small number of possibilities you don't
            want to go through the hassle of creating a whole new set of types just to represent a few possibilities.
            
            Alternately, you can just use the implicit supertype of all CLR types, <see cref="T:System.Object" /> instead of
            creating a class hierarchy, but in a very real sense this is TOO permissive, since it allows more than just
            <see cref="T:System.Int32"/> and <see cref="T:System.String"/>:
            <code>
            object foo = new Action(() => throw new Exception("Fooled you!"));
            Console.WriteLine(foo);
            // output:
            // System.Action ...
            </code>
            <see cref="T:Sasa.Either`2"/>, <see cref="T:Sasa.Either`3"/> and <see cref="T:Sasa.Either`4"/>
            are generic sum types that provide this functionality for you, along with a few convenience operations
            to make programming with sums easier. For instance, ToString is overloaded to return the string representation
            of the underlying value, there are implicit conversions into the corresponding sum type, equality is structural
            over the various cases, and value extraction from sums is done via a simple pattern matching scheme:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IEither`4.TryFourth(`3@)">
            <summary>
            Extract the third case.
            </summary>
            <param name="value">The output reference.</param>
            <returns>True if encapsulated value is of type <typeparamref name="T3"/>.</returns>
            <remarks>
            This method extracts the encapsulated value if the sum is of type <typeparamref name="T3"/>:
            <code>
            Either&lt;int, string&gt; foo = "hello world!";
            int icase;
            if (foo.TryFirst(out icase))
            {
                Console.WriteLine("int: " + icase);
                return;
            }
            string scase;
            if (foo.TrySecond(out scase))
            {
                Console.WriteLine("string: " + scase);
                return;
            }
            // output:
            // string: hello world!
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IEither`4.IsFourth">
            <summary>
            True if the encapsulated value is of type <typeparamref name="T3"/>.
            </summary>
            <remarks>
            This checks whether the sum is the first case of type <typeparamref name="T0"/>:
            <code>
            var x = Either.First&lt;int, string, decimal, DateTime&gt;(DateTime.Today);
            Console.WriteLine(x.IsFourth);
            Console.WriteLine(x.IsSecond);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IEither`4.Fourth">
            <summary>
            Access the fourth case value.
            </summary>
            <returns>An option indicating whether this sum is the fourth case.</returns>
            <remarks>
            This property attempts to extract the encapsulated value of type <typeparamref name="T1"/>. An
            <see cref="T:Sasa.Option`1"/> is returned indicating success or failure, which means you can use
            all the usual coalescing operators on options with the results:
            <code>
            Either&lt;int, string, DateTime, decimal&gt; foo = "foo";
            Console.WriteLine(foo.Fourth || 99M);
            // output:
            // 99M
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.ICovariant`1">
            <summary>
            A covariant zero-arg operation.
            </summary>
            <typeparam name="TReturn">The return type.</typeparam>
        </member>
        <member name="M:Sasa.ICovariant`1.Apply">
            <summary>
            Apply the operation.
            </summary>
            <returns>The return value of the operation.</returns>
        </member>
        <member name="T:Sasa.ICovariant`2">
            <summary>
            A covariant single-arg operation.
            </summary>
            <typeparam name="TArg0">The base argument type.</typeparam>
            <typeparam name="TReturn">The return type.</typeparam>
        </member>
        <member name="M:Sasa.ICovariant`2.Apply``1(``0)">
            <summary>
            Apply the operation.
            </summary>
            <typeparam name="T0">The covariant argument type.</typeparam>
            <param name="arg0">The operation argument.</param>
            <returns>The return value of the operation.</returns>
        </member>
        <member name="T:Sasa.ICovariant`3">
            <summary>
            A covariant two-arg operation.
            </summary>
            <typeparam name="TArg0">The base type for the first argument.</typeparam>
            <typeparam name="TArg1">The base type for the second argument.</typeparam>
            <typeparam name="TReturn">The return type.</typeparam>
        </member>
        <member name="M:Sasa.ICovariant`3.Apply``2(``0,``1)">
            <summary>
            Apply the operation.
            </summary>
            <typeparam name="T0">The covariant type of the first argument.</typeparam>
            <typeparam name="T1">The covariant type of the seconf argument.</typeparam>
            <param name="arg0">The operation's first argument.</param>
            <param name="arg1">The operaton's second argument.</param>
            <returns>The return value of the operation.</returns>
        </member>
        <member name="T:Sasa.IContravariant`1">
            <summary>
            A contravariant operation.
            </summary>
            <typeparam name="TReturn">The base type of the return value.</typeparam>
        </member>
        <member name="M:Sasa.IContravariant`1.Apply``1">
            <summary>
            Apply the operation.
            </summary>
            <typeparam name="T">The type of the return value.</typeparam>
            <returns>The return value.</returns>
        </member>
        <member name="T:Sasa.IContravariant`2">
            <summary>
            A contravariant operation.
            </summary>
            <typeparam name="TArg0">The base type of the first argument.</typeparam>
            <typeparam name="TReturn">The base type of the return value.</typeparam>
        </member>
        <member name="M:Sasa.IContravariant`2.Apply``2(``0)">
            <summary>
            Apply the operation.
            </summary>
            <typeparam name="T0">The type of the first argument.</typeparam>
            <typeparam name="T1">The type of the return value.</typeparam>
            <param name="arg0">The first argument.</param>
            <returns>The return value.</returns>
        </member>
        <member name="T:Sasa.IContravariant`3">
            <summary>
            A contravariant operation.
            </summary>
            <typeparam name="TArg0">The base type of the first argument.</typeparam>
            <typeparam name="TArg1">The base type of the second argument.</typeparam>
            <typeparam name="TReturn">The base type of the return value.</typeparam>
        </member>
        <member name="M:Sasa.IContravariant`3.Apply``3(``0,``1)">
            <summary>
            Apply the operation.
            </summary>
            <typeparam name="T0">The type of the first argument.</typeparam>
            <typeparam name="T1">The type of the second argument.</typeparam>
            <typeparam name="T2">The type of the return value.</typeparam>
            <param name="arg0">The first argument.</param>
            <param name="arg1">The second argument.</param>
            <returns>The return value.</returns>
        </member>
        <member name="T:Sasa.IO.DisposableFile">
            <summary>
            Disposable file.
            </summary>
            <remarks>
            This is a simple object intended to automate the handling of temporary files. Like most
            <see cref="T:System.IDisposable"/> objects, a <see cref="T:Sasa.IO.DisposableFile"/> is intended to be
            used within a "using" block, and the file it references is deleted upon exiting the block.
            <code>
            using (var tmp = new DisposableFile(true, "foo.txt"))
            {
                File.WriteAllText(tmp.Path, "hello world!");
                Console.WriteLine(File.ReadAllText(tmp.Path));
            }
            Console.WriteLine(File.Exists("foo.txt"));
            
            // output:
            // hello world!
            // false
            </code>
            Any <see cref="T:System.IO.FileNotFoundException"/>'s thrown on dispose are ignored, so
            you can safely move the file within the block.
            </remarks>
        </member>
        <member name="M:Sasa.IO.DisposableFile.#ctor(System.Boolean,Sasa.IO.FilePath)">
            <summary>
            Construct a new disposable file object.
            </summary>
            <param name="createIfNotExists">Boolean indicating whether to create the file if it doesn't already exist.</param>
            <param name="path">The path to dispose of.</param>
            <remarks>
            This constructor creates a temporary file:
            <code>
            using (var tmp = new DisposableFile(createIfNotExists: true, path: "foo.txt"))
            {
                ...
            }
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IO.DisposableFile.Path">
            <summary>
            The underlying file path.
            </summary>
            <remarks>
            This property exposes the path to the disposable file:
            <code>
            using (var tmp = new DisposableFile(createIfNotExists: true, path: "foo.txt"))
            {
                Console.WriteLine(tmp.Path);
            }
            // output:
            // foo.txt
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.DisposableFile.CreateTemporary">
            <summary>
            Construct a temporary, disposable file.
            </summary>
            <returns>A disposable file handle.</returns>
            <remarks>
            This static method invokes <see cref="M:System.IO.Path.GetTempFileName"/>
            and returns a <see cref="T:Sasa.IO.DisposableFile"/> instance encapsulating the
            created file:
            <code>
            using (var tmp = DisposableFile.CreateTemporary())
            {
                File.WriteAllText(tmp.Path, "hello world!");
            }
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.DisposableFile.Dispose">
            <summary>
            Dispose of the file.
            </summary>
        </member>
        <member name="M:Sasa.IO.DisposableFile.Equals(Sasa.IO.DisposableFile)">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="other">The object to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.IO.DisposableFile.Equals(System.Object)">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.IO.DisposableFile.GetHashCode">
            <summary>
            Computes the hash code for the object.
            </summary>
            <returns>The integer hash code.</returns>
        </member>
        <member name="M:Sasa.IO.DisposableFile.op_Equality(Sasa.IO.DisposableFile,Sasa.IO.DisposableFile)">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="left">The left object to compare.</param>
            <param name="right">The right object to compare.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.IO.DisposableFile.op_Inequality(Sasa.IO.DisposableFile,Sasa.IO.DisposableFile)">
            <summary>
            Compares struct for inequality.
            </summary>
            <param name="left">The left object to compare.</param>
            <param name="right">The right object to compare.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="T:Sasa.IO.FilePath">
            <summary>
            A structured file system path.
            </summary>
            <remarks>
            One persistent difficulty in dealing with IO in .NET is path handling. .NET exposes a platform's directory
            separator characters, but really this sort of thing should be automated. Furthermore, paths are considered
            simple strings and so concatenating fragments could leave you with a path string that goes up and down
            directories with no clear final result, ie. resolving the final path string is left to the OS.
            
            This means that you can't easily reason about the constructed paths without consulting the OS, which is a
            relatively expensive operation. Furthermore, <see cref="M:System.IO.Path.Combine(System.String,System.String)"/> has a number of corner
            cases that make constructing paths non-compositional, requiring numerous argument validations to ensure
            a correct result.
            
            Enter <see cref="T:Sasa.IO.FilePath" />. It's a simple struct that encapsulates an underlying path string,
            so FilePath operations are just as efficient as your current path handling. FilePath fully resolves
            directory change operations where possible, so the final path string designates the path the OS will
            actually look up. Null or empty strings are considered references to the current directory, ie. ".". There
            is also a "jail" operation which ensures that a provided path cannot escape a particularly sub-directory,
            just like the OS-level chroot jail.
            
            This module ensures that all paths containing "." and ".." are rewritten to equivalent forms without
            directory change operations, where possible.
            
            In some cases, this is not possible, such as when ".." precedes the rest of the path, ie. ../foo. In such
            cases, the directory change operations are retained, under the assumption that a future path combination
            will permit full resolution.
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.#ctor(System.String)">
            <summary>
            Construct a structured file system path.
            </summary>
            <param name="path">The root path.</param>
            <remarks>
            This constructor takes an arbitrary path string, resolves all the inner directory change operations, and
            returns a final path:
            <code>
            var foo = "foo/../..";
            var path1 = new FilePath(foo);
            var path2 = new FilePath("bar/" + foo);
            Console.WriteLine(path1);
            Console.WriteLine(path2);
            Console.WriteLine("root" / path2); // FilePath composition using /
            // output:
            // ..
            // .
            // root
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.IO.FilePath.Path">
            <summary>
            The underlying path.
            </summary>
        </member>
        <member name="M:Sasa.IO.FilePath.Resolve(System.String)">
            <summary>
            Resolves all relative changes in a path.
            </summary>
            <param name="path">The path to resolve.</param>
            <returns>A resolved path string.</returns>
            <remarks>
            The real workhorse behind FilePath, this method resolves all path change operations in a string and
            returns a simplified path string. In case you want to stick with raw string paths, you can use this
            method to perform path simplification:
            <code>
            var path1 = "foo/../..";
            var path2 = "bar/" + path1;
            Console.WriteLine(FilePath.Resolve(path1));
            Console.WriteLine(FilePath.Resolve(path2));
            Console.WriteLine(FilePath.Resolve("root/" + path2));
            // output:
            // ..
            // 
            // root
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.Parse(System.Text.StringBuilder,System.Int32,System.String,System.Int32)">
            <summary>
            Traverse the path string in reverse order, skipping fragments due to
            encountered .. fragments along the way.
            </summary>
            <param name="norm">The resolved path string.</param>
            <param name="skip">The number of fragments to skip.</param>
            <param name="path">The path string.</param>
            <param name="end">The current end of the fragment.</param>
        </member>
        <member name="M:Sasa.IO.FilePath.Combine(Sasa.IO.FilePath)">
            <summary>
            Construct a combined path from two paths.
            </summary>
            <param name="file">The path to combine with this one.</param>
            <returns>The combined path.</returns>
            <remarks>
            This method exposes the same semantics as <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>, but on FilePath instances:
            <code>
            var foo = new FilePath("foo/../..");
            var bar = new FilePath("/bar");
            Console.WriteLine(FilePath.Combine(foo, bar));
            Console.WriteLine(FilePath.Combine(bar, foo));
            // output:
            // ..\bar
            // .
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.GetEnumerator">
            <summary>
            Returns an enumerator over the file path components.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.Jail(Sasa.IO.FilePath,Sasa.IO.FilePath)">
            <summary>
            Ensure <paramref name="path"/> cannot escape the <paramref name="root" /> directory.
            </summary>
            <param name="root">The root path.</param>
            <param name="path">The path under <paramref name="root"/>.</param>
            <returns>A full path under <paramref name="root"/>.</returns>
            <remarks>
            The Jail methods provide a chroot-jail operation on file paths, to ensure a provided path
            string cannot escape a certain sub-directory:
            <code>
            var escape = new FilePath("../..");
            var bar = new FilePath("/bar");
            Console.WriteLine(FilePath.Jail(bar, escape));
            // output:
            // bar
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.Jail(Sasa.IO.FilePath)">
            <summary>
            Ensure <paramref name="path"/> cannot escape the current directory.
            </summary>
            <param name="path">The path under the current directory.</param>
            <returns>A full path under current directory.</returns>
            <remarks>
            The Jail methods provide a chroot-jail operation on file paths, to ensure a provided path
            string cannot escape a certain sub-directory:
            <code>
            var escape = new FilePath("../..");
            var bar = new FilePath("/bar");
            Console.WriteLine(bar.Jail(escape));
            // output:
            // bar
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.Equals(Sasa.IO.FilePath)">
            <summary>
            Compare two paths for equality.
            </summary>
            <param name="other">The path to compare to.</param>
            <returns>True if the paths are equal.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.Equals(System.Object)">
            <summary>
            Compare two paths for equality.
            </summary>
            <param name="obj">The path to compare to.</param>
            <returns>True if the paths are equal.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.GetHashCode">
            <summary>
            Compute hash code of path.
            </summary>
            <returns>Hash code for path.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.CompareTo(Sasa.IO.FilePath)">
            <summary>
            Order two paths.
            </summary>
            <param name="other">Other path to compare against.</param>
            <returns>Returns zero if equal, less than zero if this path
            is less than <paramref name="other"/>, else returns greater than
            zero.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.IsParentOf(Sasa.IO.FilePath)">
            <summary>
            Checks whether <paramref name="other"/> is a child of this path.
            </summary>
            <param name="other">The path to check.</param>
            <returns>True if <paramref name="other"/> is a child of this path.</returns>
            <remarks>
            This method compares two paths to see if one is a subset of the other:
            <code>
            var foobar = new FilePath("foo/bar");
            var bar = new FilePath("bar");
            var foo = new FilePath("foo");
            Console.WriteLine(bar.IsParentOf(foobar));
            Console.WriteLine(foo.IsParentOf(foobar));
            Console.WriteLine(foobar.IsParentOf(foo));
            // output:
            // false
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.ToString">
            <summary>
            Return a string representation of the path.
            </summary>
            <returns>A string representation of the path.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.ToString(System.Char)">
            <summary>
            Return a string representation of the path.
            </summary>
            <param name="directorySeparator">The character to use to separate directory components of a path.</param>
            <returns>A string representation of the path.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Division(Sasa.IO.FilePath,System.String)">
            <summary>
            Combine the given path and string component.
            </summary>
            <param name="path">A structured path.</param>
            <param name="part">An unstructured path string.</param>
            <returns>The combined structured path.</returns>
            <remarks>
            This operation provides a convenient shorthand for composing paths, and a shorthand for <see cref="M:Sasa.IO.FilePath.Combine(Sasa.IO.FilePath)"/>:
            <code>
            var foo = "foo/../..";
            var path1 = new FilePath(foo);
            var path2 = "bar" / path1;
            Console.WriteLine(path1);
            Console.WriteLine(path2);
            Console.WriteLine("root" / path2);
            // output:
            // ..
            // .
            // root
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Division(System.String,Sasa.IO.FilePath)">
            <summary>
            Combine the given path and string component.
            </summary>
            <param name="path">A structured path.</param>
            <param name="part">An unstructured path string.</param>
            <returns>The combined structured path.</returns>
            <remarks>
            This operation provides a convenient shorthand for composing paths, and a shorthand for <see cref="M:Sasa.IO.FilePath.Combine(Sasa.IO.FilePath)"/>:
            <code>
            var foo = "foo/../..";
            var path1 = new FilePath(foo);
            var path2 = "bar" / path1;
            Console.WriteLine(path1);
            Console.WriteLine(path2);
            Console.WriteLine("root" / path2);
            // output:
            // ..
            // .
            // root
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Division(Sasa.IO.FilePath,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Combine the given path and string components.
            </summary>
            <param name="path">The structured path.</param>
            <param name="parts">The components of a path.</param>
            <returns>A combined structured path.</returns>
            <remarks>
            This operation provides a convenient shorthand for composing paths, and a shorthand for <see cref="M:Sasa.IO.FilePath.Combine(Sasa.IO.FilePath)"/>:
            <code>
            var foo = "foo/../..";
            var path1 = new FilePath(foo);
            var path2 = "bar" / path1;
            Console.WriteLine(path1);
            Console.WriteLine(path2);
            Console.WriteLine("root" / path2);
            // output:
            // ..
            // .
            // root
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Division(System.Collections.Generic.IEnumerable{System.String},Sasa.IO.FilePath)">
            <summary>
            Combine the given path and string components.
            </summary>
            <param name="path">The structured path.</param>
            <param name="parts">The components of a path.</param>
            <returns>A combined structured path.</returns>
            <remarks>
            This operation provides a convenient shorthand for composing paths, and a shorthand for <see cref="M:Sasa.IO.FilePath.Combine(Sasa.IO.FilePath)"/>:
            <code>
            var foo = "foo/../..";
            var path1 = new FilePath(foo);
            var path2 = "bar" / path1;
            Console.WriteLine(path1);
            Console.WriteLine(path2);
            Console.WriteLine("root" / path2);
            // output:
            // ..
            // .
            // root
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Division(System.String[],Sasa.IO.FilePath)">
            <summary>
            Combine the given path and string components.
            </summary>
            <param name="path">The structured path.</param>
            <param name="parts">The components of a path.</param>
            <returns>A combined structured path.</returns>
            <remarks>
            This operation provides a convenient shorthand for composing paths, and a shorthand for <see cref="M:Sasa.IO.FilePath.Combine(Sasa.IO.FilePath)"/>:
            <code>
            var foo = "foo/../..";
            var path1 = new FilePath(foo);
            var path2 = "bar" / path1;
            Console.WriteLine(path1);
            Console.WriteLine(path2);
            Console.WriteLine("root" / path2);
            // output:
            // ..
            // .
            // root
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Division(Sasa.IO.FilePath,Sasa.IO.FilePath)">
            <summary>
            Combine the given path and string components.
            </summary>
            <param name="path1">The first structured path.</param>
            <param name="path2">The second structured path.</param>
            <returns>The combined structured path.</returns>
            <remarks>
            This operation provides a convenient shorthand for composing paths, and a shorthand for <see cref="M:Sasa.IO.FilePath.Combine(Sasa.IO.FilePath)"/>:
            <code>
            var foo = "foo/../..";
            var path1 = new FilePath(foo);
            var path2 = "bar" / path1;
            Console.WriteLine(path1);
            Console.WriteLine(path2);
            Console.WriteLine("root" / path2);
            // output:
            // ..
            // .
            // root
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Implicit(System.String)~Sasa.IO.FilePath">
            <summary>
            Implicitly convert a string to a structured path.
            </summary>
            <param name="path">The path contained in an unstructured string.</param>
            <returns>A structured path.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Implicit(Sasa.IO.FilePath)~System.String">
            <summary>
            Implicitly convert a string to a structured path.
            </summary>
            <param name="path">The path contained in an unstructured string.</param>
            <returns>A structured path.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Equality(Sasa.IO.FilePath,Sasa.IO.FilePath)">
            <summary>
            Check path equality.
            </summary>
            <param name="left">The left hand path.</param>
            <param name="right">The right hand path.</param>
            <returns>True if paths are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.op_Inequality(Sasa.IO.FilePath,Sasa.IO.FilePath)">
            <summary>
            Check path inequality.
            </summary>
            <param name="left">The left hand path.</param>
            <param name="right">The right hand path.</param>
            <returns>True if paths are not equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.op_LessThan(Sasa.IO.FilePath,Sasa.IO.FilePath)">
            <summary>
            Check path inequality.
            </summary>
            <param name="left">The left hand path.</param>
            <param name="right">The right hand path.</param>
            <returns>True if paths are not equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.IO.FilePath.op_GreaterThan(Sasa.IO.FilePath,Sasa.IO.FilePath)">
            <summary>
            Check path inequality.
            </summary>
            <param name="left">The left hand path.</param>
            <param name="right">The right hand path.</param>
            <returns>True if paths are not equal, false otherwise.</returns>
        </member>
        <member name="T:Sasa.IO.Streams">
            <summary>
            Extension methods to System.IO.Stream
            </summary>
        </member>
        <member name="M:Sasa.IO.Streams.CopyTo(System.IO.Stream,System.IO.Stream,System.Int64)">
            <summary>
            Copy one stream to another.
            </summary>
            <param name="input">The input stream.</param>
            <param name="output">The output stream.</param>
            <param name="count">The number of bytes to copy.</param>
            <remarks>
            This extension method copies data from one stream to another:
            <code>
            var source = new MemoryStream(Encoding.ASCII.GetBytes("Hello world!"));
            var target = new MemoryStream();
            source.CopyTo(target);
            Console.WriteLine(Encoding.ASCII.GetString(target.ToArray()));
            // output:
            // Hello world!
            </code>
            There is also an overload explicitly specifying the number of bytes to copy.
            </remarks>
        </member>
        <member name="M:Sasa.IO.Streams.ToArray(System.IO.Stream)">
            <summary>
            Read the full stream into a byte array.
            </summary>
            <param name="stream">The stream to read.</param>
            <returns>The contents of the stream.</returns>
            <remarks>
            This extension method dumps the contents of any stream into a byte[]:
            <code>
            // write contents to file
            using (var fs = File.OpenWrite("foo.txt"))
            {
                fs.Write(Encoding.ASCII.GetBytes("Hello world!"));
            }
            // read contents from file in one go
            byte[] data;
            using (var fs = File.OpenRead("foo.txt"))
            {
                data = fs.ToArray();
            }
            Console.WriteLine(Encoding.ASCII.GetString(data));
            // output:
            // Hello world!
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.ITuple`1">
            <summary>
            A two element tuple.
            </summary>
            <typeparam name="T">The first argument type.</typeparam>
            <remarks>
            It's common to return multiple values from functions, and there are two common ways to
            do so in .NET: out parameters, and ordinary objects like structs and classes.
            
            Unfortunately, defining a whole class just to return two or three values is often overkill. Also,
            out parameters have some limitations, like inability to use them in lambdas, even when it's safe
            to do so.
            
            Enter tuples, which are types containing only generic parameters whose only purpose is to group
            some items together to address these difficulties. Sasa's ITuple interfaces define the abstract
            contracts satisfied by Sasa's tuple types.
            
            However, unlike .NET's newly released tuples, Sasa's implementation tuples don't use the "tuple"
            name. They are instead split into <see cref="T:Sasa.Pair`2"/>, <see cref="T:Sasa.Triple`3"/> and
            <see cref="T:Sasa.Quad`4"/> because I found the shared "tuple" name often confusing when
            auditing code. Particularly where nested generics are concerned, like enumerable sequences of
            tuples, it's often hard to distinguish Tuple&lt;string,int,int&gt;
            from Tuple&lt;string,int,int,int&gt; while refactoring.
            </remarks>
        </member>
        <member name="P:Sasa.ITuple`1.First">
            <summary>
            The first value.
            </summary>
            <remarks>
            This property permits clients to access the first item in a tuple of arbitrary size:
            <code>
            var x = Tuples.Create(3, "foo");
            Console.WriteLine(x.First);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.ITuple`2">
            <summary>
            A two element tuple.
            </summary>
            <typeparam name="T0">The first argument type.</typeparam>
            <typeparam name="T1">The second argument type.</typeparam>
            <remarks>
            It's common to return multiple values from functions, and there are two common ways to
            do so in .NET: out parameters, and ordinary objects like structs and classes.
            
            Unfortunately, defining a whole class just to return two or three values is often overkill. Also,
            out parameters have some limitations, like inability to use them in lambdas, even when it's safe
            to do so.
            
            Enter tuples, which are types containing only generic parameters whose only purpose is to group
            some items together to address these difficulties. Sasa's ITuple interfaces define the abstract
            contracts satisfied by Sasa's tuple types.
            
            However, unlike .NET's newly released tuples, Sasa's implementation tuples don't use the "tuple"
            name. They are instead split into <see cref="T:Sasa.Pair`2"/>, <see cref="T:Sasa.Triple`3"/> and
            <see cref="T:Sasa.Quad`4"/> because I found the shared "tuple" name often confusing when
            auditing code. Particularly where nested generics are concerned, like enumerable sequences of
            tuples, it's often hard to distinguish Tuple&lt;string,int,int&gt;
            from Tuple&lt;string,int,int,int&gt; while refactoring.
            </remarks>
        </member>
        <member name="P:Sasa.ITuple`2.Second">
            <summary>
            The second value.
            </summary>
            <remarks>
            This property permits clients to access the second item in a tuple of arbitrary size:
            <code>
            var x = Tuples.Create(3, "foo");
            Console.WriteLine(x.Second);
            // output:
            // foo
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.ITuple`3">
            <summary>
            A three element tuple.
            </summary>
            <typeparam name="T0">The first argument type.</typeparam>
            <typeparam name="T1">The second argument type.</typeparam>
            <typeparam name="T2">The third argument type.</typeparam>
            <remarks>
            It's common to return multiple values from functions, and there are two common ways to
            do so in .NET: out parameters, and ordinary objects like structs and classes.
            
            Unfortunately, defining a whole class just to return two or three values is often overkill. Also,
            out parameters have some limitations, like inability to use them in lambdas, even when it's safe
            to do so.
            
            Enter tuples, which are types containing only generic parameters whose only purpose is to group
            some items together to address these difficulties. Sasa's ITuple interfaces define the abstract
            contracts satisfied by Sasa's tuple types.
            
            However, unlike .NET's newly released tuples, Sasa's implementation tuples don't use the "tuple"
            name. They are instead split into <see cref="T:Sasa.Pair`2"/>, <see cref="T:Sasa.Triple`3"/> and
            <see cref="T:Sasa.Quad`4"/> because I found the shared "tuple" name often confusing when
            auditing code. Particularly where nested generics are concerned, like enumerable sequences of
            tuples, it's often hard to distinguish Tuple&lt;string,int,int&gt;
            from Tuple&lt;string,int,int,int&gt; while refactoring.
            </remarks>
        </member>
        <member name="P:Sasa.ITuple`3.Third">
            <summary>
            The third value.
            </summary>
            <remarks>
            This property permits clients to access the third item in a tuple of arbitrary size:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M);
            Console.WriteLine(x.Third);
            // output:
            // 123.4
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.ITuple`4">
            <summary>
            A four element tuple.
            </summary>
            <typeparam name="T0">The first argument type.</typeparam>
            <typeparam name="T1">The second argument type.</typeparam>
            <typeparam name="T2">The third argument type.</typeparam>
            <typeparam name="T3">The fourth argument type.</typeparam>
            <remarks>
            It's common to return multiple values from functions, and there are two common ways to
            do so in .NET: out parameters, and ordinary objects like structs and classes.
            
            Unfortunately, defining a whole class just to return two or three values is often overkill. Also,
            out parameters have some limitations, like inability to use them in lambdas, even when it's safe
            to do so.
            
            Enter tuples, which are types containing only generic parameters whose only purpose is to group
            some items together to address these difficulties. Sasa's ITuple interfaces define the abstract
            contracts satisfied by Sasa's tuple types.
            
            However, unlike .NET's newly released tuples, Sasa's implementation tuples don't use the "tuple"
            name. They are instead split into <see cref="T:Sasa.Pair`2"/>, <see cref="T:Sasa.Triple`3"/> and
            <see cref="T:Sasa.Quad`4"/> because I found the shared "tuple" name often confusing when
            auditing code. Particularly where nested generics are concerned, like enumerable sequences of
            tuples, it's often hard to distinguish Tuple&lt;string,int,int&gt;
            from Tuple&lt;string,int,int,int&gt; while refactoring.
            </remarks>
        </member>
        <member name="P:Sasa.ITuple`4.Fourth">
            <summary>
            The fourth element.
            </summary>
            <remarks>
            This property permits clients to access the fourth item in a tuple of arbitrary size:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M, "hello world!");
            Console.WriteLine(x.Third);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch1`1">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch1`1.Case``1">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch1">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch2">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch2.Case``2">
            <summary>
            The exact type.
            </summary>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch3">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch3.Case``3">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch4">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch4.Case``4">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch5">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch5.Case``5">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch6">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch6.Case``6">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch7">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch7.Case``7">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatchAny">
            <summary>
            This interface can dispatch on any arity.
            </summary>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch8">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch8.Case``8">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch9">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch9.Case``9">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
            <typeparam name="T8">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch10">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch10.Case``10">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
            <typeparam name="T8">The exact runtime type.</typeparam>
            <typeparam name="T9">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch11">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch11.Case``11">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
            <typeparam name="T8">The exact runtime type.</typeparam>
            <typeparam name="T9">The exact runtime type.</typeparam>
            <typeparam name="T10">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch12">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch12.Case``12">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
            <typeparam name="T8">The exact runtime type.</typeparam>
            <typeparam name="T9">The exact runtime type.</typeparam>
            <typeparam name="T10">The exact runtime type.</typeparam>
            <typeparam name="T11">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch13">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch13.Case``13">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
            <typeparam name="T8">The exact runtime type.</typeparam>
            <typeparam name="T9">The exact runtime type.</typeparam>
            <typeparam name="T10">The exact runtime type.</typeparam>
            <typeparam name="T11">The exact runtime type.</typeparam>
            <typeparam name="T12">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch14">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch14.Case``14">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
            <typeparam name="T8">The exact runtime type.</typeparam>
            <typeparam name="T9">The exact runtime type.</typeparam>
            <typeparam name="T10">The exact runtime type.</typeparam>
            <typeparam name="T11">The exact runtime type.</typeparam>
            <typeparam name="T12">The exact runtime type.</typeparam>
            <typeparam name="T13">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch15">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch15.Case``15">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
            <typeparam name="T8">The exact runtime type.</typeparam>
            <typeparam name="T9">The exact runtime type.</typeparam>
            <typeparam name="T10">The exact runtime type.</typeparam>
            <typeparam name="T11">The exact runtime type.</typeparam>
            <typeparam name="T12">The exact runtime type.</typeparam>
            <typeparam name="T13">The exact runtime type.</typeparam>
            <typeparam name="T14">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.IDispatch16">
            <summary>
            Dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.IDispatch16.Case``16">
            <summary>
            The exact type.
            </summary>
            <typeparam name="T0">The exact runtime type.</typeparam>
            <typeparam name="T1">The exact runtime type.</typeparam>
            <typeparam name="T2">The exact runtime type.</typeparam>
            <typeparam name="T3">The exact runtime type.</typeparam>
            <typeparam name="T4">The exact runtime type.</typeparam>
            <typeparam name="T5">The exact runtime type.</typeparam>
            <typeparam name="T6">The exact runtime type.</typeparam>
            <typeparam name="T7">The exact runtime type.</typeparam>
            <typeparam name="T8">The exact runtime type.</typeparam>
            <typeparam name="T9">The exact runtime type.</typeparam>
            <typeparam name="T10">The exact runtime type.</typeparam>
            <typeparam name="T11">The exact runtime type.</typeparam>
            <typeparam name="T12">The exact runtime type.</typeparam>
            <typeparam name="T13">The exact runtime type.</typeparam>
            <typeparam name="T14">The exact runtime type.</typeparam>
            <typeparam name="T15">The exact runtime type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.PIC">
            <summary>
            A polymorphic inline cache used for cached dynamic dispatch.
            </summary>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch1``1(``0@,System.Type)">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="handler">The dispatcher.</param>
            <param name="type">The dynamic type used for dispatch.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch1``2(``0@,System.Type)">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TBase">The base type of the value being dispatched.</typeparam>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="handler">The dispatcher.</param>
            <param name="type">The dynamic type used for dispatch.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch2``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch3``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch4``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch5``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch6``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch7``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch8``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch9``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch10``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch11``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch12``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch13``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch14``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch15``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch16``1(``0@,System.Type[])">
            <summary>
            Dispatch to the exact runtime type.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
            <param name="types">The dynamic types used for dispatch.</param>
            <param name="handler">The dispatcher.</param>
        </member>
        <member name="M:Sasa.Dynamics.PIC.Dispatch``1(``0@,System.Type[])">
            <summary>
            Dispatch to any number of arguments.
            </summary>
            <typeparam name="TDispatch">The dispatch handler type.</typeparam>
            <param name="handler">The dispatch handler.</param>
            <param name="types">The type parameters.</param>
        </member>
        <member name="T:Sasa.Dynamics.PIC`1">
            <summary>
            A dispatch cache.
            </summary>
            <typeparam name="TDispatch">The dispatcher type.</typeparam>
        </member>
        <member name="T:Sasa.Dynamics.Dispatcher`1">
            <summary>
            The base class for all arity-specific dispatchers.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Sasa.Dynamics.Dispatcher`1.Dispatch``1(``0@)">
            <summary>
            Dispatch into the given handler.
            </summary>
            <typeparam name="TDispatch">The dispatch case handler type.</typeparam>
            <param name="handler">The dispatch case handler.</param>
        </member>
        <member name="T:Sasa.Numbers">
            <summary>
            Extensions on numeric types.
            </summary>
        </member>
        <member name="M:Sasa.Numbers.UpTo``1(``0,``0)">
            <summary>
            Generate a stream of <typeparamref name="T"/> from <paramref name="start"/> up to <paramref name="end"/>.
            </summary>
            <typeparam name="T">The sequence type.</typeparam>
            <param name="start">The lower incusive bound of the sequence.</param>
            <param name="end">The upper exclusive bound of the sequence.</param>
            <returns>A stream of int from [<paramref name="start"/>, <paramref name="end"/>) incremented by 1.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="start"/> is greater than <paramref name="end"/>.</exception>
            <remarks>
            This overloaded extension provides a simple way to generate a sequence of increasing numbers:
            <code>
            // iseq = 1, 2, 3
            IEnumerable&lt;int&gt; iseq = 1.UpTo(end: 4);
            // iseq2 = 1, 3, 5, 7
            IEnumerable&lt;int&gt; iseq2 = 1.UpTo(end: 8, step: 2);
            // dseq = 5.0, 5.5, 6.0, 6.5, 7.0
            IEnumerable&lt;double&gt; dseq = 5.0.UpTo(end: 7.5, step: 0.5);
            </code>
            The simplest overload simply takes the inclusive lower and upper bounds for the sequence, and the
            second overload additionally takes a step size designating the increment between each number emitted.
            
            These are defined as generic methods which make use of <see cref="T:Sasa.Operators`1"/>, Sasa's generic
            operators class.
            </remarks>
        </member>
        <member name="M:Sasa.Numbers.UpTo``1(``0,``0,``0)">
            <summary>
            Generate a stream of <typeparamref name="T"/> from <paramref name="start"/> up to <paramref name="end"/>.
            </summary>
            <typeparam name="T">The sequence type.</typeparam>
            <param name="start">The lower incusive bound of the sequence.</param>
            <param name="end">The upper exclusive bound of the sequence.</param>
            <param name="step">The increment value.</param>
            <returns>A stream of int from [<paramref name="start"/>, <paramref name="end"/>) incremented by <paramref name="step"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="start"/> is greater than <paramref name="end"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="step"/> is less than or equal to zero.</exception>
            <remarks>
            This overloaded extension provides a simple way to generate a sequence of increasing numbers:
            <code>
            // iseq = 1, 2, 3
            IEnumerable&lt;int&gt; iseq = 1.UpTo(end: 4);
            // iseq2 = 1, 3, 5, 7
            IEnumerable&lt;int&gt; iseq2 = 1.UpTo(end: 8, step: 2);
            // dseq = 5.0, 5.5, 6.0, 6.5, 7.0
            IEnumerable&lt;double&gt; dseq = 5.0.UpTo(end: 7.5, step: 0.5);
            </code>
            The simplest overload simply takes the inclusive lower and upper bounds for the sequence, and the
            second overload additionally takes a step size designating the increment between each number emitted.
            
            These are defined as generic methods which make use of <see cref="T:Sasa.Operators`1"/>, Sasa's generic
            operators class.
            </remarks>
        </member>
        <member name="M:Sasa.Numbers.DownTo``1(``0,``0)">
            <summary>
            Generate a stream of numbers from start up to end.
            </summary>
            <param name="start">The upper incusive bound of the stream.</param>
            <param name="end">The lower exclusive bound of the stream.</param>
            <returns>A stream of int from [<paramref name="start"/>, <paramref name="end"/>).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="start"/> is less than <paramref name="end"/>.</exception>
            <remarks>
            This extension method provides a simple way to generate a sequence of decreasing numbers:
            <code>
            // iseq = 4, 3, 2
            IEnumerable&lt;int&gt; iseq = 4.DownTo(end: 1);
            // iseq2 = 8, 6, 4, 2
            IEnumerable&lt;int&gt; iseq2 = 8.DownTo(end: 1, step: 2);
            // dseq = 7.5, 7.0, 6.5, 6.0, 5.5
            IEnumerable&lt;double&gt; dseq = 7.5.DownTo(end: 5.0, step: 0.5);
            </code>
            The simplest overload simply takes the inclusive upper and exclusive lower bounds for the sequence,
            and the second overload additionally takes a step size designating the decrement between each number
            emitted.
            
            These are defined as generic methods which make use of <see cref="T:Sasa.Operators`1"/>, Sasa's generic
            operators class.
            </remarks>
        </member>
        <member name="M:Sasa.Numbers.DownTo``1(``0,``0,``0)">
            <summary>
            Generate a stream of numbers from start up to end.
            </summary>
            <param name="start">The upper incusive bound of the stream.</param>
            <param name="end">The lower exclusive bound of the stream.</param>
            <param name="step">The increment value.</param>
            <returns>A stream of int from [<paramref name="start"/>, <paramref name="end"/>).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="start"/> is less than <paramref name="end"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="step"/> is less than or equal to zero.</exception>
            <remarks>
            This extension method provides a simple way to generate a sequence of decreasing numbers:
            <code>
            // iseq = 4, 3, 2
            IEnumerable&lt;int&gt; iseq = 4.DownTo(end: 1);
            // iseq2 = 8, 6, 4, 2
            IEnumerable&lt;int&gt; iseq2 = 8.DownTo(end: 1, step: 2);
            // dseq = 7.5, 7.0, 6.5, 6.0, 5.5
            IEnumerable&lt;double&gt; dseq = 7.5.DownTo(end: 5.0, step: 0.5);
            </code>
            The simplest overload simply takes the inclusive upper and exclusive lower bounds for the sequence,
            and the second overload additionally takes a step size designating the decrement between each number
            emitted.
            
            These are defined as generic methods which make use of <see cref="T:Sasa.Operators`1"/>, Sasa's generic
            operators class.
            </remarks>
        </member>
        <member name="M:Sasa.Numbers.Bound``1(``0,``0,``0)">
            <summary>
            Bound the given value by the upper and lower values.
            </summary>
            <param name="value">The value to bound.</param>
            <param name="min">The lower inclusive bound.</param>
            <param name="max">The upper inclusive bound.</param>
            <returns>
            Generate <paramref name="value"/> if <paramref name="min"/> &lt;= <paramref name="value"/> &lt;= <paramref name="max"/>,
            or <paramref name="min"/> or <paramref name="max"/> if <paramref name="value"/> is out of that range.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="min"/> is greater than <paramref name="max"/>.</exception>
            <remarks>
            This extension method ensures that a value falls between lower and upper inclusive limits:
            <code>
            int x = 3.Bound(0, 5);          // x=3
            int y = 99.Bound(0, 5);         // y=5
            double z = 3.0.Bound(4.4, 5.7); // z=4.4
            </code>
            This is defined as a generic method which makes use of <see cref="T:Sasa.Operators`1"/>, Sasa's generic
            operators class.
            </remarks>
        </member>
        <member name="M:Sasa.Numbers.Max``1(``0,``0)">
            <summary>
            Find the maximum of two values.
            </summary>
            <typeparam name="T">The type of values being compared.</typeparam>
            <param name="first">The first value.</param>
            <param name="second">The second value.</param>
            <returns>The max of <paramref name="first"/> and <paramref name="second"/>.</returns>
            <remarks>
            This extension method returns the maximum between two arguments it's given:
            <code>
            int x = Numbers.Max(3, 88);        // x=88
            decimal d = Numbers.Max(234M, 8M); // d=234M
            </code>
            This is defined as a generic method which makes use of <see cref="T:Sasa.Operators`1"/>, Sasa's generic operators class.
            </remarks>
        </member>
        <member name="M:Sasa.Numbers.Min``1(``0,``0)">
            <summary>
            Find the maximum of two values.
            </summary>
            <typeparam name="T">The type of values being compared.</typeparam>
            <param name="first">The first value.</param>
            <param name="second">The second value.</param>
            <returns>The max of <paramref name="first"/> and <paramref name="second"/>.</returns>
            <remarks>
            This extension method returns the smaller of two arguments:
            <code>
            int x = Numbers.Min(3, 88);        // x=3
            decimal d = Numbers.Min(234M, 8M); // d=8M
            </code>
            This is defined as a generic method which makes use of <see cref="T:Sasa.Operators`1"/>, Sasa's generic operators class.
            </remarks>
        </member>
        <member name="M:Sasa.Numbers.GetHashCode``1(``0,``0,``0,System.Int32)">
            <summary>
            Computes a universal hash code.
            </summary>
            <param name="value">The value to hash.</param>
            <param name="scalingFactor">The multiplicative constant.</param>
            <param name="additiveConstant">The additive constant.</param>
            <param name="bitCount">The number of bits in the resulting hash.</param>
            <returns>An integral universal hash code.</returns>
        </member>
        <member name="M:Sasa.Numbers.ToSentence(System.Int32)">
            <summary>
            Converts the given number to an english sentence.
            </summary>
            <param name="number">The number to convert.</param>
            <returns>The string representation of the number.</returns>
            <remarks>
            This method converts an integer to its English sentence representation:
            <code>
            var list = new[] { 3, 99, -99, int.MinValue };
            foreach (var x in list)
            {
               Console.WriteLine(Numbers.ToSentence(x));
            }
            // outputs:
            // Three
            // Ninety Nine
            // Minus Ninety Nine
            // Minus Two Billion One Hundred Fourty Seven Million Four Hundred Eighty Three Thousand Six Hundred Fourty Eight
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Operator">
            <summary>
            A enumeration describing the overloadable operators.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Addition">
            <summary>
            Addition operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Subtraction">
            <summary>
            Subtraction operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Multiply">
            <summary>
            Multiplication operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Division">
            <summary>
            Division operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.GreaterThan">
            <summary>
            Comparison operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.GreaterThanOrEqual">
            <summary>
            Comparison operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.LessThan">
            <summary>
            Comparison operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.LessThanOrEqual">
            <summary>
            Comparison operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Increment">
            <summary>
            Increment by one.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Decrement">
            <summary>
            Decrement by one.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Modulus">
            <summary>
            Modulus/remainder operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.UnaryNegation">
            <summary>
            Negation operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.UnaryPlus">
            <summary>
            Unary plus operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Implicit">
            <summary>
            Implicit conversion.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Explicit">
            <summary>
            Explicit conversion.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Equality">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="F:Sasa.Operator.Inequality">
            <summary>
            Inequality test.
            </summary>
        </member>
        <member name="F:Sasa.Operator.BitwiseAnd">
            <summary>
            Bitwise-and operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.BitwiseOr">
            <summary>
            Bitwise-or operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.ExclusiveOr">
            <summary>
            Bitwise-xor operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.OnesComplement">
            <summary>
            Bitwise-complement/not operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.LeftShift">
            <summary>
            Left shift operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.RightShift">
            <summary>
            Right shift operator.
            </summary>
        </member>
        <member name="F:Sasa.Operator.True">
            <summary>
            Operator that converts value to true.
            </summary>
        </member>
        <member name="F:Sasa.Operator.False">
            <summary>
            Operator that converts value to false.
            </summary>
        </member>
        <member name="T:Sasa.Operators">
            <summary>
            Static extension on operators.
            </summary>
        </member>
        <member name="M:Sasa.Operators.Emit(System.Reflection.Emit.ILGenerator,Sasa.Operator,System.Nullable{System.Reflection.Emit.OpCode},System.Boolean,System.Action{System.Reflection.Emit.ILGenerator})">
            <summary>
            Emit the opcodes for primitive operators.
            </summary>
            <param name="il">The <see cref="T:System.Reflection.Emit.ILGenerator"/> to emit into.</param>
            <param name="op">The operator to emit.</param>
            <param name="conv">The optional conversion instruction.</param>
            <param name="unsigned">Flag indicating whether operator is signed or unsigned.</param>
            <param name="load">Delegate used to load the arguments being processed.</param>
        </member>
        <member name="M:Sasa.Operators.Convert(System.Type)">
            <summary>
            Inserts a conversion operation.
            </summary>
            <param name="type">The type to convert to.</param>
            <returns>The opcode used to convert to <paramref name="type"/>.</returns>
        </member>
        <member name="T:Sasa.Operators`1">
            <summary>
            Operators defined for type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type on which the operators are defined.</typeparam>
            <remarks>
            When writing generic code, it's pretty common to yearn for some generic operator interface so
            you don't have to copy-paste the same function over and over to provide overloads for all the
            CLR's primitive types. Omitting a standard operator interface was one of .NET's biggest mistakes
            in my opinion.
            
            Enter <see cref="T:Sasa.Operators`1"/>, a static class library that exposes the delegates for the
            standard mathematical and logical operators on any given type <typeparamref name="T"/>.
            If <typeparamref name="T"/> does not contain a particular operator overload, the
            corresponding delegate for that operation will be null, so you just need to check for
            their presence as a precondition.
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Add">
            <summary>
            Adds two arguments.
            </summary>
            <remarks>
            The standard addition operation is straightforward, taking two T arguments and returning their addition:
            <code>
            var x = Operators&lt;int&gt;.Add(1, 2);
            Console.WriteLine(x);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Subtract">
            <summary>
            Subtracts two arguments.
            </summary>
            <remarks>
            The subtraction operator takes two T arguments, and returns their subtraction:
            <code>
            var x = Operators&lt;int&gt;.Subtract(1, 3);
            Console.WriteLine(x);
            // output:
            // -2
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Divide">
            <summary>
            Divides two arguments.
            </summary>
            <remarks>
            The divide operator two T arguments and returns a T argument corresponding to their division:
            <code>
            var x = Operators&lt;int&gt;.Divide(6, 2);
            Console.WriteLine(x);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Multiply">
            <summary>
            Multiplies two arguments.
            </summary>
            <remarks>
            The multiply operator takes two T arguments, and returns their multiplication:
            <code>
            var x = Operators&lt;int&gt;.Multiply(9, 2);
            Console.WriteLine(x);
            // output:
            // 18
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Modulo">
            <summary>
            Takes the remainder of two arguments.
            </summary>
            <remarks>
            The modulo operator takes two T arguments, and returns the modulus/remainder of dividing the two arguments:
            <code>
            var x = Operators&lt;int&gt;.Modulo(9, 2);
            Console.WriteLine(x);
            // output:
            // 1
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Negate">
            <summary>
            Negates an argument.
            </summary>
            <remarks>
            The negate operator takes a T argument, and returns its negation:
            <code>
            var x = Operators&lt;int&gt;.Negate(9);
            Console.WriteLine(x);
            // output:
            // -9
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Not">
            <summary>
            Bitwise complement.
            </summary>
            <remarks>
            The 'not' operator takes a T argument, and returns logical/bitwise not of the value:
            <code>
            // given twos-complement, not(-1) == 0
            var x = Operators&lt;int&gt;.Not(-1); 
            Console.WriteLine(x);
            // output:
            // 0
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Increment">
            <summary>
            Increments an argument.
            </summary>
            <remarks>
            The increment operator a T argument and returns an "incremented" T:
            <code>
            var x = Operators&lt;int&gt;.Increment(98);
            Console.WriteLine(x);
            // output:
            // 99
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Decrement">
            <summary>
            Decrements an argument.
            </summary>
            <remarks>
            The decrement operator takes a T argument, and returns a "decremented" T argument:
            <code>
            var x = Operators&lt;double&gt;.Decrement(1.5);
            Console.WriteLine(x);
            // output:
            // 0.5
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Or">
            <summary>
            Or's an argument.
            </summary>
            <remarks>
            The 'or' operator takes two T arguments, and returns their logical/bitwise-or:
            <code>
            var x = Operators&lt;int&gt;.Or(1, 2);
            Console.WriteLine(x);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Xor">
            <summary>
            Xor's its argument.
            </summary>
            <remarks>
            The xor operator takes two T arguments, and returns their logical/bitwise exclusive-or:
            <code>
            var x = Operators&lt;int&gt;.Xor(1, 3);
            Console.WriteLine(x);
            // output:
            // 2
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.And">
            <summary>
            And's its argument.
            </summary>
            <remarks>
            The 'And' operation takes two T arguments, and returns a T argument which is the bitwise/logical
            'and' of the two arguments:
            <code>
            var x = Operators&lt;int&gt;.And(1, 3);
            Console.WriteLine(x);
            // output:
            // 1
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.LeftShift">
            <summary>
            Left shifts an argument.
            </summary>
            <remarks>
            The left shift operator a T argument, followed by an Int32 argument, and returns a T "left-shifted" by the Int32:
            <code>
            var x = Operators&lt;int&gt;.LeftShift(1, 3);
            Console.WriteLine(x);
            // output:
            // 8
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.RightShift">
            <summary>
            Right shifts an argument.
            </summary>
            <remarks>
            The right shift operator a T argument, followed by an Int32 argument, and returns a T "right-shifted" by the Int32:
            <code>
            var x = Operators&lt;int&gt;.RightShift(8, 3);
            Console.WriteLine(x);
            // output:
            // 1
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.True">
            <summary>
            Converts the type to a boolean.
            </summary>
            <remarks>
            The boolean conversion operator:
            <code>
            Console.WriteLine(Operators&lt;bool&gt;.True(false));
            Console.WriteLine(Operators&lt;bool&gt;.True(true));
            // output:
            // false
            // true
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.False">
            <summary>
            Converts the type to a boolean.
            </summary>
            <remarks>
            The boolean conversion operator:
            <code>
            Console.WriteLine(Operators&lt;bool&gt;.False(false));
            Console.WriteLine(Operators&lt;bool&gt;.False(true));
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Plus">
            <summary>
            Unary plus operator.
            </summary>
            <remarks>
            The unary plus operator:
            <code>
            var x = Operators&lt;Foo&gt;.Plus(new Foo());
            Console.WriteLine(x);
            // output:
            // 1
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.GreaterThan">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes two T arguments, and returns true if the first is greater than the second:
            <code>
            var x = Operators&lt;int&gt;.GreaterThan(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.LessThan">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes two T arguments, and returns true if the first is less than the second:
            <code>
            var x = Operators&lt;int&gt;.LessThan(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.GreaterThanOrEqual">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes two T arguments, and returns true if the first is greater than or equal to the second:
            <code>
            var x = Operators&lt;int&gt;.GreaterThan(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.LessThanOrEqual">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes two T arguments, and returns true if the first is less than or equal to the second:
            <code>
            var x = Operators&lt;int&gt;.LessThan(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.Equal">
            <summary>
            Compare arguments for equality.
            </summary>
            <remarks>
            The == operator takes two T arguments, and returns true if they are equal:
            <code>
            var x = Operators&lt;int&gt;.Equal(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`1.NotEqual">
            <summary>
            Compare arguments for inequality.
            </summary>
            <remarks>
            The == operator takes two T arguments, and returns true if they are not equal:
            <code>
            var x = Operators&lt;int&gt;.NotEqual(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Operators`2">
            <summary>
            Operators defined for types <typeparamref name="T0"/> and <typeparamref name="T1"/>.
            </summary>
            <typeparam name="T0">The first operator type.</typeparam>
            <typeparam name="T1">The second operator type.</typeparam>
            <remarks>
            When writing generic code, it's pretty common to yearn for some generic operator interface so
            you don't have to copy-paste the same function over and over to provide overloads for all the
            CLR's primitive types. Omitting a standard operator interface was one of .NET's biggest mistakes
            in my opinion.
            
            Enter <see cref="T:Sasa.Operators`2"/>, a static class library that exposes delegates for the
            overloadable operators defined on types <typeparamref name="T0"/> and <typeparamref name="T1"/>.
            If neither type contains an operator overload for a given operation, the corresponding delegate
            for that operation will be null, so you just need to check for their presence as a precondition.
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.Negate">
            <summary>
            Negates an argument.
            </summary>
            <remarks>
            The negate operator takes a T argument, and returns its negation:
            <code>
            var x = Operators&lt;int, int&gt;.Negate(9);
            Console.WriteLine(x);
            // output:
            // -9
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.Implicit">
            <summary>
            Implicitly converts an argument type.
            </summary>
            <remarks>
            The implicit conversion operator converts a <typeparamref name="T0"/> to a <typeparamref name="T1"/>:
            <code>
            var x = Operators&lt;int, int&gt;.Implicit(9);
            Console.WriteLine(x);
            // output:
            // -9
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.Explicit">
            <summary>
            Explicitly converts an argument type.
            </summary>
            <remarks>
            The explicit conversion operator converts a <typeparamref name="T0"/> to a <typeparamref name="T1"/>:
            <code>
            var x = Operators&lt;int, float&gt;.Explicit(9);
            Console.WriteLine(x);
            // output:
            // -9
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.Not">
            <summary>
            Bitwise complement.
            </summary>
            <remarks>
            The 'not' operator takes a T argument, and returns logical/bitwise not of the value:
            <code>
            // given twos-complement, not(-1) == 0
            var x = Operators&lt;int, int&gt;.Not(-1); 
            Console.WriteLine(x);
            // output:
            // 0
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.Increment">
            <summary>
            Increments an argument.
            </summary>
            <remarks>
            The increment operator a T argument and returns an "incremented" T:
            <code>
            var x = Operators&lt;int, int&gt;.Increment(98);
            Console.WriteLine(x);
            // output:
            // 99
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.Decrement">
            <summary>
            Decrements an argument.
            </summary>
            <remarks>
            The decrement operator takes a T argument, and returns a "decremented" T argument:
            <code>
            var x = Operators&lt;double, double&gt;.Decrement(1.5);
            Console.WriteLine(x);
            // output:
            // 0.5
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.LeftShift">
            <summary>
            Left shifts an argument.
            </summary>
            <remarks>
            The left shift operator a T argument, followed by an Int32 argument, and returns a T "left-shifted" by the Int32:
            <code>
            var x = Operators&lt;int, int&gt;.LeftShift(1, 3);
            Console.WriteLine(x);
            // output:
            // 8
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.RightShift">
            <summary>
            Right shifts an argument.
            </summary>
            <remarks>
            The right shift operator a T argument, followed by an Int32 argument, and returns a T "right-shifted" by the Int32:
            <code>
            var x = Operators&lt;int, int&gt;.RightShift(8, 3);
            Console.WriteLine(x);
            // output:
            // 1
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.Plus">
            <summary>
            Unary plus operator.
            </summary>
            <remarks>
            The unary plus operator:
            <code>
            var x = Operators&lt;int, int&gt;.Plus(-1);
            Console.WriteLine(x);
            // output:
            // -1
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.GreaterThan">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes two T arguments, and returns true if the first is greater than the second:
            <code>
            var x = Operators&lt;int, int&gt;.GreaterThan(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.LessThan">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes two T arguments, and returns true if the first is less than the second:
            <code>
            var x = Operators&lt;int, int&gt;.LessThan(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.GreaterThanOrEqual">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes two T arguments, and returns true if the first is greater than or equal to the second:
            <code>
            var x = Operators&lt;int, int&gt;.GreaterThan(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.LessThanOrEqual">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes two T arguments, and returns true if the first is less than or equal to the second:
            <code>
            var x = Operators&lt;int, int&gt;.LessThan(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.Equal">
            <summary>
            Compare arguments for equality.
            </summary>
            <remarks>
            The == operator takes two T arguments, and returns true if they are equal:
            <code>
            var x = Operators&lt;int, int&gt;.Equal(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`2.NotEqual">
            <summary>
            Compare arguments for inequality.
            </summary>
            <remarks>
            The == operator takes two T arguments, and returns true if they are not equal:
            <code>
            var x = Operators&lt;int, int&gt;.NotEqual(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Operators`3">
            <summary>
            Operators defined for types <typeparamref name="T0"/>, <typeparamref name="T1"/>
            <typeparamref name="T2"/>.
            </summary>
            <typeparam name="T0">The first operator type.</typeparam>
            <typeparam name="T1">The second operator type.</typeparam>
            <typeparam name="T2">The third operator type.</typeparam>
            <remarks>
            When writing generic code, it's pretty common to yearn for some generic operator interface so
            you don't have to copy-paste the same function over and over to provide overloads for all the
            CLR's primitive types. Omitting a standard operator interface was one of .NET's biggest mistakes
            in my opinion.
            
            Enter <see cref="T:Sasa.Operators`3"/>, a static class library that exposes delegates for the
            overloadable operators defined on types <typeparamref name="T0"/> and <typeparamref name="T1"/>.
            If neither type contains an operator overload for a given operation, the corresponding delegate
            for that operation will be null, so you just need to check for their presence as a precondition.
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.Add">
            <summary>
            Adds two arguments.
            </summary>
            <remarks>
            The standard addition operation takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and
            returns their addition as type <typeparamref name="T2"/>:
            <code>
            var x = Operators&lt;int, long, double&gt;.Add(1, 2);
            Console.WriteLine(x);
            // output:
            // 3.0
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.Subtract">
            <summary>
            Subtracts two arguments.
            </summary>
            <remarks>
            The subtraction operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their subtraction as type <typeparamref name="T2"/>:
            <code>
            var x = Operators&lt;int, int, int&gt;.Subtract(1, 3);
            Console.WriteLine(x);
            // output:
            // -2
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.Divide">
            <summary>
            Divides two arguments.
            </summary>
            <remarks>
            The divide operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their
            division as type <typeparamref name="T2"/>:
            <code>
            var x = Operators&lt;long, int, int&gt;.Divide(6, 2);
            Console.WriteLine(x);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.Multiply">
            <summary>
            Multiplies two arguments.
            </summary>
            <remarks>
            The multiply operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their multiplication as type <typeparamref name="T2"/>:
            <code>
            var x = Operators&lt;int, int, uint&gt;.Multiply(9, 2);
            Console.WriteLine(x);
            // output:
            // 18
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.Modulo">
            <summary>
            Takes the remainder of two arguments.
            </summary>
            <remarks>
            The modulo operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their modulus as type <typeparamref name="T2"/>:
            <code>
            var x = Operators&lt;int, int, int&gt;.Modulo(9, 2);
            Console.WriteLine(x);
            // output:
            // 1
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.Or">
            <summary>
            Or's an argument.
            </summary>
            <remarks>
            The 'or' operator  takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their logical/bitwise-or as type <typeparamref name="T2"/>:
            <code>
            var x = Operators&lt;int&gt;.Or(1, 2);
            Console.WriteLine(x);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.Xor">
            <summary>
            Xor's its argument.
            </summary>
            <remarks>
            The xor operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their logical/bitwise exclusive-or as type <typeparamref name="T2"/>:
            <code>
            var x = Operators&lt;int, int, uint&gt;.Xor(1, 3);
            Console.WriteLine(x);
            // output:
            // 2
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.And">
            <summary>
            And's its argument.
            </summary>
            <remarks>
            The 'And' operation takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their
            bitwise/logical 'and' as type <typeparamref name="T2"/>:
            <code>
            var x = Operators&lt;int, uint, uint&gt;.And(1, 3);
            Console.WriteLine(x);
            // output:
            // 1
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.GreaterThan">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their &gt; as type <typeparamref name="T2"/>, where T2 must implement the true/false operators:
            <code>
            var x = Operators&lt;int&gt;.GreaterThan(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.LessThan">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their &lt; as type <typeparamref name="T2"/>, where T2 must implement the true/false operators:
            <code>
            var x = Operators&lt;int&gt;.LessThan(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.GreaterThanOrEqual">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their &gt;= as type <typeparamref name="T2"/>, where T2 must implement the true/false operators:
            <code>
            var x = Operators&lt;int&gt;.GreaterThan(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.LessThanOrEqual">
            <summary>
            Compare argument magnitudes.
            </summary>
            <remarks>
            The &gt; operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their &lt;= as type <typeparamref name="T2"/>, where T2 must implement the true/false operators:
            <code>
            var x = Operators&lt;int&gt;.LessThan(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.Equal">
            <summary>
            Compare arguments for equality.
            </summary>
            <remarks>
            The == operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their equality as type <typeparamref name="T2"/>, where T2 must implement the true/false operators:
            <code>
            var x = Operators&lt;int&gt;.Equal(1, 2);
            Console.WriteLine(x);
            // output:
            // false
            </code>
            </remarks>
        </member>
        <member name="F:Sasa.Operators`3.NotEqual">
            <summary>
            Compare arguments for inequality.
            </summary>
            <remarks>
            The != operator takes arguments <typeparamref name="T0"/> and <typeparamref name="T1"/> and returns their inequality as type <typeparamref name="T2"/>, where T2 must implement the true/false operators:
            <code>
            var x = Operators&lt;int&gt;.NotEqual(1, 2);
            Console.WriteLine(x);
            // output:
            // true
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Result`1">
            <summary>
            The result of a computation reified as a value.
            </summary>
            <typeparam name="T">The type of the computation's return value.</typeparam>
        </member>
        <member name="M:Sasa.Result`1.#ctor(`0)">
            <summary>
            Construct an instance of <see cref="T:Sasa.Result`1"/>.
            </summary>
            <param name="value">The result's value.</param>
        </member>
        <member name="M:Sasa.Result`1.#ctor(System.Exception)">
            <summary>
            Construct an instance of <see cref="T:Sasa.Result`1"/>.
            </summary>
            <param name="error">The resulting error.</param>
        </member>
        <member name="P:Sasa.Result`1.Value">
            <summary>
            The return value of the computation.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when <see cref="T:Sasa.Result`1"/> has no value. The inner exception indicates the reason.</exception>
            <remarks>
            This property allows clients to obtain the value that was returned from the computation. If an error was instead
            generated, then this throws <see cref="T:System.InvalidOperationException"/> with the <see cref="P:System.Exception.InnerException"/> property
            set to the original exception:
            <code>
            Result&lt;int&gt; hasValue = 3;
            Result&lt;int&gt; noValue = new Result&lt;int&gt;(new ArgumentException("somearg"));
            Console.WriteLine(hasValue.Value);
            Console.WriteLine(noValue.Value); //InvalidOperationException
            // outputs:
            // 3
            // InvalidOperationException
            </code>
            This property is also required by <see cref="T:Sasa.IValue`1"/>, which <see cref="T:Sasa.Result`1"/> implements.
            </remarks>
        </member>
        <member name="P:Sasa.Result`1.Error">
            <summary>
            The error that was generated.
            </summary>
            <remarks>
            This property allows clients to access the exception that resulted from the computation, with the
            full stack trace intact:
            <code>
            void EnsureValue&lt;T&gt;(Result&lt;T&gt; result)
            {
              if (!result.HasValue)
                Environment.FailFast("Unexpected result!", result.Error);
            }
            </code>
            This property is also required by <see cref="T:Sasa.IResult`1"/>, which <see cref="T:Sasa.Result`1"/> implements.
            </remarks>
        </member>
        <member name="P:Sasa.Result`1.HasValue">
            <summary>
            A boolean indicating whether a value was successfully computed.
            </summary>
            <remarks>
            This property allows clients to check whether the result is a legitimate value, or if it's an error result. If HasValue returns
            true, then clients can safely access the Value property. If it's false, then doing so will throw
            <see cref="T:System.InvalidOperationException" />
            <code>
            Result&lt;int&gt; hasValue = 3;
            Result&lt;int&gt; noValue = new Result&lt;int&gt;(new ArgumentException("somearg"));
            Console.WriteLine(hasValue.HasValue);
            Console.WriteLine(noValue.HasValue);
            // outputs:
            // true
            // false
            </code>
            This property is also required by the <see cref="T:Sasa.IOptional`1"/>, which <see cref="T:Sasa.Option`1"/> implements.
            </remarks>
        </member>
        <member name="M:Sasa.Result`1.TryGetValue(`0@)">
            <summary>
            Attempt to extract the computed value.
            </summary>
            <param name="value">The value computed.</param>
            <returns>True if a value was computed, false otherwise.</returns>
            <remarks>
            This method permits accessing the encapsulated Value without throwing an exception if the result was an error:
            <code>Result&lt;int&gt; someInt = 3;
            int x;
            if (someInt.TryGetValue(out x))
              Console.WriteLine(x);
            else
              Console.WriteLine(someInt.Error);
            
            Result&lt;int&gt; noInt = new ArgumentException("noInt");
            if (noInt.TryGetValue(out x))
              Console.WriteLine(x);
            else
              Console.WriteLine(noInt.Error);
              
            // output is:
            // 3
            // System.ArgumentException: ...
            </code>
            This method is required by the <see cref="T:Sasa.IVolatile`1"/> interface, which <see cref="T:Sasa.Result`1"/> implements.
            </remarks>
        </member>
        <member name="M:Sasa.Result`1.Equals(`0)">
            <summary>
            Compares the result with a value for equality.
            </summary>
            <param name="other">The value to compare to.</param>
            <returns>True if the values are equal, false otherwise</returns>
        </member>
        <member name="M:Sasa.Result`1.Equals(Sasa.Result{`0})">
            <summary>
            Compares the result with a value for equality.
            </summary>
            <param name="other">The value to compare to.</param>
            <returns>True if the values are equal, false otherwise</returns>
        </member>
        <member name="M:Sasa.Result`1.Equals(System.Object)">
            <summary>
            Compare against <paramref name="obj"/>.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True if objects are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Result`1.GetHashCode">
            <summary>
            Computes hash code.
            </summary>
            <returns>Integer hash code.</returns>
        </member>
        <member name="M:Sasa.Result`1.op_Implicit(`0)~Sasa.Result{`0}">
            <summary>
            Implicitly convert a value into a successful <see cref="T:Sasa.Result`1"/>.
            </summary>
            <param name="value">The return value of the computation.</param>
            <returns>A successful <see cref="T:Sasa.Result`1"/>.</returns>
        </member>
        <member name="M:Sasa.Result`1.op_Implicit(Sasa.Option{`0})~Sasa.Result{`0}">
            <summary>
            Implicit convert an <see cref="T:Sasa.Option`1"/> into a <see cref="T:Sasa.Result`1"/>.
            </summary>
            <param name="opt">The option to convert.</param>
            <returns>A <see cref="T:Sasa.Result`1"/>.</returns>
        </member>
        <member name="M:Sasa.Result`1.op_BitwiseOr(Sasa.Result{`0},Sasa.Result{`0})">
            <summary>
            Coalesce optional value.
            </summary>
            <param name="left">The optional value to return, if available.</param>
            <param name="right">The value to return if optional value is empty.</param>
            <returns>Returns <paramref name="left"/> if not empty, otherwise returns <paramref name="right"/>.</returns>
            <remarks>
            The C# null coalescing operator, ??, is hard-coded to only apply to reference types or
            <see cref="T:System.Nullable`1"/>. However, the short-circuiting logical-or operator can be
            overridden, and <see cref="T:Sasa.Result`1"/> does so to provide result-coalescing:
            <code>Result&lt;int&gt; someInt = 3;
            Result&lt;int&gt; noInt = new ArgumentException("noInt");
            Console.WriteLine(someInt || 99);
            Console.WriteLine(noInt || 99);
            // output is:
            // 3
            // 99
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Result`1.op_True(Sasa.Result{`0})">
            <summary>
            Populated optional values reduce to true.
            </summary>
            <param name="result">The optional value to check.</param>
            <returns>True if the HasValue is true.</returns>
        </member>
        <member name="M:Sasa.Result`1.op_False(Sasa.Result{`0})">
            <summary>
            Unpopulated optional values reduce to false.
            </summary>
            <param name="result">The optional value to check.</param>
            <returns>True if !HasValue.</returns>
        </member>
        <member name="M:Sasa.Result`1.Select``1(System.Func{`0,``0})">
            <summary>
            Compute a <see cref="T:Sasa.Result`1"/> from a <see cref="T:Sasa.Result`1"/>.
            </summary>
            <typeparam name="TValue">The new result type.</typeparam>
            <param name="selector">A function computing the <see cref="T:Sasa.Result`1"/>.</param>
            <returns>A <see cref="T:Sasa.Result`1"/> computed from <paramref name="selector"/>.</returns>
            <remarks>
            This method is the first in the series of methods used in the LINQ query pattern:
            <code>
            Result&lt;int&gt; someInt = 3;
            Result&lt;int&gt; noInt = new ArgumentException("noInt");
            Console.WriteLine(someInt.Select(x => x &gt; 0));
            Console.WriteLine(noInt.Select(x => x &gt; 0));
            // output is:
            // true
            // Result&lt;ArgumentException&gt;
            </code>
            There is also an implementation of Select for the more abstract <see cref="T:Sasa.IResult`1"/> interface,
            but because <see cref="T:Sasa.Result`1"/> is a struct, this would incur too much unnecessary boxing,
            so we override the Select and SelectMany extension methods with instance methods.
            </remarks>
        </member>
        <member name="M:Sasa.Result`1.SelectMany``1(System.Func{`0,Sasa.Result{``0}})">
            <summary>
            Projects a new <see cref="T:Sasa.Result`1"/>.
            </summary>
            <typeparam name="TValue">The type of the new result.</typeparam>
            <param name="collector">A projection function.</param>
            <returns>A result for the final value.</returns>
            <remarks>
            The most essential LINQ operator, the SelectMany overloads implement chaining for result values:
            <code>
            var val = from y in 2.ToResult()
                      from j in 7.ToResult()
                      from x in (y + 2 + j).ToResult()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in 2.ToResult()
                        from j in Result.Fail&lt;int&gt;(new ArgumentException("j"))
                        from x in (y + 2 + j).ToResult()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // Result&lt;ArgumentException&gt;
            </code>
            There is also an implementation of SelectMany for the more abstract <see cref="T:Sasa.IResult`1"/>
            interface, but because Result&lt;T&gt; is a struct this would incur too much unnecessary
            boxing, so we override the Select and SelectMany extension methods with instance methods.
            </remarks>
        </member>
        <member name="M:Sasa.Result`1.SelectMany``2(System.Func{`0,Sasa.Result{``0}},System.Func{`0,``0,``1})">
            <summary>
            Project a new <see cref="T:Sasa.Result`1"/>.
            </summary>
            <typeparam name="T0">The type of the intermediate result.</typeparam>
            <typeparam name="TValue">The type of the final result.</typeparam>
            <param name="collector">The intermediate project.</param>
            <param name="selector">The final projection.</param>
            <returns>A result for the final value.</returns>
            <remarks>
            The most essential LINQ operator, the SelectMany overloads implement chaining for result values:
            <code>
            var val = from y in 2.ToResult()
                      from j in 7.ToResult()
                      from x in (y + 2 + j).ToResult()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in 2.ToResult()
                        from j in Result.Fail&lt;int&gt;(new ArgumentException("j"))
                        from x in (y + 2 + j).ToResult()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // Result&lt;ArgumentException&gt;
            </code>
            There is also an implementation of SelectMany for the more abstract <see cref="T:Sasa.IResult`1"/>
            interface, but because Result&lt;T&gt; is a struct this would incur too much unnecessary
            boxing, so we override the Select and SelectMany extension methods with instance methods.
            </remarks>
        </member>
        <member name="M:Sasa.Result`1.Where(System.Func{`0,System.Boolean})">
            <summary>
            Filter out an invalid value based on a predicate.
            </summary>
            <param name="predicate">The function to apply.</param>
            <returns>
            A result of type <typeparamref name="T"/>. If the value satisfies the predicate, the value
            is returned. A result with an error of type <see cref="T:System.ArgumentException"/> is returned
            otherwise.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown if argument does not satisfy the predicate.</exception>
            <remarks>
            This method implements the LINQ where clause for query patterns on <see cref="T:Sasa.Result`1"/>:
            <code>
            Result&lt;int&gt; someInt = 3;
            Result&lt;int&gt; noInt = Result.Fail&lt;int&gt;(new NotSupportedException("noInt"));
            Console.WriteLine(someInt.Where(x => x &gt; 0));
            Console.WriteLine(someInt.Where(x => x &lt; 0));
            Console.WriteLine(noInt.Where(x => x == 0));
            // outputs:
            // true
            // Result&lt;ArgumentException&gt;
            // Result&lt;NotSupportedException&gt;
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Result`1.op_Equality(Sasa.Result{`0},Sasa.Result{`0})">
            <summary>
            Compare two values for equality.
            </summary>
            <param name="left">Left value.</param>
            <param name="right">Right value.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Result`1.op_Inequality(Sasa.Result{`0},Sasa.Result{`0})">
            <summary>
            Compare two values for inequality.
            </summary>
            <param name="left">Left value.</param>
            <param name="right">Right value.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Result`1.ToString">
            <summary>
            String representation of this result.
            </summary>
            <returns>A string representation of this result.</returns>
        </member>
        <member name="T:Sasa.Result">
            <summary>
            Extensions for computations and results.
            </summary>
        </member>
        <member name="F:Sasa.Result.nullRef">
            <summary>
            The exception to use when no value has been provided.
            </summary>
        </member>
        <member name="M:Sasa.Result.Try``1(System.Func{``0})">
            <summary>
            Try executing a function.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="func">The function to execute.</param>
            <returns>The result of executing the function.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This static extension method allows clients to execute some code within an exception handling
            block, which then returns the appropriate result for you, ie. either a value or an error:
            <code>
            Result&lt;int&gt; someInt = Result.Try(() => 3);
            Result&lt;int&gt; noInt = Result.Try&lt;int&gt;(() => throw new Exception());
            Console.WriteLine(someInt);
            Console.WriteLine(noInt);
            // output is:
            // 3
            // Result&lt;Exception&gt;
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Result.Try``2(System.Func{``0,``1})">
            <summary>
            Wrap a delegate that may throw exceptions.
            </summary>
            <typeparam name="T0">The function argument type.</typeparam>
            <typeparam name="T1">The function return type.</typeparam>
            <param name="func">The function to wrap.</param>
            <returns>A function that wraps any exceptions thrown by <paramref name="func"/> in a result type.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This static extension method allows clients to execute some code within an exception handling
            block, which then returns the appropriate result for you, ie. either a value or an error:
            <code>
            Result&lt;int&gt; someInt = Result.Try(() => 3);
            Result&lt;int&gt; noInt = Result.Try&lt;int&gt;(() => throw new Exception());
            Console.WriteLine(someInt);
            Console.WriteLine(noInt);
            // output is:
            // 3
            // Result&lt;Exception&gt;
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Result.Try``1(System.Action{``0})">
            <summary>
            Wrap a delegate that may throw exceptions.
            </summary>
            <typeparam name="T">The function argument type.</typeparam>
            <param name="func">The function to wrap.</param>
            <returns>A function that wraps any exceptions thrown by <paramref name="func"/> in a result type.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This static extension method allows clients to execute some code within an exception handling
            block, which then returns the appropriate result for you, ie. either a value or an error:
            <code>
            Result&lt;int&gt; someInt = Result.Try(() => 3);
            Result&lt;int&gt; noInt = Result.Try&lt;int&gt;(() => throw new Exception());
            Console.WriteLine(someInt);
            Console.WriteLine(noInt);
            // output is:
            // 3
            // Result&lt;Exception&gt;
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Result.Try(System.Action)">
            <summary>
            Try executing a function.
            </summary>
            <param name="func">The function to execute.</param>
            <returns>The result of executing the function.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This static extension method allows clients to execute some code within an exception handling
            block, which then returns the appropriate result for you, ie. either a value or an error:
            <code>
            Result&lt;int&gt; someInt = Result.Try(() => 3);
            Result&lt;int&gt; noInt = Result.Try&lt;int&gt;(() => throw new Exception());
            Console.WriteLine(someInt);
            Console.WriteLine(noInt);
            // output is:
            // 3
            // Result&lt;Exception&gt;
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Result.Fail``1(System.Exception)">
            <summary>
            Return a <see cref="T:Sasa.Result`1"/> with the given failure message.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="error">The error indicating the failure.</param>
            <returns>The resulting failure.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This static method creates a result failure of the appropriate type with the given exception:
            <code>
            Result&lt;int&gt; fail = Result.Fail&lt;int&gt;(new ArgumentException("fail"));
            Console.WriteLine(fail);
            // outputs:
            // Result&lt;ArgumentException&gt;
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Result.Success``1(``0)">
            <summary>
            Return a successful <see cref="T:Sasa.Result`1"/> with the given value.
            </summary>
            <typeparam name="T">The type of the result.</typeparam>
            <param name="value">The value returned.</param>
            <returns>The successfuly result.</returns>
            <remarks>
            This static method creates a successful result value of the given type:
            <code>
            Result&lt;int&gt; x = Result.Success(99);
            Console.WriteLine(x);
            // outputs:
            // 99
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Result.ToResult``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Transform a lazy sequence of possible error values into lazy sequence of results.
            </summary>
            <typeparam name="T">The type of values.</typeparam>
            <param name="sequence">The sequence to wrap.</param>
            <returns>A lazy sequence of results.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method provides some simple conversions from values into results:
            <code>
            Result&lt;int&gt; someInt = 3.ToResult();
            Result&lt;int&gt; optInt = 3.ToOption().ToResult();
            Result&lt;IEnumerable&lt;int&gt;&gt; intList = new int[] { 3, 99, 66 }.ToResult();
            </code>
            The last overload over IEnumerable is useful because such sequences are often
            lazily evaluated, which means they may have hidden errors that you will only
            incur while iterating. This overload then turns a lazy sequence of possible
            unsafe errors into a lazy sequence of exception-safe result types.
            </remarks>
        </member>
        <member name="M:Sasa.Result.SelectMany``2(Sasa.IResult{``0},System.Func{``0,Sasa.IResult{``1}})">
            <summary>
            Compute a <see cref="T:Sasa.Result`1"/> from a <see cref="T:Sasa.Result`1"/>.
            </summary>
            <typeparam name="T0">The input type.</typeparam>
            <typeparam name="T1">The type of the new result.</typeparam>
            <param name="result">The initial result.</param>
            <param name="collector">A projection function.</param>
            <returns>A result for the final value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            The most essential LINQ operator, the SelectMany overloads implement chaining for result values:
            <code>
            var val = from y in 2.ToResult()
                      from j in 7.ToResult()
                      from x in (y + 2 + j).ToResult()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in 2.ToResult()
                        from j in Result.Fail&lt;int&gt;(new ArgumentException("j"))
                        from x in (y + 2 + j).ToResult()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // Result&lt;ArgumentException&gt;
            </code>
            There is also an implementation of SelectMany for the more abstract <see cref="T:Sasa.IResult`1"/>
            interface, but because Result&lt;T&gt; is a struct this would incur too much unnecessary
            boxing, so we override the Select and SelectMany extension methods with instance methods.
            </remarks>
        </member>
        <member name="M:Sasa.Result.SelectMany``3(Sasa.IResult{``0},System.Func{``0,Sasa.IResult{``1}},System.Func{``0,``1,``2})">
            <summary>
            Project a new <see cref="T:Sasa.Result`1"/>.
            </summary>
            <typeparam name="T0">The input type.</typeparam>
            <typeparam name="T1">The type of the intermediate result.</typeparam>
            <typeparam name="T2">The type of the final result.</typeparam>
            <param name="result">The initial result.</param>
            <param name="collector">The intermediate project.</param>
            <param name="selector">The final projection.</param>
            <returns>A result for the final value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            The most essential LINQ operator, the SelectMany overloads implement chaining for result values:
            <code>
            var val = from y in 2.ToResult()
                      from j in 7.ToResult()
                      from x in (y + 2 + j).ToResult()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in 2.ToResult()
                        from j in Result.Fail&lt;int&gt;(new ArgumentException("j"))
                        from x in (y + 2 + j).ToResult()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // Result&lt;ArgumentException&gt;
            </code>
            There is also an implementation of SelectMany for the more abstract <see cref="T:Sasa.IResult`1"/>
            interface, but because Result&lt;T&gt; is a struct this would incur too much unnecessary
            boxing, so we override the Select and SelectMany extension methods with instance methods.
            </remarks>
        </member>
        <member name="M:Sasa.Result.ToResult``1(Sasa.Option{``0})">
            <summary>
            Convert an optional value to a result.
            </summary>
            <typeparam name="T">The type of the encapsulated value.</typeparam>
            <param name="value">The nullable value.</param>
            <returns>A result describing the nullable value.</returns>
            <remarks>
            This extension method provides some simple conversions from values into results:
            <code>
            Result&lt;int&gt; someInt = 3.ToResult();
            Result&lt;int&gt; optInt = 3.ToOption().ToResult();
            Result&lt;IEnumerable&lt;int&gt;&gt; intList = new int[] { 3, 99, 66 }.ToResult();
            </code>
            The last overload over IEnumerable is useful because such sequences are often
            lazily evaluated, which means they may have hidden errors that you will only
            incur while iterating. This overload then turns a lazy sequence of possible
            unsafe errors into a lazy sequence of exception-safe result types.
            </remarks>
        </member>
        <member name="M:Sasa.Result.ToResult``1(System.Nullable{``0})">
            <summary>
            Convert an optional value to a result.
            </summary>
            <typeparam name="T">The type of the encapsulated value.</typeparam>
            <param name="value">The nullable value.</param>
            <returns>A result describing the nullable value.</returns>
            <remarks>
            This extension method provides some simple conversions from values into results:
            <code>
            Result&lt;int&gt; someInt = 3.ToResult();
            Result&lt;int&gt; optInt = 3.ToOption().ToResult();
            Result&lt;IEnumerable&lt;int&gt;&gt; intList = new int[] { 3, 99, 66 }.ToResult();
            </code>
            The last overload over IEnumerable is useful because such sequences are often
            lazily evaluated, which means they may have hidden errors that you will only
            incur while iterating. This overload then turns a lazy sequence of possible
            unsafe errors into a lazy sequence of exception-safe result types.
            </remarks>
        </member>
        <member name="M:Sasa.Result.Any``1(Sasa.Result{``0},System.Func{``0,System.Boolean})">
            <summary>
            Check a predicate against a result.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="value">The result value.</param>
            <param name="predicate">The predicate to check.</param>
            <returns>True if <paramref name="value"/> has a value and the predicate returns true; false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Result.All``1(Sasa.Result{``0},System.Func{``0,System.Boolean})">
            <summary>
            Check a predicate against a result.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="value">The result value.</param>
            <param name="predicate">The predicate to check.</param>
            <returns>True if <paramref name="value"/> does not have a value or if the predicate returns true; false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Result.Clone``1(``0)">
            <summary>
            Rethrow an exception preserving the exception type and stack trace.
            </summary>
            <param name="e">The exception to rethrow.</param>
        </member>
        <member name="T:Sasa.EventModify`1">
            <summary>
            The delegate representing thread-safe event modifications.
            </summary>
            <typeparam name="T">The type of event.</typeparam>
            <param name="field">The event field being modified.</param>
            <param name="handler">The handler to add/remove from <paramref name="field"/>.</param>
        </member>
        <member name="T:Sasa.Events">
             <summary>
             Extension methods to safely trigger events. Triggering events
             using Raise() is both null-safe and thread-safe. Delegates
             are still required to ensure the state they are accessing
             is valid.
             </summary>
             <remarks>
             These functions provide a certain type of thread-safety. Eric
             Lippert described the two thread-safety issues with events on
             his blog:
             
             http://blogs.msdn.com/ericlippert/archive/2009/04/29/events-and-races.aspx
            
             This Events class provides thread-safety #1 in his list, but
             not #2. Clients do not need to perform null checks before calling
             Raise() on them, and do not need to perform locking to synchronize
             add/remove handlers if they use the Add()/Remove() functions,
             etc.
             
             Clients are still required to ensure that any delegates
             called are accessing valid state, even though that state may
             have changed.
             </remarks>
        </member>
        <member name="M:Sasa.Events.Add``1(``0@,``0)">
            <summary>
            Add <paramref name="newHandler"/> to the list of events <paramref name="del"/>.
            </summary>
            <typeparam name="T">The delegate type.</typeparam>
            <param name="del">A reference to the local <see cref="T:System.Delegate"/>.</param>
            <param name="newHandler">The delegate to add.</param>
            <remarks>
            This is a static method that takes a reference to an event type <typeparamref name="T"/> and adds
            a new delegate of type <typeparamref name="T"/> to that event in a thread-safe way without using
            locks. Typically, a public event declared in C# causes the C# compiler to create a hidden field
            of type <see cref="T:System.Object"/>, and to perform a lock on that object before modifying the event:
            <code>
            public class Foo
            {
                public event EventHandler SomeEvent;
            }
            </code>
            Translates into:
            <code>
            public class Foo
            {
                EventHandler _someEvent;
                object _someEventLock = new object();
                public EventHandler SomeEvent
                {
                    add { lock (_someEventLock) _someEvent += value; }
                    remove { lock(_someEventLoc) _someEvent -= value; }
                }
            }
            </code>
            Of course, being an immutable value, a multicast delegate doesn't need locks for mutation, we
            can just perform a lock-free, atomic compare-exchange in a loop until it succeeds:
            <code>
            public class Foo
            {
                EventHandler _someEvent;
                public EventHandler SomeEvent
                {
                    add { for (var e = _someEvent; Atomics.SetFailed(ref _someEvent, Func.Combine(e, value), e); e = _someEvent); }
                    remove { for (var e = _someEvent; Atomics.SetFailed(ref _someEvent, Func.Remove(e, value), e); e = _someEvent); }
                }
            }
            </code>
            This is both faster, and doesn't waste memory. Sasa.Events.Add performs exactly the above:
            <code>
            EventHandler _someEvent;
            ...
            Events.Add(ref _someEvent, (o,e) =&gt; ...);
            </code>
            So instead of the shorthand event notation used in C#, just declare a delegate field and
            add the add/remove handlers like so:
            <code>
            public class Foo
            {
                EventHandler _someEvent;
                public EventHandler SomeEvent
                {
                    add { Events.Add(ref _someEvent, value); }
                    remove { Events.Remove(ref _someEvent, value); }
                }
            }
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Events.RaiseAny(System.Delegate,System.Object[])">
            <summary>
            Safely raise any event.
            </summary>
            <param name="del">The multicast delegate representing the event.</param>
            <param name="args">The arguments to the delegate.</param>
        </member>
        <member name="M:Sasa.Events.Raise(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Safely raise an event.
            </summary>
            <typeparam name="T">The type of the EventArgs.</typeparam>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.AsyncCallback,System.IAsyncResult)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="result">The async <see cref="T:System.IAsyncResult"/> result value.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ResolveEventHandler,System.Object,System.ResolveEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object invoking the event.</param>
            <param name="args">The event arguments.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.AssemblyLoadEventHandler,System.Object,System.AssemblyLoadEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object invoking the event.</param>
            <param name="args">The event arguments.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.UnhandledExceptionEventHandler,System.Object,System.UnhandledExceptionEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object invoking the event.</param>
            <param name="args">The event arguments.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ConsoleCancelEventHandler,System.Object,System.ConsoleCancelEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object invoking the event.</param>
            <param name="args">The event arguments.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.CrossAppDomainDelegate)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.AppDomainInitializer,System.String[])">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="args">The delegate arguments.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.Action)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise``1(System.Action{``0},``0)">
            <summary>
            Safely raise an event.
            </summary>
            <typeparam name="T">The type of the argument to the event.</typeparam>
            <param name="del">The delegate representing the event.</param>
            <param name="arg0">The first event arg.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Safely raise an event.
            </summary>
            <typeparam name="T0">The type of the first argument to the event.</typeparam>
            <typeparam name="T1">The type of the second argument to the event.</typeparam>
            <param name="del">The delegate representing the event.</param>
            <param name="arg0">The first event arg.</param>
            <param name="arg1">The second event arg.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Safely raise an event.
            </summary>
            <typeparam name="T0">The type of the first argument to the event.</typeparam>
            <typeparam name="T1">The type of the second argument to the event.</typeparam>
            <typeparam name="T2">The type of the third argument to the event.</typeparam>
            <param name="del">The delegate representing the event.</param>
            <param name="arg0">The first event arg.</param>
            <param name="arg1">The second event arg.</param>
            <param name="arg2">The third event arg.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>
            Safely raise an event.
            </summary>
            <typeparam name="T">The type of the first argument to the event.</typeparam>
            <typeparam name="T1">The type of the second argument to the event.</typeparam>
            <typeparam name="T2">The type of the third argument to the event.</typeparam>
            <typeparam name="T3">The type of the third argument to the event.</typeparam>
            <param name="del">The delegate representing the event.</param>
            <param name="arg0">The first event arg.</param>
            <param name="arg1">The second event arg.</param>
            <param name="arg2">The third event arg.</param>
            <param name="arg3">The fourth event arg.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.AddingNewEventHandler,System.Object,System.ComponentModel.AddingNewEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.AsyncCompletedEventHandler,System.Object,System.ComponentModel.AsyncCompletedEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.CancelEventHandler,System.Object,System.ComponentModel.CancelEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.CollectionChangeEventHandler,System.Object,System.ComponentModel.CollectionChangeEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.DoWorkEventHandler,System.Object,System.ComponentModel.DoWorkEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.HandledEventHandler,System.Object,System.ComponentModel.HandledEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.ListChangedEventHandler,System.Object,System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.ProgressChangedEventHandler,System.Object,System.ComponentModel.ProgressChangedEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.PropertyChangingEventHandler,System.Object,System.ComponentModel.PropertyChangingEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.RefreshEventHandler,System.ComponentModel.RefreshEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Raise(System.ComponentModel.RunWorkerCompletedEventHandler,System.Object,System.ComponentModel.RunWorkerCompletedEventArgs)">
            <summary>
            Safely raise an event.
            </summary>
            <param name="del">The delegate representing the event.</param>
            <param name="sender">The object triggering the event.</param>
            <param name="e">The event args.</param>
            <remarks>
            This extension method provides null-safe event raising. In other words, developers
            no longer have to manually implement the following pattern:
            <code>
            event Action SomeEvent;
            ...
            var someEvent = SomeEvent;
            if (someEvent != null) someEvent();
            </code>
            Instead, they can simply call SomeEvent.Raise():
            <code>
            event Action SomeEvent;
            event EventHandler OtherEvent;
            ...
            SomeEvent.Raise();
            OtherEvent.Raise(EventArgs.Empty);
            </code>
            Note that Raise is only supported for a core set of delegate types:
            <list type="bullet">
            <item>All event handler delegates under System namespace</item>
            <item>All System.Action* delegates</item>
            <item>All event handler delegates under System.ComponentModel</item>
            </list>
            </remarks>
        </member>
        <member name="M:Sasa.Events.Remove``1(``0@,``0)">
            <summary>
            Remove <paramref name="newHandler"/> from the list of events <paramref name="del"/>.
            </summary>
            <typeparam name="T">The delegate type.</typeparam>
            <param name="del">A reference to the local <see cref="T:System.Delegate"/>.</param>
            <param name="newHandler">The delegate to remove.</param>
        </member>
        <member name="M:Sasa.Events.Clear``1(``0@)">
            <summary>
            Clears an event by setting the field to null and returning the previous event contents.
            </summary>
            <typeparam name="T">The type of the delegate.</typeparam>
            <param name="del">A reference to the local <see cref="T:System.Delegate"/>.</param>
            <returns>The previous event contents.</returns>
            <remarks>
            This method clears out the entire list of event handlers, and returns the
            original contents:
            <code>
            EventHandler _someEvent;
            ...
            var x = Events.Clear(ref _someEvent);
            // _someEvent is now null, and x has the original contents
            x.Raise();
            </code>
            I often use something like the above for thread-safe, lock-free disposal patterns.
            </remarks>
        </member>
        <member name="T:Sasa.IRef`1">
            <summary>
            A mutable reference.
            </summary>
            <typeparam name="T">The type of value the reference contains.</typeparam>
            <remarks>
            An extension of <see cref="T:Sasa.IValue`1"/> to mutable values.
            </remarks>
        </member>
        <member name="P:Sasa.IRef`1.Value">
            <summary>
            The value The reference.
            </summary>
            <exception cref="T:System.Exception">
            Implementations of <see cref="T:Sasa.IRef`1"/> may throw many different types of exceptions.
            </exception>
            <remarks>
            <see cref="T:Sasa.IRef`1"/> extends the read-only <see cref="T:Sasa.IValue`1"/> with a setter for this property:
            <code>
            IRef&lt;int&gt; x = new Ref&lt;int&gt;(3);
            x.Value = 999;
            Console.WriteLine(x.Value);
            // output:
            // 999
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.IValue`1">
            <summary>
            A read-only encapsulated value.
            </summary>
            <typeparam name="T">The type of the encapsulated value.</typeparam>
            <remarks>
            Fundamentally, programs manipulate values. These values can often be classified into various
            categories depending on how they can be manipulated or computed. At the most basic level, we
            have a simple value represented by <see cref="T:Sasa.IValue`1"/>.
            </remarks>
        </member>
        <member name="P:Sasa.IValue`1.Value">
            <summary>
            A read-only reference to a value.
            </summary>
            <exception cref="T:System.Exception">
            Implementations of <see cref="T:Sasa.IValue`1"/> may throw many different types of exceptions.
            </exception>
            <remarks>
            <see cref="T:Sasa.IValue`1"/> provides only a single property to access the encapsulated value:
            <code>
            IValue&lt;int&gt; x = new Immutable&lt;int&gt;(3);
            Console.WriteLine(x.Value);
            // output:
            // 3
            </code>
            This demonstrates the use of the simple <see cref="T:Sasa.Immutable`1"/> value class, but the Value property need
            not be so simple. It can even throw exceptions in some cases. For instance, <see cref="P:Sasa.Result`1.Value"/>
            throws InvalidOperationException if the result was an error instead of a value.
            </remarks>
        </member>
        <member name="T:Sasa.IVolatile`1">
            <summary>
            A volatile value.
            </summary>
            <typeparam name="T">The type of value held The reference.</typeparam>
            <remarks>
            Some values may or may not be present, and it's often necessary to check for the presence of a
            legitimate value and to obtaThat value in a single step. Enter <see cref="T:Sasa.IVolatile`1"/>
            which provides a standard interface for the common <see cref="M:Sasa.IVolatile`1.TryGetValue(`0@)"/>
            pattern.
            </remarks>
        </member>
        <member name="M:Sasa.IVolatile`1.TryGetValue(`0@)">
            <summary>
            Attempt to extract the value.
            </summary>
            <param name="value">The value contained The reference.</param>
            <returns>True if the value was successfully retrieved, false otherwise.</returns>
            <remarks>
            Checks for the presence of a legitimate value and to obtaThat value in a single step:
            <code>
            IVolatile&lt;int&gt; withValue = new Option&lt;int&gt;(3);
            int value;
            if (withValue.TryGetValue(out value)) Console.WriteLine(value);
            
            IVolatile&lt;int&gt; noValue = Option&lt;int&gt;.None;
            if (noValue.TryGetValue(out value)) Console.WriteLine(value);
            
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.IOptional`1">
            <summary>
            Encapsulates a value that may or may not be available.
            </summary>
            <typeparam name="T">The type of the encapsulated value.</typeparam>
            <remarks>
            This interface aggregates a few of the more primitive interfaces to make implementation
            simpler. In particular, it encapsulates the notion of an optional value by implementing
            <see cref="T:Sasa.IValue`1"/>, <see cref="T:Sasa.IVolatile`1"/> and <see cref="T:Sasa.IResolvable`1"/>.
            </remarks>
        </member>
        <member name="T:Sasa.IResolvable`1">
            <summary>
            A container for which you can test whether a value is available.
            </summary>
            <typeparam name="T">The type of the encapsulated value.</typeparam>
            <remarks>
            Some values may or may not be present, and it's often necessary to check for the presence of a
            legitimate value and to obtaThat value in a single step. Enter <see cref="T:Sasa.IResolvable`1"/>
            which provides a standard interface for the common <see cref="P:Sasa.IResolvable`1.HasValue"/>
            property.
            
            This interface is implemented by <see cref="T:Sasa.Result`1"/> and a few other abstractions in Sasa.
            <see cref="T:Sasa.Result"/> also implements the LINQ query pattern on <see cref="T:Sasa.IResult`1"/> instances.
            </remarks>
        </member>
        <member name="P:Sasa.IResolvable`1.HasValue">
            <summary>
            True if a value is available.
            </summary>
            <remarks>
            This property checks the implementation to verify whether a legitimate value
            is available:
            <code>
            IResolvable&lt;int&gt; withValue = new Option&lt;int&gt;(3);
            if (withValue.HasValue) Console.WriteLine(withValue.Value);
            
            IResolvable&lt;int&gt; noValue = Option&lt;int&gt;.None;
            if (noValue.HasValue) Console.WriteLine(noValue.Value);
            
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.IResult`1">
            <summary>
            An interface designating a value that may not have been computed
            due to an error.
            </summary>
            <typeparam name="T">The type of value being computed.</typeparam>
            <remarks>
            <see cref="T:Sasa.IResult`1"/> describes values that resolve either to a value or an error.
            </remarks>
        </member>
        <member name="P:Sasa.IResult`1.Error">
            <summary>
            The resulting error, if any.
            </summary>
            <remarks>
            If the result of a computation is an error, this property allows access to that error:
            <code>
            IResult&lt;int&gt; withValue = new Result&lt;int&gt;(3);
            if (withValue.HasValue) Console.WriteLine(withValue.Value);
            
            IResult&lt;int&gt; noValue = Result.Fail&lt;int&gt;(new ArgumentException());
            if (noValue.HasValue)
                Console.WriteLine(noValue.Value);
            else
                Console.WriteLine("Error: {0}", noValue.Error.Message);
            // output:
            // 3
            // Error: ArgumentException ...
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Ref">
            <summary>
            Base class for all first-class reference types
            </summary>
        </member>
        <member name="T:Sasa.Ref.Array`1">
            <summary>
            First-class reference indexing into an array.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Sasa.Ref.Array`1.#ctor(`0[],System.Int32)">
            <summary>
            Construct a new array reference.
            </summary>
            <param name="array">The array to reference.</param>
            <param name="index">The array index.</param>
        </member>
        <member name="P:Sasa.Ref.Array`1.Value">
            <summary>
            The encapsulated value.
            </summary>
        </member>
        <member name="T:Sasa.Ref.Member`1">
            <summary>
            First-class reference into an object property.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Sasa.Ref.Member`1.#ctor(System.Func{`0},System.Action{`0})">
            <summary>
            Construct a new property reference.
            </summary>
            <param name="get">The property getter.</param>
            <param name="set">The property setter.</param>
        </member>
        <member name="P:Sasa.Ref.Member`1.Value">
            <summary>
            The encapsulated value.
            </summary>
        </member>
        <member name="M:Sasa.Ref.Create``1(``0)">
            <summary>
            Create a simple reference value.
            </summary>
            <typeparam name="T">The type of the reference's value.</typeparam>
            <param name="value">The default value.</param>
            <returns>A first-class reference value.</returns>
        </member>
        <member name="M:Sasa.Ref.Create``1">
            <summary>
            Create an empty reference value.
            </summary>
            <typeparam name="T">The type of the reference's value.</typeparam>
            <returns>A first-class reference value.</returns>
        </member>
        <member name="M:Sasa.Ref.Create``1(``0[],System.Int32)">
            <summary>
            Create a reference into an array.
            </summary>
            <typeparam name="T">The type of the reference's value.</typeparam>
            <param name="array">The array to index into.</param>
            <param name="index">The array index.</param>
            <returns>A first-class reference value indexing the given array.</returns>
        </member>
        <member name="M:Sasa.Ref.Create``1(System.Func{``0},System.Action{``0})">
            <summary>
            Create a reference into an object.
            </summary>
            <typeparam name="T">The type of the reference's value.</typeparam>
            <param name="get">The property getter.</param>
            <param name="set">The property setter.</param>
            <returns>A first-class reference to an object's property.</returns>
        </member>
        <member name="M:Sasa.Ref.Create``1(System.Object,System.Reflection.PropertyInfo)">
            <summary>
            Create a reference into an object.
            </summary>
            <typeparam name="T">The type of the reference's value.</typeparam>
            <param name="obj">The object instance whose property we are accessing. Can be null for static properties.</param>
            <param name="property">The object's property information.</param>
            <returns>A first-class reference to an object's property.</returns>
        </member>
        <member name="M:Sasa.Ref.Create``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Create a reference into an object.
            </summary>
            <typeparam name="T">The type of the reference's value.</typeparam>
            <typeparam name="TObject">The object being accessed.</typeparam>
            <param name="obj">The object whose member we're accessing.</param>
            <param name="member">A member access expression on a constant object.</param>
            <returns>A first-class reference to an object's property.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the expression is not a simple member access of a constant object.</exception>
            <remarks>
            The <paramref name="member"/> parameter must be a simple member access expressions on a constant object:
            <code>
            var x = new WeakReference();
            IRef&lt;object&gt; xref = Ref.Create(() => uri.Target);
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Ref.Create``2(``0,System.Reflection.FieldInfo)">
            <summary>
            Construct a reference for a field.
            </summary>
            <typeparam name="TObject">The object type being referenced.</typeparam>
            <typeparam name="T">The field type being referenced.</typeparam>
            <param name="obj">The object being referenced.</param>
            <param name="field">The field being referenced.</param>
            <returns>A reference offering direct access to a field.</returns>
        </member>
        <member name="M:Sasa.Ref.Create``2(``0,System.Reflection.MemberInfo)">
            <summary>
            Construct a reference for a member.
            </summary>
            <typeparam name="TObject">The object type being referenced.</typeparam>
            <typeparam name="T">The member type being referenced.</typeparam>
            <param name="obj">The object being referenced.</param>
            <param name="member">The member reference.</param>
            <returns>A reference offering direct access to a member.</returns>
        </member>
        <member name="T:Sasa.Ref`1">
            <summary>
            Simple reference.
            </summary>
            <typeparam name="T">The type of the encapsulated value.</typeparam>
        </member>
        <member name="M:Sasa.Ref`1.#ctor(`0)">
            <summary>
            Construct a new reference.
            </summary>
            <param name="value">The default value.</param>
        </member>
        <member name="M:Sasa.Ref`1.#ctor">
            <summary>
            Construct a new empty reference.
            </summary>
        </member>
        <member name="P:Sasa.Ref`1.Value">
            <summary>
            The encapsulated value.
            </summary>
        </member>
        <member name="T:Sasa.Immutable`1">
            <summary>
            An immutable value.
            </summary>
            <typeparam name="T">The type of the encapsulated value.</typeparam>
        </member>
        <member name="M:Sasa.Immutable`1.#ctor(`0)">
            <summary>
            Constructs an instance of a value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Sasa.Immutable`1.Value">
            <summary>
            The encapsulated value.
            </summary>
        </member>
        <member name="M:Sasa.Immutable`1.op_Implicit(`0)~Sasa.Immutable{`0}">
            <summary>
            Implicitly wrap a value in an <see cref="T:Sasa.Immutable`1"/>.
            </summary>
            <param name="value">The value to wrap.</param>
            <returns>An immutable wrapper.</returns>
        </member>
        <member name="M:Sasa.Immutable`1.Equals(`0)">
            <summary>
            Check for equality.
            </summary>
            <param name="other">The object to compare to.</param>
            <returns>True if the encapsulated values are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Immutable`1.Equals(Sasa.Immutable{`0})">
            <summary>
            Check for equality.
            </summary>
            <param name="other">The immutable slot to compare to.</param>
            <returns>True if the immutable slots are equal, false otherwise.</returns>
        </member>
        <member name="T:Sasa.NonNull`1">
            <summary>
            This class encapsulates a non-null reference. An of this class instance serves as evidence
            that the encapsulated reference is not null.
            </summary>
            <typeparam name="T">The type of the encapsulated reference.</typeparam>
            <remarks>NonNull should only be used to decorate method arguments, and never as locals or fields. 
            The only way an invalid instance of NonNull can be created is when declaring it as a local:
            <code>
            ...
            NonNull&lt;T&gt; foo;
            ...
            T bar = foo; // ArgumentNullException
            </code>
            When it comes to high assurance code, you should utilize Option and NonNull types for
            method arguments, to declare which arguments may be null and which must necessarily be
            non-null. The type checker will ensure that values are handled properly within the method,
            and client code will receive the errors when passing in null references for NonNull values.
            </remarks>
        </member>
        <member name="P:Sasa.NonNull`1.Value">
            <summary>
            Retrieves the encapsulated value.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            Thrown if the instance was created via the implicit empty constructor.
            </exception>
            <remarks>
            This simple getter will simply return the encapsulated, non-null value. However, there
            are cases where an invalid instance is created by the default struct constructor. In
            such cases, an exception is thrown on first access indicating the reason for the failure:
            <code>
            var x = new NonNull&lt;T&gt;[0];
            var invalid = x.FirstOrDefault();
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.NonNull`1.HasValue">
            <summary>
            True if the value is non-null, false otherwise.
            </summary>
        </member>
        <member name="M:Sasa.NonNull`1.#ctor(`0)">
            <summary>
            Construct an assuredy non-null reference.
            </summary>
            <param name="value">The possibly null value to check.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the argument is null.</exception>
        </member>
        <member name="M:Sasa.NonNull`1.op_Implicit(Sasa.NonNull{`0})~`0">
            <summary>
            Implicit conversion back to a type T.
            </summary>
            <param name="value">The NonNull value to convert back to T.</param>
            <returns>The encapsulated T value.</returns>
        </member>
        <member name="M:Sasa.NonNull`1.Equals(`0)">
            <summary>
            Compare encapsulated values for equality.
            </summary>
            <param name="other">The value to compare against.</param>
            <returns>True if values are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.NonNull`1.Equals(Sasa.NonNull{`0})">
            <summary>
            Compare NonNull values for equality.
            </summary>
            <param name="other">The value to compare against.</param>
            <returns>True if values are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.NonNull`1.Equals(System.Object)">
            <summary>
            Compares equality of the encapsulated value and the given value.
            </summary>
            <param name="obj">The value to compare.</param>
            <returns>True if the values are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.NonNull`1.GetHashCode">
            <summary>
            Return the hash code of the encapsulated value.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Sasa.NonNull`1.ToString">
            <summary>
            Returns a string representation of the encapsulated value.
            </summary>
            <returns>Returns a string representation of the encapsulated value.</returns>
        </member>
        <member name="M:Sasa.NonNull`1.op_Equality(Sasa.NonNull{`0},Sasa.NonNull{`0})">
            <summary>
            Compares two NonNull values for equality.
            </summary>
            <param name="left">The first NonNull.</param>
            <param name="right">The second NonNull.</param>
            <returns>Returns true if the NonNulls are equal, and false otherwise.</returns>
        </member>
        <member name="M:Sasa.NonNull`1.op_Inequality(Sasa.NonNull{`0},Sasa.NonNull{`0})">
            <summary>
            Compares two NonNull values for inequality.
            </summary>
            <param name="left">The first NonNull.</param>
            <param name="right">The second NonNull.</param>
            <returns>Returns true if the NonNulls are not equal, and false otherwise.</returns>
        </member>
        <member name="T:Sasa.Lazy`1">
            <summary>
            A thread-safe lazy value.
            </summary>
            <typeparam name="T">The type of the value to be lazily evaluated.</typeparam>
            <remarks>
            This implements <see cref="T:Sasa.IOptional`1"/> since it is temporally optional. In other words, at any given
            time it may or may not have a value.
            
            In principle, there is little difference between a Lazy&lt;T&gt;, a Task&lt;T&gt;/Future&lt;T&gt; and
            a reactive value, React&lt;T&gt;, like that found in the Sasa.Reactive assembly. In fact, the latter
            largely generalizes the semantics of the previous three since you can easily register for notifications
            and construct chained computations ala promise pipelining [1]. As such, Sasa.Lazy&lt;T&gt; may one day
            be replaced by React&lt;T&gt; or something even more general. But it's available in the meantime, it's
            simple, and it's well tested in production environments.
            
            [1] http://en.wikipedia.org/wiki/Futures_and_promises#Promise_pipelining
            </remarks>
        </member>
        <member name="M:Sasa.Lazy`1.#ctor(System.Func{`0})">
            <summary>
            Return a lazily value computed by invoked thunk().
            </summary>
            <param name="thunk">The function used to compute the value when required.</param>
            <remarks>
            <code>
            Lazy&lt;int&gt; x = 3;
            Lazy&lt;int&gt; y = new Lazy&lt;int&gt;(() =&gt;
            {
              Console.WriteLine("Please enter a number:");
              return int.Parse(Console.ReadLine());
            });
            Console.WriteLine(x.HasValue);
            Console.WriteLine(y.HasValue);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Lazy`1.#ctor(`0)">
            <summary>
            Return a resolved lazy value.
            </summary>
            <param name="value">The value to encapsulate in a lazy type.</param>
            <remarks>
            <code>
            Lazy&lt;int&gt; x = 3;
            Lazy&lt;int&gt; y = new Lazy&lt;int&gt;(() =&gt;
            {
              Console.WriteLine("Please enter a number:");
              return int.Parse(Console.ReadLine());
            });
            Console.WriteLine(x.HasValue);
            Console.WriteLine(y.HasValue);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Lazy`1.Value">
            <summary>
            Force evaluation of the value.
            </summary>
            <returns>Returns the computed value.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the lazy computation generated an error.
            </exception>
        </member>
        <member name="P:Sasa.Lazy`1.Error">
            <summary>
            The resulting error, if any.
            </summary>
            <remarks>
            If the result of a computation is an error, this property allows access to that error:
            <code>
            IResult&lt;int&gt; withValue = new Result&lt;int&gt;(3);
            if (withValue.HasValue) Console.WriteLine(withValue.Value);
            
            IResult&lt;int&gt; noValue = Result.Fail&lt;int&gt;(new ArgumentException());
            if (noValue.HasValue)
                Console.WriteLine(noValue.Value);
            else
                Console.WriteLine("Error: {0}", noValue.Error.Message);
            // output:
            // 3
            // Error: ArgumentException ...
            </code>
            This property is thread-safe and accessing it does trigger the lazy computation.
            </remarks>
        </member>
        <member name="P:Sasa.Lazy`1.HasValue">
            <summary>
            True if a valid value has been computed.
            </summary>
            <remarks>
            This property checks the implementation to verify whether a legitimate value is available:
            <code>
            IResolvable&lt;int&gt; withValue = new Option&lt;int&gt;(3);
            if (withValue.HasValue) Console.WriteLine(withValue.Value);
            
            IResolvable&lt;int&gt; noValue = Option&lt;int&gt;.None;
            if (noValue.HasValue) Console.WriteLine(noValue.Value);
            
            // output:
            // 3
            </code>
            This property is thread-safe and accessing it does not force the lazy computation.
            </remarks>
        </member>
        <member name="M:Sasa.Lazy`1.TryGetValue(`0@)">
            <summary>
            Attempts to extract the value.
            </summary>
            <param name="value">The lazy value to extract.</param>
            <returns>Returns true if the lazy value was already forced, false otherwise.</returns>
            <remarks>
            This method is thread-safe. Calling this method does not force the lazy computation.
            
            This property checks the implementation to verify whether a legitimate value
            is available:
            <code>
            IResolvable&lt;int&gt; withValue = new Option&lt;int&gt;(3);
            if (withValue.HasValue) Console.WriteLine(withValue.Value);
            
            IResolvable&lt;int&gt; noValue = Option&lt;int&gt;.None;
            if (noValue.HasValue) Console.WriteLine(noValue.Value);
            
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Lazy`1.Eval">
            <summary>
            Evaluate the thunk.
            </summary>
            <returns>The value returned from the thunk.</returns>
        </member>
        <member name="M:Sasa.Lazy`1.op_Implicit(System.Func{`0})~Sasa.Lazy{`0}">
            <summary>
            Implicitly construct a lazy value from a thunk.
            </summary>
            <param name="thunk">The thunk used to compute the lazy value.</param>
            <returns>A lazily computed value.</returns>
        </member>
        <member name="M:Sasa.Lazy`1.op_Implicit(`0)~Sasa.Lazy{`0}">
            <summary>
            Implicitly convert a value to an initialized lazy value.
            </summary>
            <param name="value">The value to wrap.</param>
            <returns>The lazily computed value.</returns>
        </member>
        <member name="T:Sasa.Lazy">
            <summary>
            Convenience methods for lazy values.
            </summary>
        </member>
        <member name="M:Sasa.Lazy.Create``1(System.Func{``0})">
            <summary>
            Construct a new lazy value.
            </summary>
            <typeparam name="T">The type of the lazy value.</typeparam>
            <param name="make">The function constructing the lazy value.</param>
            <returns>A new lazily initialized value.</returns>
            <remarks>
            This static method is used to construct lazy types, somewhat akin to the constructors:
            <code>
            Lazy&lt;int&gt; x = Lazy.Create(3);
            Lazy&lt;int&gt; y = Lazy.Create(() =&gt;
            {
              Console.WriteLine("Please enter a number:");
              return int.Parse(Console.ReadLine());
            });
            Console.WriteLine(x.HasValue);
            Console.WriteLine(y.HasValue);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Lazy.Create``1(``0)">
            <summary>
            Construct a new lazy value.
            </summary>
            <typeparam name="T">The type of the lazy value.</typeparam>
            <param name="make">The function constructing the lazy value.</param>
            <returns>A new lazily initialized value.</returns>
            <remarks>
            This static method is used to construct lazy types, somewhat akin to the constructors:
            <code>
            Lazy&lt;int&gt; x = Lazy.Create(3);
            Lazy&lt;int&gt; y = Lazy.Create(() =&gt;
            {
              Console.WriteLine("Please enter a number:");
              return int.Parse(Console.ReadLine());
            });
            Console.WriteLine(x.HasValue);
            Console.WriteLine(y.HasValue);
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Option`1">
            <summary>
            Represents a possibly null value.
            </summary>
            <typeparam name="T">The type of the optional value.</typeparam>
            <remarks>
            This is an abstraction to deal with nullable/optional values. Reference types are already nullable, and
            structs have <see cref="T:System.Nullable`1"/>, so why write yet another abstraction to deal with optional values?
            
            The answer is pretty simple: there is no other way to write a function whose GENERIC arguments are clearly
            and plainly optional. This is partially complicated because C# doesn't consider type constraints when
            selecting method overrides, otherwise you could do something like this:
            <code>
            int Foo&lt;T&gt;(T nullable)
              where T : class
            {
                ...
            }
            int Foo&lt;T&gt;(T notNullable)
              where T : struct
            {
                ...
            }
            </code>
            The nullable overload is clear from the type information, but this type information is never used and C#
            complains about ambiguous methods. Technically, you could simply write Foo like so:
            <code>
            int Foo&lt;T&gt;(T possiblyNull)
            {
                if (possiblyNull == null)
                    ...
                else
                    ...
            }
            </code>
            This will work even if you pass in Nullable&lt;int&gt; because a Nullable&lt;int&gt; can be compared to
            null, and so will take the proper branch. However, it's not at all clear from the type signature of Foo
            that possiblyNull is an optional value. So Sasa.Option was created to easily specify this sort of
            contract, and have the contract enforced by the type system:
            <code>
            int Foo&lt;T&gt;(Option&lt;T&gt; possiblyNull)
            {
                if (possiblyNull == null)
                    ...
                else
                    ...
            }
            </code>
            <see cref="T:Sasa.Option`1"/> has safe implicit conversions from T, and comparisons to null are fully defined.
            
            When it comes to high assurance code, you should utilize Option and NonNull types for
            method arguments, to declare which arguments may be null and which must necessarily be
            non-null. The type checker will ensure that values are handled properly within the method,
            and client code will receive the errors when passing in null references for NonNull values.
            </remarks>
        </member>
        <member name="P:Sasa.Option`1.Value">
            <summary>
            The wrapped value.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if it contains no value.</exception>
            <remarks>
            Sasa.Option encapsulates a value that may or may not be there. This property of the <see cref="T:Sasa.Option`1"/>
            struct returns the encapsulated value if it exists, or throws <see cref="T:System.InvalidOperationException"/> if no value exists.
            <code>
            Option&lt;int&gt; someInt = 3;
            Console.WriteLine(someInt.Value);
            Option&lt;int&gt; noInt = null;
            Console.WriteLine(noInt.Value); // throws InvalidOperationException
            // output is:
            // 3
            // throws InvalidOperationException
            </code>
            This property is also required by <see cref="T:Sasa.IValue`1"/>, which <see cref="T:Sasa.Option`1"/> implements.
            </remarks>
        </member>
        <member name="P:Sasa.Option`1.HasValue">
            <summary>
            Check if value exists.
            </summary>
            <returns>True if there is a non-null value, false otherwise..</returns>
            <remarks>
            To check whether an <see cref="T:Sasa.Option`1"/> has a value, just access this property as you would on
            a <see cref="T:System.Nullable`1"/>:
            <code>
            Option&lt;int&gt; someInt = 3;
            Option&lt;int&gt; noInt = null;
            Console.WriteLine(someInt.HasValue);
            Console.WriteLine(noInt.HasValue);
            // output is:
            // true
            // false
            </code>
            This property is also required by the <see cref="T:Sasa.IOptional`1"/>, which <see cref="T:Sasa.Option`1"/>
            implements.
            </remarks>
        </member>
        <member name="P:Sasa.Option`1.None">
            <summary>
            An empty option value.
            </summary>
        </member>
        <member name="M:Sasa.Option`1.#ctor(`0)">
            <summary>
            Construct an optional value.
            </summary>
            <param name="value">The wrapped value.</param>
        </member>
        <member name="M:Sasa.Option`1.Equals(`0)">
            <summary>
            Compares Option&lt;T&gt; and a T for equality.
            </summary>
            <param name="other">The other object to compare to.</param>
            <returns>True if the instances are equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.Equals(Sasa.Option{`0})">
            <summary>
            Compares two Option&lt;T&gt; instances for equality.
            </summary>
            <param name="other">The other object to compare to.</param>
            <returns>True if the instances are equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.Equals(System.Nullable{Sasa.Option{`0}})">
            <summary>
            Compares two objects for equality.
            </summary>
            <param name="other">The other object to compare to.</param>
            <returns>True if the instances are equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.Equals(System.Object)">
            <summary>
            Compares two objects for equality.
            </summary>
            <param name="obj">The other object to compare to.</param>
            <returns>True if the instances are equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.GetHashCode">
            <summary>
            Serves as a hash function for this type.
            </summary>
            <returns>A hash code.</returns>
        </member>
        <member name="M:Sasa.Option`1.TryGetValue(`0@)">
            <summary>
            Attempts to extract the value.
            </summary>
            <param name="value">The value extracted.</param>
            <returns>Returns true if a value was available, false otherwise.</returns>
            <remarks>
            This method permits accessing the encapsulated value without throwing an exception if the value is null:
            <code>
            Option&lt;int&gt; someInt = 3;
            int x;
            if (someInt.TryGetValue(out x))
                Console.WriteLine(x);
            else
                Console.WriteLine("null");
            
            Option&lt;int&gt; noInt = null;
            if (noInt.TryGetValue(out x))
                Console.WriteLine(x);
            else
                Console.WriteLine("null");
                
            // output is:
            // 3
            // null
            </code>
            This method is required by the <see cref="T:Sasa.IVolatile`1"/> interface, which <see cref="T:Sasa.Option`1"/> implements.
            </remarks>
        </member>
        <member name="M:Sasa.Option`1.op_Implicit(`0)~Sasa.Option{`0}">
            <summary>
            An implicit conversion from any value to an optional value.
            </summary>
            <param name="value">The value to be converted.</param>
            <returns>Returns a wrapped optional reference.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_Implicit(Sasa.Result{`0})~Sasa.Option{`0}">
            <summary>
            Implicit convert a <see cref="T:Sasa.Result`1"/> into an <see cref="T:Sasa.Option`1"/>.
            </summary>
            <param name="result">The result to convert.</param>
            <returns>An <see cref="T:Sasa.Option`1"/>.</returns>
        </member>
        <member name="M:Sasa.Option`1.ToString">
            <summary>
            Return a string representation.
            </summary>
            <returns>A string representation of the optional value.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_Equality(Sasa.Option{`0},Sasa.Option{`0})">
            <summary>
            Compares two objects for equality.
            </summary>
            <param name="left">The left comparand.</param>
            <param name="right">The right comparand.</param>
            <returns>True if the instances are equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_Inequality(Sasa.Option{`0},Sasa.Option{`0})">
            <summary>
            Compares two objects for inequality.
            </summary>
            <param name="left">The left comparand.</param>
            <param name="right">The right comparand.</param>
            <returns>True if the instances are not equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_Equality(Sasa.Option{`0},System.Nullable{Sasa.Option{`0}})">
            <summary>
            Compares two objects for equality.
            </summary>
            <param name="left">The left comparand.</param>
            <param name="right">The right comparand.</param>
            <returns>True if the instances are equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_Inequality(Sasa.Option{`0},System.Nullable{Sasa.Option{`0}})">
            <summary>
            Compares two objects for inequality.
            </summary>
            <param name="left">The left comparand.</param>
            <param name="right">The right comparand.</param>
            <returns>True if the instances are not equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_Equality(System.Nullable{Sasa.Option{`0}},Sasa.Option{`0})">
            <summary>
            Compares two objects for equality.
            </summary>
            <param name="left">The left comparand.</param>
            <param name="right">The right comparand.</param>
            <returns>True if the instances are equal.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_Inequality(System.Nullable{Sasa.Option{`0}},Sasa.Option{`0})">
            <summary>
            Compares two objects for inequality.
            </summary>
            <param name="left">The left comparand.</param>
            <param name="right">The right comparand.</param>
            <returns>True if the instances are not equal.</returns>
            <remarks>
            The C# null coalescing operation, ??, is hard-coded to only apply to reference types or <see cref="T:System.Nullable`1"/>.
            However, the short-circuiting logical-or operator can be overridden, and <see cref="T:Sasa.Option`1"/> does so to provide
            option-coalescing:
            <code>
            Option&lt;int&gt; someInt = 3;
            Option&lt;int&gt; noInt = null;
            Console.WriteLine(someInt || 99);
            Console.WriteLine(noInt || 99);
            // output is:
            // 3
            // 99
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option`1.op_BitwiseOr(Sasa.Option{`0},Sasa.Option{`0})">
            <summary>
            Coalesce optional value.
            </summary>
            <param name="left">The optional value to return, if available.</param>
            <param name="right">The value to return if optional value is empty.</param>
            <returns>Returns <paramref name="left"/> if not empty, otherwise returns <paramref name="right"/>.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_True(Sasa.Option{`0})">
            <summary>
            Populated optional values reduce to true.
            </summary>
            <param name="value">The optional value to check.</param>
            <returns>True if the HasValue is true.</returns>
        </member>
        <member name="M:Sasa.Option`1.op_False(Sasa.Option{`0})">
            <summary>
            Unpopulated optional values reduce to false.
            </summary>
            <param name="value">The optional value to check.</param>
            <returns>True if !HasValue.</returns>
        </member>
        <member name="T:Sasa.Option">
            <summary>
            Option operations.
            </summary>
            <remarks>
            This class provides all the LINQ overloads needed to transparently work
            with System.Nullable&lt;T&gt; and Option&lt;&gt; in LINQ computations.
            </remarks>
        </member>
        <member name="M:Sasa.Option.ToOption``1(``0)">
            <summary>
            Construct a new optional value.
            </summary>
            <typeparam name="T">The type of the optional value.</typeparam>
            <param name="value">The value to track.</param>
            <returns>A new option value.</returns>
            <remarks>
            This extension method allows simple conversions to option types, given any value T or any nullable struct value T?:
            <code>
            Option&lt;int&gt; someInt = 3.ToOption();
            Option&lt;int&gt; noInt = new int?().ToOption();
            Console.WriteLine(someInt || 99);
            Console.WriteLine(noInt || 99);
            // output is:
            // 3
            // 99
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.ToOption``1(System.Nullable{``0})">
            <summary>
            Construct a new optional value.
            </summary>
            <typeparam name="T">The type of the optional value.</typeparam>
            <param name="value">A nullable value.</param>
            <returns>A possibly empty option value.</returns>
            <remarks>
            This extension method allows simple conversions to option types, given any value T or any nullable struct value T?:
            <code>
            Option&lt;int&gt; someInt = 3.ToOption();
            Option&lt;int&gt; noInt = new int?().ToOption();
            Console.WriteLine(someInt || 99);
            Console.WriteLine(noInt || 99);
            // output is:
            // 3
            // 99
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.ToNullable``1(Sasa.Option{``0})">
            <summary>
            Construct a Nullable value type given an option type.
            </summary>
            <typeparam name="T">The nullable type.</typeparam>
            <param name="option">The optional value.</param>
            <returns>A new nullable value.</returns>
            <remarks>
            Given any <see cref="T:Sasa.Option`1"/>, where <typeparamref name="T"/> is a value type,
            we can easily convert this to a Nullable&lt;T&gt; type using this extension method:
            <code>
            int? someInt = new Option&lt;T&gt;.ToNullable();
            Console.WriteLine(someInt ?? 99);
            // output is:
            // 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Try``1(System.Func{``0})">
            <summary>
            Execute some code that may return null.
            </summary>
            <typeparam name="T">The possibly-null value.</typeparam>
            <param name="func">The code to execute.</param>
            <returns>An optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This method enables clients to execute some piece of code that  returns a value into an
            <see cref="T:Sasa.Option`1"/>. If the delegate throws an exception, then <see cref="P:Sasa.Option`1.None"/>
            is returned:
            <code>
            Option&lt;int&gt; someInt = Option.Try(() =&gt; 3);
            Option&lt;int&gt; noInt = Option.Try&lt;int&gt;(() =&gt; throw new NotSupportedException());
            Console.WriteLine(someInt);
            Console.WriteLine(noInt);
            // output is:
            // 3
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Try``2(System.Func{``0,``1})">
            <summary>
            Wrap a delegate that may throw exceptions.
            </summary>
            <typeparam name="T0">The argument of the delegate.</typeparam>
            <typeparam name="T1">The return type of the delegate.</typeparam>
            <param name="func">The code to execute.</param>
            <returns>A function that wraps any errors in an optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This method enables clients to execute some piece of code that  returns a value into an
            <see cref="T:Sasa.Option`1"/>. If the delegate throws an exception, then <see cref="P:Sasa.Option`1.None"/>
            is returned:
            <code>
            Option&lt;int&gt; someInt = Option.Try(() =&gt; 3);
            Option&lt;int&gt; noInt = Option.Try&lt;int&gt;(() =&gt; throw new NotSupportedException());
            Console.WriteLine(someInt);
            Console.WriteLine(noInt);
            // output is:
            // 3
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Try``1(System.Action{``0})">
            <summary>
            Wrap a delegate that may throw exceptions.
            </summary>
            <typeparam name="T">The delegate argument type.</typeparam>
            <param name="func">The code to execute.</param>
            <returns>A function that wraps any errors in an optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This method enables clients to execute some piece of code that  returns a value into an
            <see cref="T:Sasa.Option`1"/>. If the delegate throws an exception, then <see cref="P:Sasa.Option`1.None"/>
            is returned:
            <code>
            Option&lt;int&gt; someInt = Option.Try(() =&gt; 3);
            Option&lt;int&gt; noInt = Option.Try&lt;int&gt;(() =&gt; throw new NotSupportedException());
            Console.WriteLine(someInt);
            Console.WriteLine(noInt);
            // output is:
            // 3
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Select``2(Sasa.Option{``0},System.Func{``0,``1})">
            <summary>
            Transforms the embedded value to a new value if it exists, otherwise
            returns None.
            </summary>
            <typeparam name="T0">The type of the optional value.</typeparam>
            <typeparam name="TValue">The type of the returned optional value.</typeparam>
            <param name="option">The optional value.</param>
            <param name="some">The function to apply if <paramref name="option"/> has a value.</param>
            <returns>
            Returns <paramref name="some"/>(<paramref name="option"/>) if <code>o.HasValue</code>
            is true, or <code>new Option(default(R))</code> otherwise.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This extension method implements the LINQ select query pattern on <see cref="T:Sasa.Option`1"/>:
            <code>
            Option&lt;int&gt; someInt = 3;
            Option&lt;int&gt; noInt = null;
            Console.WriteLine(someInt.Select(x =&gt; x &gt; 0));
            Console.WriteLine(noInt.Select(x =&gt; x &gt; 0));
            // output is:
            // true
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Select``2(System.Nullable{``0},System.Func{``0,``1})">
            <summary>
            Transforms the embedded value to a new value if it exists, otherwise
            returns None.
            </summary>
            <typeparam name="T0">The type of the optional value.</typeparam>
            <typeparam name="TValue">The type of the returned optional value.</typeparam>
            <param name="option">The optional value.</param>
            <param name="some">The function to apply if <paramref name="option"/> has a value.</param>
            <returns>
            Returns <paramref name="some"/>(<paramref name="option"/>) if <code>o.HasValue</code>
            is true, or <code>new Option(default(R))</code> otherwise.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This extension method implements the LINQ select query pattern on <see cref="T:System.Nullable`1"/>:
            <code>
            int? someInt = 3;
            int? noInt = null;
            Console.WriteLine(someInt.Select(x =&gt; x &gt; 0));
            Console.WriteLine(noInt.Select(x =&gt; x &gt; 0));
            // output is:
            // true
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``2(Sasa.Option{``0},System.Func{``0,Sasa.Option{``1}})">
            <summary>
            Project an optional value to another optional value.
            </summary>
            <typeparam name="T0">The type of the original value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The original optional instance.</param>
            <param name="selector">The projection function.</param>
            <returns>A new optional value computed from the original.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``2(Sasa.Option{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Project an optional value to another optional value.
            </summary>
            <typeparam name="T0">The type of the original value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The original optional instance.</param>
            <param name="selector">The projection function.</param>
            <returns>A new optional value computed from the original.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``2(System.Nullable{``0},System.Func{``0,Sasa.Option{``1}})">
            <summary>
            Project an optional value to another optional value.
            </summary>
            <typeparam name="T0">The type of the original value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The original optional instance.</param>
            <param name="selector">The projection function.</param>
            <returns>A new optional value computed from the original.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``2(System.Nullable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Project an optional value to another optional value.
            </summary>
            <typeparam name="T0">The type of the original value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The original optional instance.</param>
            <param name="selector">The projection function.</param>
            <returns>A new optional value computed from the original.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``3(Sasa.Option{``0},System.Func{``0,Sasa.Option{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects two optional values to a third value.
            </summary>
            <typeparam name="T0">The type of the first value.</typeparam>
            <typeparam name="T1">The type of the second value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The optional type.</param>
            <param name="selector">The intermediate projection function.</param>
            <param name="result">The final projection function.</param>
            <returns>The returned optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``3(System.Nullable{``0},System.Func{``0,Sasa.Option{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects two optional values to a third value.
            </summary>
            <typeparam name="T0">The type of the first value.</typeparam>
            <typeparam name="T1">The type of the second value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The optional type.</param>
            <param name="selector">The intermediate projection function.</param>
            <param name="result">The final projection function.</param>
            <returns>The returned optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``2(Sasa.Option{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Projects two optional values to a third value.
            </summary>
            <typeparam name="T0">The type of the first value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The optional type.</param>
            <param name="selector">The final projection function.</param>
            <returns>The returned optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``3(Sasa.Option{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects two optional values to a third value.
            </summary>
            <typeparam name="T0">The type of the first value.</typeparam>
            <typeparam name="T1">The type of the second value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The optional type.</param>
            <param name="selector">The intermediate projection function.</param>
            <param name="result">The final projection function.</param>
            <returns>The returned optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``3(Sasa.Option{``0},System.Func{``0,System.Nullable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects two optional values to a third value.
            </summary>
            <typeparam name="T0">The type of the first value.</typeparam>
            <typeparam name="T1">The type of the second value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The optional type.</param>
            <param name="selector">The intermediate projection function.</param>
            <param name="result">The final projection function.</param>
            <returns>The returned optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.SelectMany``3(System.Nullable{``0},System.Func{``0,System.Nullable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects two optional values to a third value.
            </summary>
            <typeparam name="T0">The type of the first value.</typeparam>
            <typeparam name="T1">The type of the second value.</typeparam>
            <typeparam name="TValue">The type of the projected value.</typeparam>
            <param name="option">The optional type.</param>
            <param name="selector">The intermediate projection function.</param>
            <param name="result">The final projection function.</param>
            <returns>The returned optional value.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This implements all permutations of SelectMany with Nullable&lt;T&gt; and Option&lt;T&gt;, which enables
            you to use option values in queries:
            <code>
            var val = from y in new int?(2)
                      from j in 7.ToOption()
                      from x in (y + 2 + j).ToOption()
                      select x;
            Console.WriteLine(val);
            
            var noval = from y in new int?(2)
                        from j in new int?()
                        from x in (y + 2 + j).ToOption()
                        select x;
            Console.WriteLine(noval);
            // output:
            // 11
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Do``1(Sasa.Option{``0},System.Action{``0})">
            <summary>
            Performs the given action on the embedded value if it exists.
            </summary>
            <typeparam name="T">The type of the optional value.</typeparam>
            <param name="option">The optional value.</param>
            <param name="func">The function to apply.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This extension method performs an action specified by a delegate only if the <see cref="T:Sasa.Option`1"/> has a value:
            <code>
            Action&lt;int&gt; print = Console.WriteLine;
            Option&lt;int&gt; someInt = 3;
            Option&lt;int&gt; noInt = null;
            someInt.Do(print);
            noInt.Do(print);
            // output is:
            // 3
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Where``1(System.Nullable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filter out an invalid value based on a predicate.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="value">The nullable value.</param>
            <param name="predicate">The function to apply.</param>
            <returns>An optional value of type <typeparamref name="T"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This extension method implements the LINQ where clause for query patterns on <see cref="T:System.Nullable`1"/>:
            <code>
            Option&lt;int&gt; someInt = 3;
            Option&lt;int&gt; noInt = null;
            Console.WriteLine(someInt.Where(x =&gt; x &gt; 0));
            Console.WriteLine(someInt.Where(x =&gt; x &lt; 0));
            Console.WriteLine(noInt.Where(x =&gt; x == 0));
            // output is:
            // true
            // null
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Where``1(Sasa.Option{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filter out an invalid value based on a predicate.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="value">The nullable value.</param>
            <param name="predicate">The function to apply.</param>
            <returns>An optional value of type <typeparamref name="T"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
            <remarks>
            This extension method implements the LINQ where clause for query patterns on <see cref="T:Sasa.Option`1"/>:
            <code>
            Option&lt;int&gt; someInt = 3;
            Option&lt;int&gt; noInt = null;
            Console.WriteLine(someInt.Where(x =&gt; x &gt; 0));
            Console.WriteLine(someInt.Where(x =&gt; x &lt; 0));
            Console.WriteLine(noInt.Where(x =&gt; x == 0));
            // output is:
            // true
            // null
            // null
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Option.Any``1(System.Nullable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Check a predicate against a nullable value.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="value">The nullable value.</param>
            <param name="predicate">The predicate to check.</param>
            <returns>True if <paramref name="value"/> has a value and the predicate returns true; false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
        </member>
        <member name="M:Sasa.Option.Any``1(Sasa.Option{``0},System.Func{``0,System.Boolean})">
            <summary>
            Check a predicate against a nullable value.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="value">The nullable value.</param>
            <param name="predicate">The predicate to check.</param>
            <returns>True if <paramref name="value"/> has a value and the predicate returns true; false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
        </member>
        <member name="M:Sasa.Option.All``1(System.Nullable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Check a predicate against a nullable value.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="value">The nullable value.</param>
            <param name="predicate">The predicate to check.</param>
            <returns>True if <paramref name="value"/> does not have a value or if the predicate returns true; false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
        </member>
        <member name="M:Sasa.Option.All``1(Sasa.Option{``0},System.Func{``0,System.Boolean})">
            <summary>
            Check a predicate against a nullable value.
            </summary>
            <typeparam name="T">The source type.</typeparam>
            <param name="value">The nullable value.</param>
            <param name="predicate">The predicate to check.</param>
            <returns>True if <paramref name="value"/> does not have a value or if the predicate returns true; false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if an argument is null.</exception>
        </member>
        <member name="M:Sasa.Option.ExceptNull``1(System.Collections.Generic.IEnumerable{Sasa.Option{``0}})">
            <summary>
            Filters a sequence of options into a sequence of non-empty values.
            </summary>
            <typeparam name="T">The type of values.</typeparam>
            <param name="source">The source sequence.</param>
            <returns>A filtered sequence of values.</returns>
        </member>
        <member name="M:Sasa.Option.ExceptNull``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>
            Filters a sequence of options into a sequence of non-empty values.
            </summary>
            <typeparam name="T">The type of values.</typeparam>
            <param name="source">The source sequence.</param>
            <returns>A filtered sequence of values.</returns>
        </member>
        <member name="T:Sasa.Pair`2">
            <summary>
            A 2-element tuple type.
            </summary>
            <typeparam name="T0">Type of Pair.First.</typeparam>
            <typeparam name="T1">Type of Pair.Second.</typeparam>
            <remarks>
            It's common to return multiple values from functions, and there are two common ways to
            do so in .NET: out parameters, and ordinary objects like structs and classes.
            
            Unfortunately, defining a whole class just to return two or three values is often overkill. Also,
            out parameters have some limitations, like inability to use them in lambdas, even when it's safe
            to do so.
            
            Enter tuples, which are types containing only generic parameters whose only purpose is to group
            some items together to address these difficulties. Sasa's ITuple interfaces define the abstract
            contracts satisfied by Sasa's tuple types.
            
            However, unlike .NET's newly released tuples, Sasa's implementation tuples don't use the "tuple"
            name. They are instead split into <see cref="T:Sasa.Pair`2"/>, <see cref="T:Sasa.Triple`3"/> and
            <see cref="T:Sasa.Quad`4"/> because I found the shared "tuple" name often confusing when
            auditing code. Particularly where nested generics are concerned, like enumerable sequences of
            tuples, it's often hard to distinguish Tuple&lt;string,int,int&gt;
            from Tuple&lt;string,int,int,int&gt; while refactoring.
            </remarks>
        </member>
        <member name="M:Sasa.Pair`2.#ctor(`0,`1)">
            <summary>
            Construct a new Pair.
            </summary>
            <param name="first">Value of the first element.</param>
            <param name="second">Value of the second element.</param>
        </member>
        <member name="P:Sasa.Pair`2.First">
            <summary>
            First element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the first item in a pair:
            <code>
            var x = Tuples.Create(3, "foo");
            Console.WriteLine(x.First);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Pair`2.Second">
            <summary>
            Second element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the second item in a pair:
            <code>
            var x = Tuples.Create(3, "foo");
            Console.WriteLine(x.Second);
            // output:
            // foo
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Pair`2.Bind(`0@,`1@)">
            <summary>
            Bind all tuple elements to locals.
            </summary>
            <param name="first">The first value.</param>
            <param name="second">The second value.</param>
            <remarks>
            This method extracts all of a Pair's values in one step using "out" parameters.
            So even if you prefer out parameters to tuples, you can easily use an interface
            that uses Sasa's tuples:
            <code>
            int i;
            string foo;
            Tuples.Create(3, "foo")
                  .Bind(out i, out foo);
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Pair`2.ToKeyValue">
            <summary>
            Convert a Pair to a KeyValuePair.
            </summary>
            <returns>A KeyValuePair, where Key=First, Value=Second.</returns>
            <remarks>
            This method converts a Pair into a <see cref="T:System.Collections.Generic.KeyValuePair`2"/>:
            <code>
            var dict = new Dictionary&lt;int, string&gt;();
            dict.Add(Tuples.Create(3, "foo").ToKeyValue());
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Pair`2.Equals(Sasa.Pair{`0,`1})">
            <summary>
            Test Pair equality element-wise.
            </summary>
            <param name="other"></param>
            <returns>True if the pairs are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Pair`2.Equals(System.Object)">
            <summary>
            Test equality.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True if the objects are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Pair`2.GetHashCode">
            <summary>
            Compute hash code.
            </summary>
            <returns>Hash code for the encapsulated values.</returns>
        </member>
        <member name="M:Sasa.Pair`2.CompareTo(Sasa.Pair{`0,`1})">
            <summary>
            Compare the two values, Pair.First first, then Pair.Second if Pair.First are equal.
            </summary>
            <param name="other">The Pair to compare against.</param>
            <returns>
            Returns zero if the pairs are equal element-wise, returns a number greater than zero if
            the current pair is greater than <paramref name="other"/> element-wise, else returns a
            number greater than zero.
            </returns>
        </member>
        <member name="M:Sasa.Pair`2.ToString">
            <summary>
            Return a string representation of this Pair.
            </summary>
            <returns>A string representation of this Pair.</returns>
        </member>
        <member name="M:Sasa.Pair`2.op_Implicit(Sasa.Pair{`0,`1})~System.Collections.Generic.KeyValuePair{`0,`1}">
            <summary>
            Implicitly convert Pair to KeyValuePair.
            </summary>
            <param name="pair">The Pair to convert.</param>
            <returns>A KeyValuePair, where Key=First, Value=Second.</returns>
        </member>
        <member name="M:Sasa.Pair`2.op_Implicit(System.Collections.Generic.KeyValuePair{`0,`1})~Sasa.Pair{`0,`1}">
            <summary>
            Implicitly convert KeyValuePair to Pair.
            </summary>
            <param name="pair">The KeyValuePair to convert.</param>
            <returns>A new Pair instance, where First=Key, and Second=Value.</returns>
        </member>
        <member name="M:Sasa.Pair`2.op_Equality(Sasa.Pair{`0,`1},Sasa.Pair{`0,`1})">
            <summary>
            Compares two Pairs for equality.
            </summary>
            <param name="left">The first Pair.</param>
            <param name="right">The second Pair.</param>
            <returns>True if the Pairs are equal, and false otherwise.</returns>
        </member>
        <member name="M:Sasa.Pair`2.op_Inequality(Sasa.Pair{`0,`1},Sasa.Pair{`0,`1})">
            <summary>
            Compares two Pairs for inequality.
            </summary>
            <param name="left">The first Pair.</param>
            <param name="right">The second Pair.</param>
            <returns>True if the Pairs are not equal, and false otherwise.</returns>
        </member>
        <member name="M:Sasa.Pair`2.op_LessThan(Sasa.Pair{`0,`1},Sasa.Pair{`0,`1})">
            <summary>
            Orders two pairs.
            </summary>
            <param name="left">The first Pair.</param>
            <param name="right">The second Pair.</param>
            <returns>
            True if <paramref name="left"/> is less than <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Pair`2.op_GreaterThan(Sasa.Pair{`0,`1},Sasa.Pair{`0,`1})">
            <summary>
            Orders two pairs.
            </summary>
            <param name="left">The first Pair.</param>
            <param name="right">The second Pair.</param>
            <returns>
            True if <paramref name="left"/> is greater than <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Pair`2.op_LessThanOrEqual(Sasa.Pair{`0,`1},Sasa.Pair{`0,`1})">
            <summary>
            Orders two pairs.
            </summary>
            <param name="left">The first Pair.</param>
            <param name="right">The second Pair.</param>
            <returns>
            True if <paramref name="left"/> is less than or equal to <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Pair`2.op_GreaterThanOrEqual(Sasa.Pair{`0,`1},Sasa.Pair{`0,`1})">
            <summary>
            Orders two pairs.
            </summary>
            <param name="left">The first Pair.</param>
            <param name="right">The second Pair.</param>
            <returns>
            True if <paramref name="left"/> is greater than or equal to <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="T:Sasa.Quad`4">
            <summary>
            A 4-element tuple type.
            </summary>
            <typeparam name="T0">The type of the first value.</typeparam>
            <typeparam name="T1">The type of the second value.</typeparam>
            <typeparam name="T2">The type of the third value.</typeparam>
            <typeparam name="T3">The type of the fourth value.</typeparam>
            <remarks>
            It's common to return multiple values from functions, and there are two common ways to
            do so in .NET: out parameters, and ordinary objects like structs and classes.
            
            Unfortunately, defining a whole class just to return two or three values is often overkill. Also,
            out parameters have some limitations, like inability to use them in lambdas, even when it's safe
            to do so.
            
            Enter tuples, which are types containing only generic parameters whose only purpose is to group
            some items together to address these difficulties. Sasa's ITuple interfaces define the abstract
            contracts satisfied by Sasa's tuple types.
            
            However, unlike .NET's newly released tuples, Sasa's implementation tuples don't use the "tuple"
            name. They are instead split into <see cref="T:Sasa.Pair`2"/>, <see cref="T:Sasa.Triple`3"/> and
            <see cref="T:Sasa.Quad`4"/> because I found the shared "tuple" name often confusing when
            auditing code. Particularly where nested generics are concerned, like enumerable sequences of
            tuples, it's often hard to distinguish Tuple&lt;string,int,int&gt;
            from Tuple&lt;string,int,int,int&gt; while refactoring.
            </remarks>
        </member>
        <member name="M:Sasa.Quad`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Construct a new Quad.
            </summary>
            <param name="first">The first value.</param>
            <param name="second">The second value.</param>
            <param name="third">The third value.</param>
            <param name="fourth">The fourth value.</param>
        </member>
        <member name="P:Sasa.Quad`4.First">
            <summary>
            First element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the first item in a quad:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M, "hello world!");
            Console.WriteLine(x.First);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Quad`4.Second">
            <summary>
            Second element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the fourth item in a quad:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M, "hello world!");
            Console.WriteLine(x.Second);
            // output:
            // foo
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Quad`4.Third">
            <summary>
            Third element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the third item in a quad:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M, "hello world!");
            Console.WriteLine(x.Third);
            // output:
            // 123.4
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Quad`4.Fourth">
            <summary>
            Fourth element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the fourth item in a quad:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M, "hello world!");
            Console.WriteLine(x.Fourth);
            // output:
            // hello world!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Quad`4.Bind(`0@,`1@,`2@,`3@)">
            <summary>
            Bind all tuple elements to locals.
            </summary>
            <param name="first">The first value.</param>
            <param name="second">The second value.</param>
            <param name="third">The third value.</param>
            <param name="fourth">The fourth value.</param>
            <remarks>
            This method extracts all of a Quad's values in one step using "out" parameters.
            So even if you prefer out parameters to tuples, you can easily use an interface
            that uses Sasa's tuples:
            <code>
            int i;
            string foo;
            decimal d;
            Tuples.Create(3, "foo", 123.4M)
                  .Bind(out i, out foo, out d);
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Quad`4.Equals(Sasa.Quad{`0,`1,`2,`3})">
            <summary>
            Test equality of Quads element-wise.
            </summary>
            <param name="other">The other Quad to compare for equality.</param>
            <returns>True if the Quad instances match, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Quad`4.Equals(System.Object)">
            <summary>
            Test equality.
            </summary>
            <param name="obj">Object to compare for equality.</param>
            <returns>True if the objects match, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Quad`4.GetHashCode">
            <summary>
            Generate a hash code.
            </summary>
            <returns>The hash of the encapsulated values.</returns>
        </member>
        <member name="M:Sasa.Quad`4.CompareTo(Sasa.Quad{`0,`1,`2,`3})">
            <summary>
            Compare the two values, testing sequentially, Quad.First, Quad.Second
            Quad.Third, and Quad.Fourth for any values that can specify an 
            ordering.
            </summary>
            <param name="other">The Quad to compare against.</param>
            <returns>The ordering compares sequentially Quad.First, Quad.Second,
            Quad.Third and Quad.Fourth until it finds an entry that ensures an
            total order.</returns>
        </member>
        <member name="M:Sasa.Quad`4.ToString">
            <summary>
            Return a string representation of this Quad.
            </summary>
            <returns>A string representation of this Quad.</returns>
        </member>
        <member name="M:Sasa.Quad`4.op_Equality(Sasa.Quad{`0,`1,`2,`3},Sasa.Quad{`0,`1,`2,`3})">
            <summary>
            Compares two Quads for equality.
            </summary>
            <param name="left">The first Quad.</param>
            <param name="right">The second Quad.</param>
            <returns>Returns true if the Quads are equal, and false otherwise.</returns>
        </member>
        <member name="M:Sasa.Quad`4.op_Inequality(Sasa.Quad{`0,`1,`2,`3},Sasa.Quad{`0,`1,`2,`3})">
            <summary>
            Compares two Quads for inequality.
            </summary>
            <param name="left">The first Quad.</param>
            <param name="right">The second Quad.</param>
            <returns>Returns true if the Quads are not equal, and false otherwise.</returns>
        </member>
        <member name="M:Sasa.Quad`4.op_LessThan(Sasa.Quad{`0,`1,`2,`3},Sasa.Quad{`0,`1,`2,`3})">
            <summary>
            Orders two pairs.
            </summary>
            <param name="left">The first tuple.</param>
            <param name="right">The second tuple.</param>
            <returns>
            True if <paramref name="left"/> is less than <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Quad`4.op_GreaterThan(Sasa.Quad{`0,`1,`2,`3},Sasa.Quad{`0,`1,`2,`3})">
            <summary>
            Orders two tuples.
            </summary>
            <param name="left">The first tuple.</param>
            <param name="right">The second tuple.</param>
            <returns>
            True if <paramref name="left"/> is greater than <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Quad`4.op_LessThanOrEqual(Sasa.Quad{`0,`1,`2,`3},Sasa.Quad{`0,`1,`2,`3})">
            <summary>
            Orders two pairs.
            </summary>
            <param name="left">The first tuple.</param>
            <param name="right">The second tuple.</param>
            <returns>
            True if <paramref name="left"/> is less than or equal to <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Quad`4.op_GreaterThanOrEqual(Sasa.Quad{`0,`1,`2,`3},Sasa.Quad{`0,`1,`2,`3})">
            <summary>
            Orders two tuples.
            </summary>
            <param name="left">The first tuple.</param>
            <param name="right">The second tuple.</param>
            <returns>
            True if <paramref name="left"/> is greater than or equal to <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="T:Sasa.Strings">
            <summary>
            String extension methods.
            </summary>
        </member>
        <member name="M:Sasa.Strings.IsNullOrEmpty(System.String)">
            <summary>
            Returns true if string is null or empty.
            </summary>
            <param name="input">The string to test.</param>
            <returns>True if the string is null or of length 0.</returns>
            <remarks>
            This is a convenient extension method that simply calls string.IsNullOrEmpty:
            <code>
            string[] list = new string[] { null, "", "foo!" };
            foreach(var x in list)
            {
                if (!x.IsNullOrEmpty())
                    Console.WriteLine(x);
            }
            // output:
            // foo!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.IsNullOrWhiteSpace(System.String)">
            <summary>
            Returns true if string is null or whitespace.
            </summary>
            <param name="input">The string to test.</param>
            <returns>True if the string is null or consists only of whitespace.</returns>
            <remarks>
            This is a convenient extension method that simply calls string.IsNullOrWhitespace:
            <code>
            string[] list = new string[] { null, "foo!", "  " };
            foreach(var x in list)
            {
                if (!x.IsNullOrWhitespace())
                    Console.WriteLine(x);
            }
            // output:
            // foo!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.IsNullOrWhiteSpace(System.String,System.Int32,System.Int32)">
            <summary>
            Returns true if string is null, empty or has only whitespace in the specified range.
            </summary>
            <param name="input">The string to test.</param>
            <param name="index">The index at which to start the search.</param>
            <param name="count">The number of characters to compare.</param>
            <returns>True if the string is null or consists only of whitespace.</returns>
            <remarks>
            This is a convenient extension method that simply calls string.IsNullOrWhitespace:
            <code>
            string[] list = new string[] { null, "foo!", "  " };
            foreach(var x in list)
            {
                if (!x.IsNullOrWhitespace())
                    Console.WriteLine(x);
            }
            // output:
            // foo!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.IfNullOrEmpty(System.String,System.String)">
            <summary>
            Ensures returned string is not null or empty.
            </summary>
            <param name="input">The string to test.</param>
            <param name="otherwise">The string to return if <paramref name="input"/> is null or empty.</param>
            <returns>Returns the string if the not null or of length 0, or 'otherwise' otherwise.</returns>
            <remarks>
            This extension method allows you to return a string or other type of input if the input string is null or empty:
            <code>
            string[] list = new string[] { null, "", "foo!" };
            foreach(var x in list)
            {
                Console.WriteLine(x.IfNullOrEmpty("null or empty!"));
            }
            // output:
            // null or empty!
            // null or empty!
            // foo!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.IfNullOrEmpty``1(System.String,``0)">
            <summary>
            Ensures returned string is not null or empty.
            </summary>
            <param name="input">The string to test.</param>
            <param name="otherwise">The object to return if <paramref name="input"/> is null or empty.</param>
            <returns>Returns the string if the not null or of length 0, or 'otherwise' otherwise.</returns>
            <remarks>
            This extension method allows you to return a string or other type of input if the input string is null or empty.
            This overload with the generic type parameter simply calls ToString() on its argument. It was added simply
            to avoid the overhead of calling ToString on the second argument before knowing whether the first
            string was empty:
            <code>
            string[] list = new string[] { null, "", "foo!" };
            foreach(var x in list)
            {
                Console.WriteLine(x.IfNullOrEmpty(3.4));
            }
            // output:
            // 3.4
            // 3.4
            // foo!
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Slice(System.String,System.Int32,System.Int32)">
            <summary>
            Return a slice of a string delineated by the start and end indices.
            </summary>
            <param name="value">The string to slice.</param>
            <param name="start">The start of the slice.</param>
            <param name="end">The end of the slice.</param>
            <returns>The string slice.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method complements <see cref="M:System.String.Substring(System.Int32,System.Int32)"/>. Substring
            takes an index and the number of characters to extract, where Slice takes two indices,
            thus making it easier to write certain kinds of string processing algorithms:
            <code>
            string large = "This is a sample sentence.";
            string firstWord = large.Slice(0, 4);
            Console.WriteLine(firstWord);
            // output:
            // This
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.WordWrapAt(System.String,System.Int32)">
            <summary>
            Wraps the string at the given column index.
            </summary>
            <param name="input">The string to process.</param>
            <param name="column">The column at which to wrap the string.</param>
            <returns>A stream of strings representing the wrapped lines. String.Length is &lt;= column.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method that inserts newlines at the whitespace boundary nearest but
            less than the provided column parameter. In other words, contrary to Strings.HardWrapAt
            which inserts the newline at the specified index, this method searches back for the
            nearest whitespace boundary less than the column boundary:
            <code>
            string text = "Lorem ipsum dolor sit amet, consectetur";
            foreach (var line in text.WordWrapAt(8))
            {
                Console.WriteLine(line);
            }
            // output:
            // Lorem
            //  ipsum
            //  dolor
            //  sit
            //  amet,
            //  consectetur
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.HardWrapAt(System.String,System.Int32)">
            <summary>
            Wraps the string at the given column index.
            </summary>
            <param name="input">The string to process.</param>
            <param name="column">The column at which to wrap the string.</param>
            <returns>A stream of strings representing the wrapped lines. String.Length is &lt;= column.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method inserts new lines directly at the index specified in a function parameter,
            without regard to words or other considerations, and returns an enumerable sequence of lines:
            <code>
            string text = "Lorem ipsum dolor sit amet, consectetur";
            foreach (var line in text.HardWrapAt(8))
            {
                Console.WriteLine(line);
            }
            // output:
            // Lorem ip
            // sum dolo
            // r sit am
            // et, cons
            // ectetur
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.HardWrapAt(System.String,System.Int32,System.StringSplitOptions)">
            <summary>
            Wraps the string at the given column index.
            </summary>
            <param name="input">The string to process.</param>
            <param name="column">The column at which to wrap the string.</param>
            <param name="options">The split options to use when returning lines.</param>
            <returns>A stream of strings representing the wrapped lines. String.Length is &lt;= column.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method inserts new lines directly at the index specified in a function parameter,
            without regard to words or other considerations, and returns an enumerable sequence of lines:
            <code>
            string text = "Lorem ipsum dolor sit amet, consectetur";
            foreach (var line in text.HardWrapAt(8))
            {
                Console.WriteLine(line);
            }
            // output:
            // Lorem ip
            // sum dolo
            // r sit am
            // et, cons
            // ectetur
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Lines(System.String)">
            <summary>
            Returns the string split into individual lines.
            </summary>
            <param name="input">The string to split.</param>
            <returns>An array of all the lines in the string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method splits a string into a sequence of lines:
            <code>
            var lines = "foo\r\n \t bar\r\n\r\nend".Lines();
            foreach (var x in lines)
            {
                Console.WriteLine(x);
            }
            // output:
            // foo
            //  	 bar
            // end
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Lines(System.String,System.StringSplitOptions)">
            <summary>
            Returns the string split into individual lines.
            </summary>
            <param name="input">The string to split.</param>
            <param name="options">The options to use when creating lines.</param>
            <returns>An array of all the lines in the string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method splits a string into a sequence of lines:
            <code>
            var lines = "foo\r\n \t bar\r\n\r\nend".Lines();
            foreach (var x in lines)
            {
                Console.WriteLine(x);
            }
            // output:
            // foo
            //  	 bar
            // end
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Words(System.String)">
            <summary>
            Split a string along whitespace boundaries.
            </summary>
            <param name="input">The string to split.</param>
            <returns>An array of strings which were separate by whitespace in the original string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method that splits a string along whitespace boundaries:
            <code>
            string words = "foo bar\r\n\tbaz\rfoobar\nbarbaz".Words();
            foreach (var x in words)
            {
                Console.WriteLine(x);
            }
            // output:
            // foo
            // bar
            // baz
            // foobar
            // barbaz
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.ToBase64(System.String,System.String)">
            <summary>
            Convert a string to Base64.
            </summary>
            <param name="input">The string to convert.</param>
            <param name="encoding">The string encoding to use.</param>
            <returns>The Base64-encoded string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a convenient extension method for converting a Unicode string into a Base64 encoded
            string, using an optional text encoding parameter. If no encoding provided, UTF-8 is the
            default:
            <code>
            string encoded = "foo bar".ToBase64(); // utf-8
            Console.WriteLine(encoded);
            string decoded = encoded.FromBase64(encoded);
            Console.WriteLine(decoded);
            Console.WriteLine(decoded.ToBase64("utf-16"));
            // output:
            // Zm9vIGJhcg==
            // foo bar
            // ZgBvAG8AIABiAGEAcgA=
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.ToBase64(System.String)">
            <summary>
            Convert a string to Base64.
            </summary>
            <param name="input">The string to convert.</param>
            <returns>The Base64-encoded string in UTF-8 encoding.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a convenient extension method for converting a Unicode string into a Base64 encoded
            string, using an optional text encoding parameter. If no encoding provided, UTF-8 is the
            default:
            <code>
            string encoded = "foo bar".ToBase64(); // utf-8
            Console.WriteLine(encoded);
            string decoded = encoded.FromBase64(encoded);
            Console.WriteLine(decoded);
            Console.WriteLine(decoded.ToBase64("utf-16"));
            // output:
            // Zm9vIGJhcg==
            // foo bar
            // ZgBvAG8AIABiAGEAcgA=
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.FromBase64(System.String,System.String)">
            <summary>
            Convert a string from a Base64 encoded string to another string.
            </summary>
            <param name="input">The string the convert.</param>
            <param name="encoding">The string encoding to use.</param>
            <returns>The unencoded string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a convenient extension method for converting a Base64 encoded string into an ordinary
            Unicode string, with an optional encoding parameter used to interpret the data:
            <code>
            string encoded = "foo bar".ToBase64(); // utf-8
            Console.WriteLine(encoded);
            string decoded = encoded.FromBase64(encoded);
            Console.WriteLine(decoded);
            Console.WriteLine(decoded.ToBase64("utf-16"));
            // output:
            // Zm9vIGJhcg==
            // foo bar
            // ZgBvAG8AIABiAGEAcgA=
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.FromBase64(System.String)">
            <summary>
            Convert a string from a Base64 encoded string to another string using UTF-8 encoding.
            </summary>
            <param name="input">The string the convert.</param>
            <returns>The decoded string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a convenient extension method for converting a Base64 encoded string into an ordinary
            Unicode string, with an optional encoding parameter used to interpret the data:
            <code>
            string encoded = "foo bar".ToBase64(); // utf-8
            Console.WriteLine(encoded);
            string decoded = encoded.FromBase64(encoded);
            Console.WriteLine(decoded);
            Console.WriteLine(decoded.ToBase64("utf-16"));
            // output:
            // Zm9vIGJhcg==
            // foo bar
            // ZgBvAG8AIABiAGEAcgA=
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Split(System.String,System.StringSplitOptions,System.Char[])">
            <summary>
            Split the string according to the given options and delimiters.
            </summary>
            <param name="input">The input string.</param>
            <param name="options">The options to use when splitting the string.</param>
            <param name="delimiter">The delimiters used to split the string.</param>
            <returns>The split string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method wraps the <see cref="M:System.String.Split(System.Char[],System.StringSplitOptions)"/>
            overload that accepts <see cref="T:System.StringSplitOptions"/>:
            <code>
            string var csv = "foo,comma,bar,,baz";
            foreach (var x in csv.Split(StringSplitOptions.RemoveEmptyEntries, ','))
            {
                Console.WriteLine(x);
            }
            // output:
            // foo
            // comma
            // bar
            // baz
            </code>
            This overload takes a variable length list of characters to use for splitting,
            basically reversing the order in the base class libraries for convenience.
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Split(System.String,System.StringSplitOptions,System.String[])">
            <summary>
            Split the string according to the given options and delimiters.
            </summary>
            <param name="input">The input string.</param>
            <param name="options">The options to use when splitting the string.</param>
            <param name="delimiter">The delimiters used to split the string.</param>
            <returns>The split string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method wraps the <see cref="M:System.String.Split(System.String[],System.StringSplitOptions)"/>
            overload that accepts <see cref="T:System.StringSplitOptions"/>:
            <code>
            string var csv = "foo,comma,bar,,baz";
            foreach (var x in csv.Split(StringSplitOptions.RemoveEmptyEntries, ","))
            {
                Console.WriteLine(x);
            }
            // output:
            // foo
            // comma
            // bar
            // baz
            </code>
            This overload takes a variable length list of strings to use for splitting,
            basically reversing the order in the base class libraries for convenience.
            </remarks>
        </member>
        <member name="M:Sasa.Strings.SliceEquals(System.String,System.Int32,System.String)">
            <summary>
            Checks the value of a substring.
            </summary>
            <param name="value">The string to inspect.</param>
            <param name="start">The index at which to check for the substring.</param>
            <param name="sub">The string to use for comparison.</param>
            <returns>True if string <paramref name="sub"/> is found at <paramref name="value"/>[<paramref name="start"/>].</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method takes an input string, an index, and a substring and checks whether the substring
            is in the input string at the given index:
            <code>
            string[] list = new string[] { "Flub", "Foo", "Baz_Foob", "Bar Foo!" };
            foreach(var x in list)
            {
                Console.WriteLine(x.SliceEquals(4, "Foo"));
            }
            // output:
            // false
            // false
            // true
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.SliceEquals(System.String,System.Int32,System.String,System.StringComparison)">
            <summary>
            Checks the value of a substring.
            </summary>
            <param name="value">The string to inspect.</param>
            <param name="start">The index at which to check for the substring.</param>
            <param name="sub">The string to use for comparison.</param>
            <param name="comparisonType">The type of comparison to perform.</param>
            <returns>True if string <paramref name="sub"/> is found at <paramref name="value"/>[<paramref name="start"/>].</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method takes an input string, an index, and a substring and checks whether the substring
            is in the input string at the given index:
            <code>
            string[] list = new string[] { "Flub", "Foo", "Baz_Foob", "Bar Foo!" };
            foreach(var x in list)
            {
                Console.WriteLine(x.SliceEquals(4, "Foo", StringComparison.Ordinal));
            }
            // output:
            // false
            // false
            // true
            // true
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Strings.Token">
            <summary>
            Tokens identified by the Tokenize function.
            </summary>
        </member>
        <member name="P:Sasa.Strings.Token.Index">
            <summary>
            The index marking the beginning of the token.
            </summary>
        </member>
        <member name="P:Sasa.Strings.Token.Tok">
            <summary>
            The token identified.
            </summary>
        </member>
        <member name="M:Sasa.Strings.Token.Equals(Sasa.Strings.Token)">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="other">The object to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Strings.Token.Equals(System.Object)">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Strings.Token.GetHashCode">
            <summary>
            Computes the hash code for the object.
            </summary>
            <returns>The integer hash code.</returns>
        </member>
        <member name="M:Sasa.Strings.Token.ToString">
            <summary>
            Generate a string representation.
            </summary>
            <returns>A string representation.</returns>
        </member>
        <member name="M:Sasa.Strings.Token.op_Equality(Sasa.Strings.Token,Sasa.Strings.Token)">
            <summary>
            Compares struct for equality.
            </summary>
            <param name="left">The left object to compare.</param>
            <param name="right">The right object to compare.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Strings.Token.op_Inequality(Sasa.Strings.Token,Sasa.Strings.Token)">
            <summary>
            Compares struct for inequality.
            </summary>
            <param name="left">The left object to compare.</param>
            <param name="right">The right object to compare.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Strings.Tokenize(System.String,System.String[])">
            <summary>
            Searches the input stream for a set of tokens.
            </summary>
            <param name="input">The input string to search.</param>
            <param name="tokens">The list of tokens to search for.</param>
            <returns>A stream of tokens.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method that searches an input string for a list of string tokens, and
            returns a sequence of token positions found in the string:
            <code>
            var operators = "4 + 5 - 6^2 == x".Tokenize("+", "-", "^", "==");
            foreach (var x in operators)
            {
                Console.WriteLine("Found {0} at index {1}", x.Tok, x.Index);
            }
            // output:
            // Found + at index 2
            // Found - at index 6
            // Found ^ at index 9
            // Found == at index 12
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Tokenize(System.String,System.StringComparison,System.String[])">
            <summary>
            Searches the input stream for a set of tokens.
            </summary>
            <param name="input">The input string to search.</param>
            <param name="comparisonType">The type of string comparison to perform while tokenizing.</param>
            <param name="tokens">The list of tokens to search for.</param>
            <returns>A stream of tokens.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method that searches an input string for a list of string tokens, and
            returns a sequence of token positions found in the string:
            <code>
            var operators = "4 + 5 - 6^2 == x".Tokenize("+", "-", "^", "==");
            foreach (var x in operators)
            {
                Console.WriteLine("Found {0} at index {1}", x.Tok, x.Index);
            }
            // output:
            // Found + at index 2
            // Found - at index 6
            // Found ^ at index 9
            // Found == at index 12
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Format(System.String,System.Object[])">
            <summary>
            Generate a formatted string.
            </summary>
            <param name="pattern">The format string.</param>
            <param name="substitutions">The format string substitutions.</param>
            <returns>A formatted string generated by substituting the values in <paramref name="substitutions"/> into <paramref name="pattern"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method wraps <see cref="M:System.String.Format(System.String,System.Object[])"/>:
            <code>
            Console.WriteLine("i = {0}".Format(1234567));
            
            string invariant = "{0:#,##0.00}".Format(CultureInfo.InvariantCulture,
                                                     10000);
            Console.WriteLine(invariant);
            
            string de = "{0:#,##0.00}".Format(CultureInfo.GetCultureInfo("de-de"),
                                              10000);
            Console.WriteLine(de);
            // output:
            // i = 1234567
            // 10,000.00
            // 10.000,00
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.Format(System.String,System.IFormatProvider,System.Object[])">
            <summary>
            Generate a formatted string.
            </summary>
            <param name="provider">The format provider.</param>
            <param name="pattern">The format string.</param>
            <param name="substitutions">The format string substitutions.</param>
            <returns>A formatted string generated by substituting the values in <paramref name="substitutions"/> into <paramref name="pattern"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method wraps <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>:
            <code>
            Console.WriteLine("i = {0}".Format(1234567));
            
            string invariant = "{0:#,##0.00}".Format(CultureInfo.InvariantCulture,
                                                     10000);
            Console.WriteLine(invariant);
            
            string de = "{0:#,##0.00}".Format(CultureInfo.GetCultureInfo("de-de"),
                                              10000);
            Console.WriteLine(de);
            // output:
            // i = 1234567
            // 10,000.00
            // 10.000,00
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Strings.RemoveLast(System.Text.StringBuilder,System.Int32)">
            <summary>
            Remove <paramref name="count"/> characters from the end.
            </summary>
            <param name="builder">The <see cref="T:System.Text.StringBuilder"/> instance to modify.</param>
            <param name="count">The number of characters to remove.</param>
            <returns>The modified <see cref="T:System.Text.StringBuilder"/>.</returns>
        </member>
        <member name="M:Sasa.Strings.SplitSubstring(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            A string split and substring operation combined into one.
            </summary>
            <param name="input">The input string.</param>
            <param name="search">The substring to search.</param>
            <param name="start">The index of the input at which to start the search.</param>
            <param name="count">The number of characters to search.</param>
            <returns>
            A sequence of substrings that are separated by <paramref name="search"/> in the input,
            bounded by <paramref name="start"/> and <paramref name="count"/>.
            </returns>
        </member>
        <member name="T:Sasa.Empty">
            <summary>
            An empty/void value.
            </summary>
        </member>
        <member name="M:Sasa.Empty.Equals(System.Object)">
            <summary>
            Equality test for Empty.
            </summary>
            <param name="obj">Object to compare.</param>
            <returns>Returns true of <paramref name="obj"/> is Void, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Empty.Equals(Sasa.Empty)">
            <summary>
            Equality test for Empty.
            </summary>
            <param name="other">Object to compare.</param>
            <returns>Returns true.</returns>
        </member>
        <member name="M:Sasa.Empty.GetHashCode">
            <summary>
            Returns the hash code for a Void value.
            </summary>
            <returns>Hash code for Void.</returns>
        </member>
        <member name="M:Sasa.Empty.ToString">
            <summary>
            Convert Void to a string.
            </summary>
            <returns>Returns a string representation of a Unit value.</returns>
        </member>
        <member name="M:Sasa.Empty.op_Equality(Sasa.Empty,Sasa.Empty)">
            <summary>
            Equality on two voids is always true.
            </summary>
            <param name="left">Left hand side.</param>
            <param name="right">Right hand side.</param>
            <returns>Returns true.</returns>
        </member>
        <member name="M:Sasa.Empty.op_Inequality(Sasa.Empty,Sasa.Empty)">
            <summary>
            Inequality on two voids is always false.
            </summary>
            <param name="left">Left hand side.</param>
            <param name="right">Right hand side.</param>
            <returns>Returns false.</returns>
        </member>
        <member name="T:Sasa.Tokenizer">
            <summary>
            A class that encapsulates a simple tokenization scheme.
            </summary>
        </member>
        <member name="M:Sasa.Tokenizer.#ctor(System.String[])">
            <summary>
            Construct a new tokenizer.
            </summary>
            <param name="tokens">The list of tokens to search for.</param>
        </member>
        <member name="M:Sasa.Tokenizer.#ctor(System.StringComparison,System.String[])">
            <summary>
            Construct a new tokenizer.
            </summary>
            <param name="comparisonType">The types of string comparison.</param>
            <param name="tokens">The list of tokens to search for.</param>
        </member>
        <member name="M:Sasa.Tokenizer.Tokenize(System.String,System.Int32,System.Int32)">
            <summary>
            Searches the input stream for a set of tokens.
            </summary>
            <param name="input">The input string to search.</param>
            <param name="start">The starting index to start the tokenization.</param>
            <param name="count">The number of characters to analyze.</param>
            <returns>A stream of tokens.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method that searches an input string for a list of string tokens, and
            returns a sequence of token positions found in the string:
            <code>
            var operators = "4 + 5 - 6^2 == x".Tokenize("+", "-", "^", "==");
            foreach (var x in operators)
            {
                Console.WriteLine("Found {0} at index {1}", x.Tok, x.Index);
            }
            // output:
            // Found + at index 2
            // Found - at index 6
            // Found ^ at index 9
            // Found == at index 12
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Tuples">
            <summary>
            Tuple convenience functions.
            </summary>
            <remarks>
            It's common to return multiple values from functions, and there are two common ways to
            do so in .NET: out parameters, and ordinary objects like structs and classes.
            
            Unfortunately, defining a whole class just to return two or three values is often overkill. Also,
            out parameters have some limitations, like inability to use them in lambdas, even when it's safe
            to do so.
            
            Enter tuples, which are types containing only generic parameters whose only purpose is to group
            some items together to address these difficulties. Sasa's ITuple interfaces define the abstract
            contracts satisfied by Sasa's tuple types.
            
            However, unlike .NET's newly released tuples, Sasa's implementation tuples don't use the "tuple"
            name. They are instead split into <see cref="T:Sasa.Pair`2"/>, <see cref="T:Sasa.Triple`3"/> and
            <see cref="T:Sasa.Quad`4"/> because I found the shared "tuple" name often confusing when
            auditing code. Particularly where nested generics are concerned, like enumerable sequences of
            tuples, it's often hard to distinguish Tuple&lt;string,int,int&gt;
            from Tuple&lt;string,int,int,int&gt; while refactoring.
            </remarks>
        </member>
        <member name="M:Sasa.Tuples.Keyed``2(``0,``1)">
            <summary>
            Construct a KeyValuePair from the given values.
            </summary>
            <typeparam name="TKey">The first type.</typeparam>
            <typeparam name="TValue">The second type.</typeparam>
            <param name="key">The first value.</param>
            <param name="value">The second value.</param>
            <returns>A new KeyValuePair.</returns>
            <remarks>
            This static method creates a <see cref="T:System.Collections.Generic.KeyValuePair`2"/>. It exploits
            C#'s type inference to make it easy to create key value pairs without having to explicitly
            specify all the type information:
            <code>
            var dict = new Dictionary&lt;int, string&gt;();
            dict.Add(Tuples.Keyed(3, "foo"));
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Tuples.Create``2(``0,``1)">
            <summary>
            Construct a Pair from the given values.
            </summary>
            <typeparam name="T0">The first type.</typeparam>
            <typeparam name="T1">The second type.</typeparam>
            <param name="item0">The first value.</param>
            <param name="item1">The second value.</param>
            <returns>A new Pair.</returns>
            <remarks>
            This is an overloaded static method to conveniently create tuples exploiting C#'s type inference:
            <code>
            var quad = Tuples.Create(3, "foo", 123.4M, "hello world!");
            var triple = Tuples.Create(3, "foo", 123.4M);
            var pair = Tuples.Create(3, "foo");
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Tuples.Create``3(``0,``1,``2)">
            <summary>
            Construct a Triple from the given values.
            </summary>
            <typeparam name="T0">The first type.</typeparam>
            <typeparam name="T1">The second type.</typeparam>
            <typeparam name="T2">The third type.</typeparam>
            <param name="item0">The first value.</param>
            <param name="item1">The second value.</param>
            <param name="item2">The third value.</param>
            <returns>A new Triple.</returns>
            <remarks>
            This is an overloaded static method to conveniently create tuples exploiting C#'s type inference:
            <code>
            var quad = Tuples.Create(3, "foo", 123.4M, "hello world!");
            var triple = Tuples.Create(3, "foo", 123.4M);
            var pair = Tuples.Create(3, "foo");
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Tuples.Create``4(``0,``1,``2,``3)">
            <summary>
            Construct a Quad from the given values.
            </summary>
            <typeparam name="T0">The first type.</typeparam>
            <typeparam name="T1">The second type.</typeparam>
            <typeparam name="T2">The third type.</typeparam>
            <typeparam name="T3">The fourth type.</typeparam>
            <param name="item0">The first value.</param>
            <param name="item1">The second value.</param>
            <param name="item2">The third value.</param>
            <param name="item3">The fourth value.</param>
            <returns>A new Quad.</returns>
            <remarks>
            This is an overloaded static method to conveniently create tuples exploiting C#'s type inference:
            <code>
            var quad = Tuples.Create(3, "foo", 123.4M, "hello world!");
            var triple = Tuples.Create(3, "foo", 123.4M);
            var pair = Tuples.Create(3, "foo");
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Tuples.Flatten``4(Sasa.Pair{Sasa.Pair{``0,``1},Sasa.Pair{``2,``3}})">
            <summary>
            Flatten a nested pair of pairs into a Quad.
            </summary>
            <typeparam name="T0">The first type.</typeparam>
            <typeparam name="T1">The second type.</typeparam>
            <typeparam name="T2">The third type.</typeparam>
            <typeparam name="T3">The fourth type.</typeparam>
            <param name="nested">A nested tuple to flatten into a single tuple.</param>
            <returns>A flattened tuple.</returns>
        </member>
        <member name="M:Sasa.Tuples.Flatten``3(Sasa.Pair{Sasa.Pair{``0,``1},``2})">
            <summary>
            Flatten a nested pair of a pair into a Triple.
            </summary>
            <typeparam name="T0">The first type.</typeparam>
            <typeparam name="T1">The second type.</typeparam>
            <typeparam name="T2">The third type.</typeparam>
            <param name="nested">A nested tuple to flatten into a single tuple.</param>
            <returns>A flattened tuple.</returns>
        </member>
        <member name="M:Sasa.Tuples.Array``1(``0[])">
            <summary>
            A syntactic shortcut to create arrays of values leveraging type inference.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="values">The values to create.</param>
            <returns>An array of the provided values.</returns>
        </member>
        <member name="T:Sasa.TypeConstraint`1">
            <summary>
            Specifies a type constraint that normally C# would not be able to enforce.
            </summary>
            <typeparam name="T">The type constraint to enforce.</typeparam>
            <remarks>
            It's well known that C# forbids certain core types from appearing as constraints, namely
            <see cref="T:System.Enum"/>, <see cref="T:System.Delegate"/>, and <see cref="T:System.Array"/>.
            <see cref="T:Sasa.TypeConstraint`1"/> and <see cref="T:Sasa.TypeConstraint`2"/> are two purely
            declarative abstract classes that are recognized by Sasa's ilrewrite tool, and which permit
            programs to specify the above forbidden constraints. This pattern is used throughout Sasa to
            implement functionality allowed by the CLR but that would normally be forbidden by C#.
            
            <see cref="T:Sasa.TypeConstraint`2"/> is unfortunately required to express some corner cases. It's
            primarily used in <see cref="T:Sasa.Operators`3"/>, and it's generally only needed if you're
            going to use some methods defined with TypeConstraint within the same assembly. If you can
            factor out those constrained methods into a separate assembly, you shouldn't ever need it.
            
            Sasa's ilrewrite tool basically crawls the generated assembly IL and erases all references to
            <see cref="T:Sasa.TypeConstraint`1"/> wherever it appears. In type signatures, the following:
            <code>
            T : TypeConstraint&lt;Foo&gt;
            </code>
            is replaced by:
            <code>
            T : Foo
            </code>
            Note that ilrewrite is how Sasa is complying with the LGPL while also providing strongly named
            assemblies with a privately held key. The LGPL stipulates that Sasa users ought to be able to
            replace my assemblies with their own whenever they wish, and this is possible using ilrewrite.
            An assembly that was built against my Sasa.dll simply needs to pass through ilrewrite that's
            given a different Sasa.dll signed with another key, and the output assembly will then be bound
            to the new assembly and key. After a brief exchange with a associate member of the EFF, these
            terms seemed satisfactory, although I should note that he isn't licensed to practice law, and
            his opinion does not constitute an official EFF response on this issue.
            </remarks>
        </member>
        <member name="P:Sasa.TypeConstraint`1.Value">
            <summary>
            Extract the encapsulated value.
            </summary>
            <remarks>
            This property allows code compiled assuming a value of type <see cref="T:Sasa.TypeConstraint`1"/>
            to access the underlying value of type Foo. The ilrewrite tool erases calls to this property
            as well, leaving the access to the raw value. The following example is actually the
            definition of <see cref="M:Sasa.Func.Combine``1(``0,``0)"/>:
            <code>
            public static T Combine&lt;T&gt;(this T first, T second)
                where T : TypeConstraint&lt;Delegate&gt;
            {
                return Delegate.Combine(first.Value, second.Value) as T;
            }
            </code>
            The ilrewrite tool erases all references to TypeConstraint so the final output is exactly:
            <code>
            public static T Combine&lt;T&gt;(this T first, T second)
                where T : Delegate
            {
                return Delegate.Combine(first, second) as T;
            }
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.TypeConstraint`1.op_Implicit(`0)~Sasa.TypeConstraint{`0}">
            <summary>
            Implicitly convert a value of type <typeparamref name="T"/> to a TypeConstraint.
            </summary>
            <param name="value"></param>
            <returns>Throws an <see cref="T:System.NotSupportedException"/> if ilrewrite is not run on the assembly.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if ilrewrite is not run on the assembly.</exception>
            <remarks>
            This implicit conversion from T to <see cref="T:Sasa.TypeConstraint`1"/> means client code should never
            have to construct such an instance manually. If you forget to run ilrewrite on an assembly,
            attempting to construct or access any members of TypeConstraint will throw a
            <see cref="T:System.NotSupportedException"/> naming the assembly that needs rewriting.
            </remarks>
        </member>
        <member name="M:Sasa.TypeConstraint`1.Assert(`0)">
            <summary>
            Assert that the given value satisfies the constraint.
            </summary>
            <param name="value">The constrained value.</param>
            <returns>A type constraint that will be erased.</returns>
        </member>
        <member name="T:Sasa.TypeConstraint`2">
            <summary>
            Specifies a subtyping type constraint relationship. You use this constraint
            primarily when compiling with other code that specifies TypeConstraint.
            </summary>
            <typeparam name="T">The inherited type.</typeparam>
            <typeparam name="TBase">The base type for which the constraint is enforced.</typeparam>
            <remarks>
            It's well known that C# forbids certain core types from appearing as constraints, namely
            <see cref="T:System.Enum"/>, <see cref="T:System.Delegate"/>, and <see cref="T:System.Array"/>.
            <see cref="T:Sasa.TypeConstraint`1"/> and <see cref="T:Sasa.TypeConstraint`2"/> are two purely
            declarative abstract classes that are recognized by Sasa's ilrewrite tool, and which permit
            programs to specify the above forbidden constraints. This pattern is used throughout Sasa to
            implement functionality allowed by the CLR but that would normally be forbidden by C#.
            
            <see cref="T:Sasa.TypeConstraint`2"/> is unfortunately required to express some corner cases. It's
            primarily used in <see cref="T:Sasa.Operators`3"/>, and it's generally only needed if you're
            going to use some methods defined with TypeConstraint within the same assembly. If you can
            factor out those constrained methods into a separate assembly, you shouldn't ever need it.
            
            Sasa's ilrewrite tool basically crawls the generated assembly IL and erases all references to
            <see cref="T:Sasa.TypeConstraint`1"/> wherever it appears. In type signatures, the following:
            <code>
            T : TypeConstraint&lt;Foo&gt;
            </code>
            is replaced by:
            <code>
            T : Foo
            </code>
            Note that ilrewrite is how Sasa is complying with the LGPL while also providing strongly named
            assemblies with a privately held key. The LGPL stipulates that Sasa users ought to be able to
            replace my assemblies with their own whenever they wish, and this is possible using ilrewrite.
            An assembly that was built against my Sasa.dll simply needs to pass through ilrewrite that's
            given a different Sasa.dll signed with another key, and the output assembly will then be bound
            to the new assembly and key. After a brief exchange with a associate member of the EFF, these
            terms seemed satisfactory, although I should note that he isn't licensed to practice law, and
            his opinion does not constitute an official EFF response on this issue.
            </remarks>
        </member>
        <member name="P:Sasa.TypeConstraint`2.Value">
            <summary>
            Extract the encapsulated value.
            </summary>
            <remarks>
            This property allows code compiled assuming a value of type <see cref="T:Sasa.TypeConstraint`1"/>
            to access the underlying value of type Foo. The ilrewrite tool erases calls to this property
            as well, leaving the access to the raw value. The following example is actually the
            definition of <see cref="M:Sasa.Func.Combine``1(``0,``0)"/>:
            <code>
            public static T Combine&lt;T&gt;(this T first, T second)
                where T : TypeConstraint&lt;Delegate&gt;
            {
                return Delegate.Combine(first.Value, second.Value) as T;
            }
            </code>
            The ilrewrite tool erases all references to TypeConstraint so the final output is exactly:
            <code>
            public static T Combine&lt;T&gt;(this T first, T second)
                where T : Delegate
            {
                return Delegate.Combine(first, second) as T;
            }
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.TypeConstraint`2.op_Implicit(`0)~Sasa.TypeConstraint{`0,`1}">
            <summary>
            Implicitly convert a value of type <typeparamref name="T"/> to a TypeConstraint.
            </summary>
            <param name="value"></param>
            <returns>Throws an <see cref="T:System.NotSupportedException"/> if ilrewrite is not run on the assembly.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if ilrewrite is not run on the assembly.</exception>
            <remarks>
            This implicit conversion from T to <see cref="T:Sasa.TypeConstraint`1"/> means client code should never
            have to construct such an instance manually. If you forget to run ilrewrite on an assembly,
            attempting to construct or access any members of TypeConstraint will throw a
            <see cref="T:System.NotSupportedException"/> naming the assembly that needs rewriting.
            </remarks>
        </member>
        <member name="M:Sasa.TypeConstraint`2.Assert(`0)">
            <summary>
            Assert that the given value satisfies the constraint.
            </summary>
            <param name="value">The constrained value.</param>
            <returns>A type constraint that will be erased.</returns>
        </member>
        <member name="T:Sasa.Types">
            <summary>
            Extensions to System.Type.
            </summary>
            <remarks>
            Sasa.Types is a static class containing a number of extension methods on <see cref="T:System.Type"/>,
            together with extensions that mirror some of the CLR metadata instructions which aren't typically
            available in C#. 
            </remarks>
        </member>
        <member name="M:Sasa.Types.IsUnsignedPrimitive(System.Type)">
            <summary>
            Checks whether given type is an unsigned primitive type.
            </summary>
            <param name="x">The type to check.</param>
            <returns>True if <paramref name="x"/> is an unsigned primitive.</returns>
        </member>
        <member name="M:Sasa.Types.SizeOf(System.Type)">
            <summary>
            Returns the size of the type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Sasa.Types.Constrain``2">
            <summary>
            Declare additional type constraints on <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type parameter we are constraining.</typeparam>
            <typeparam name="TBase">The type constraint to insert.</typeparam>
            <remarks>
            C# forbids certain types from appearing as constraints, eg. System.Delegate and
            System.Enum. This declaration within a method adds such constraints to the method's
            type parameters after rewriting the IL.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Subtypes(System.Type,System.Type)">
            <summary>
            Checks subtyping relationships.
            </summary>
            <param name="subtype">The subtype.</param>
            <param name="supertype">The potential supertype.</param>
            <returns>True if <paramref name="subtype"/> is a subtype of <paramref name="supertype"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method on <see cref="T:System.Type"/> that checks subtyping relationships
            on runtime types and type arguments:
            <code>
            Console.WriteLine(typeof(int).Subtypes(typeof(object)));
            Console.WriteLine(typeof(int).Subtypes&lt;object&gt;());
            Console.WriteLine(typeof(int).Subtypes&lt;string&gt;());
            </code>
            However, this check has an important limitation when dealing with type parameters. See
            <see cref="M:System.Type.IsAssignableFrom(System.Type)"/>.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Subtypes``1(System.Type)">
            <summary>
            Checks subtyping relationships.
            </summary>
            <typeparam name="T">The potential supertype.</typeparam>
            <param name="subtype">The subtype.</param>
            <returns>True if <paramref name="subtype"/> is a subtype of <typeparamref name="T"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method on <see cref="T:System.Type"/> that checks subtyping relationships
            on runtime types and type arguments:
            <code>
            Console.WriteLine(typeof(int).Subtypes(typeof(object)));
            Console.WriteLine(typeof(int).Subtypes&lt;object&gt;());
            Console.WriteLine(typeof(int).Subtypes&lt;string&gt;());
            
            // output:
            // true
            // true
            // false
            </code>
            However, this check has an important limitation when dealing with type parameters. See
            <see cref="M:System.Type.IsAssignableFrom(System.Type)"/>.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Subtypes``2">
            <summary>
            Checks subtyping relationships.
            </summary>
            <typeparam name="TSub">The subtype.</typeparam>
            <typeparam name="TSup">The potential supertype.</typeparam>
            <returns>True if <typeparamref name="TSub"/> is a subtype of <typeparamref name="TSup"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method on <see cref="T:System.Type"/> that checks subtyping relationships
            on runtime types and type arguments:
            <code>
            Console.WriteLine(typeof(int).Subtypes(typeof(object)));
            Console.WriteLine(typeof(int).Subtypes&lt;object&gt;());
            Console.WriteLine(typeof(int).Subtypes&lt;string&gt;());
            
            // output:
            // true
            // true
            // false
            </code>
            However, this check has an important limitation when dealing with type parameters. See
            <see cref="M:System.Type.IsAssignableFrom(System.Type)"/>.
            </remarks>
        </member>
        <member name="M:Sasa.Types.ShortName(System.Type)">
            <summary>
            Return the shortest string required to identify a type.
            </summary>
            <param name="type">The type to format as a string.</param>
            <returns>A string representation of the type.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method on <see cref="T:System.Type"/> generates an abbreviated string describing
            any type, including generic types:
            <code>
            Console.WriteLine(typeof(int?).ShortName());
            // output:
            // [System.Nullable`[[System.Int32, mscorlib]], mscorlib]]
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Types.ShortGenericType(System.Type,System.Type[],System.Text.StringBuilder)">
            <summary>
            Generates an abbreviated type name for a generic type definition with the specified
            generic type arguments.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="genericArguments">The generic type arguments.</param>
            <param name="output">The StringBuilder to which the type string should be written.</param>
            <returns>An abbreviated generic type name.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method on <see cref="T:System.Type"/> generates an abbreviated string
            describing a generic type, ie. assembly references omit versioning and public key
            information:
            <code>
            var nullableInt = typeof(int?);
            var nullable = nullableInt.GetGenericTypeDefinition();
            Console.WriteLine(nullable.ShortGenericType(nullableInt.GetGenericArguments()));
            // output:
            // [System.Nullable`1[[System.Int32, mscorlib]], mscorlib]
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Types.ShortName(System.Type,System.Text.StringBuilder)">
            <summary>
            Return the shortest string required to identify a type.
            </summary>
            <param name="type">The type to format as a string.</param>
            <param name="output">The StringBuilder to which the type string should be written.</param>
            <returns>A string representation of the type.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Types.ShortGenericType(System.Type,System.Type[])">
            <summary>
            Generates an abbreviated type name for a generic type definition with the specified
            generic type arguments.
            </summary>
            <param name="type">The generic type definition.</param>
            <param name="genericArguments">The generic type arguments.</param>
            <returns>An abbreviated generic type name.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This extension method on <see cref="T:System.Type"/> generates an abbreviated string
            describing a generic type, ie. assembly references omit versioning and public key
            information:
            <code>
            var nullableInt = typeof(int?);
            var nullable = nullableInt.GetGenericTypeDefinition();
            Console.WriteLine(nullable.ShortGenericType(nullableInt.GetGenericArguments()));
            // output:
            // [System.Nullable`1[[System.Int32, mscorlib]], mscorlib]
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Types.IsGenericTypeInstance(System.Type)">
            <summary>
            Checks that the type is a generic type with all generic parameters specified.
            </summary>
            <param name="type">The type to test.</param>
            <returns>True if the type is instaniated with all generic parameters, false otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method on <see cref="T:System.Type"/> that checks whether
            the Type instance is an instantiated generic type definition:
            <code>
            struct Foo { }
            struct Foo&lt;T&gt; { }
            
            Console.WriteLine(typeof(Foo).IsGenericTypeInstance());
            Console.WriteLine(typeof(Foo&lt;&gt;).IsGenericTypeInstance());
            Console.WriteLine(typeof(Foo&lt;int&gt;).IsGenericTypeInstance());
            
            // output:
            // false
            // false
            // true
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Types.Property``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Reflect on an instance property.
            </summary>
            <typeparam name="TObject">The type of object being reflected upon.</typeparam>
            <typeparam name="TField">The field type.</typeparam>
            <param name="member">A simple <see cref="T:System.Linq.Expressions.MemberExpression"/> designating the property.</param>
            <returns>A <see cref="T:System.Reflection.PropertyInfo"/> instance describing the designated property.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="member"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="member"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="T:System.Linq.Expressions.MemberExpression"/> does not designate a property.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method that extracts the <see cref="T:System.Reflection.PropertyInfo"/> of a property
            access expression:
            <code>
            public class Foo
            {
                public static int StaticProperty { get; set; }
                public int AutoProperty { get; set; }
            }
            var sprop = Types.Property(() =&gt; Foo.StaticProperty);
            var iprop = Types.Property&lt;Foo, int&gt;(x =&gt; x.AutoProperty);
            
            Console.WriteLine(sprop);
            Console.WriteLine(iprop);
            // output:
            // Int32 StaticProperty
            // Int32 AutoProperty
            </code>
            The first overload is for static properties, and the second overload is for instance properties since it
            accepts an expression taking an instance and returning the property value.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Property``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Reflect on a static property.
            </summary>
            <typeparam name="T">The type of object being reflected upon.</typeparam>
            <param name="member">A simple <see cref="T:System.Linq.Expressions.MemberExpression"/> designating the property.</param>
            <returns>The <see cref="T:System.Reflection.PropertyInfo"/> describing the designated property.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="member"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="member"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="T:System.Linq.Expressions.MemberExpression"/> does not designate a property.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is an extension method that extracts the <see cref="T:System.Reflection.PropertyInfo"/> of a property
            access expression:
            <code>
            public class Foo
            {
                public static int StaticProperty { get; set; }
                public int AutoProperty { get; set; }
            }
            var sprop = Types.Property(() =&gt; Foo.StaticProperty);
            var iprop = Types.Property&lt;Foo, int&gt;(x =&gt; x.AutoProperty);
            
            Console.WriteLine(sprop);
            Console.WriteLine(iprop);
            // output:
            // Int32 StaticProperty
            // Int32 AutoProperty
            </code>
            The first overload is for static properties, and the second overload is for instance properties since it
            accepts an expression taking an instance and returning the property value.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Method``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Reflect on an instance method.
            </summary>
            <typeparam name="TObject">The type of object being reflected upon.</typeparam>
            <typeparam name="TMethod">The method type signature exposed as a delegate.</typeparam>
            <param name="target">A simple <see cref="T:System.Linq.Expressions.MemberExpression"/> designating the method.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/> describing the designated method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="target"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="T:System.Linq.Expressions.MemberExpression"/> does not designate a method.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a static method that extracts the <see cref="T:System.Reflection.MethodInfo"/> of a delegate expression:
            <code>
            struct Foo
            {
               public static int DoSomething(string x);
                public int Otherwise();
            }
            ...
            var doSomething = Types.Method&lt;Func&lt;string, int&gt;&gt;(() =&gt; Foo.DoSomething);
            var otherwise = Types.Method&lt;Func&lt;Foo, Func&lt;int&gt;&gt;&gt;(x =&gt; x.Otherwise);
            
            Console.WriteLine(doSomething);
            Console.WriteLine(otherwise);
            
            // output:
            // Int32 DoSomething(String)
            // Int32 Otherwise()
            </code>
            The second overload is for instance methods, so it accepts an expression that takes an instance,
            and returns a delegate to the method of interest.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Method``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Reflect on a static method.
            </summary>
            <typeparam name="T">The method type.</typeparam>
            <param name="target">A simple <see cref="T:System.Linq.Expressions.MemberExpression"/> designating the method.</param>
            <returns>The <see cref="T:System.Reflection.MethodInfo"/> describing the designated method.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="target"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="target"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="T:System.Linq.Expressions.MemberExpression"/> does not designate a method.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a static method that extracts the <see cref="T:System.Reflection.MethodInfo"/> of a delegate expression:
            <code>
            struct Foo
            {
               public static int DoSomething(string x);
                public int Otherwise();
            }
            ...
            var doSomething = Types.Method&lt;Func&lt;string, int&gt;&gt;(() =&gt; Foo.DoSomething);
            var otherwise = Types.Method&lt;Func&lt;Foo, Func&lt;int&gt;&gt;&gt;(x =&gt; x.Otherwise);
            
            Console.WriteLine(doSomething);
            Console.WriteLine(otherwise);
            
            // output:
            // Int32 DoSomething(String)
            // Int32 Otherwise()
            </code>
            The second overload is for instance methods, so it accepts an expression that takes an instance,
            and returns a delegate to the method of interest.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Constructor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Reflect on a constructor.
            </summary>
            <typeparam name="T">The object type.</typeparam>
            <param name="construct">A simple <see cref="T:System.Linq.Expressions.NewExpression"/> designating the method.</param>
            <returns>The <see cref="T:System.Reflection.ConstructorInfo"/> describing the constructor.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="construct"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="construct"/> is not a <see cref="T:System.Linq.Expressions.NewExpression"/>.</exception>
            <remarks>
            This method accepts a lambda expression with a "new" expression designating a type's constructor. It then extracts and
            returns the <see cref="T:System.Reflection.ConstructorInfo" /> used that expression:
            <code>
            struct Foo
            {
               public Foo(int i)
               {
                   ...
               }
            }
            ...
            var x = Types.Constructor(() =&gt; new Foo(3));
            Console.WriteLine(x);
            // output:
            // Void .ctor(Int32)
            </code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
        </member>
        <member name="M:Sasa.Types.HasAutoField(System.Reflection.PropertyInfo)">
            <summary>
            Checks whether property is an auto-property with compiler-generated backing fields.
            </summary>
            <param name="property">The property to check.</param>
            <returns>True if auto-property, false otherwise.</returns>
            <remarks>
            This is an extension method on <see cref="T:System.Reflection.PropertyInfo"/> that checks whether a
            property is an auto-property with a compiler-generated backing field:
            <code>
            class Foo
            {
                public int Bar
                {
                   get { return 0; }
                }
                public int AutoProp { get; set; }
            }
            var autop = Types.Property&lt;Foo, int&gt;(x =&gt; x.AutoProp);
            var normp = Types.Property&lt;Foo, int&gt;(x =&gt; x.Bar);
            
            Console.WriteLine(autop.HasAutoField());
            Console.WriteLine(normp.HasAutoField());
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Types.GetBackingField(System.Reflection.PropertyInfo)">
            <summary>
            Obtains the backing field for <paramref name="property"/>, if any.
            </summary>
            <param name="property">The property whose backing field being obtained.</param>
            <returns>The backing field if <paramref name="property"/> is an auto-property, else null.</returns>
            <remarks>
            This extension method on <see cref="T:System.Reflection.PropertyInfo"/> attempts to extract the
            compiler-generated field metadata:
            <code>
            public class Foo
            {
                public int AutoProperty { get; set; }
            }
            var backingField = Types.Property&lt;Foo, int&gt;(x =&gt; x.AutoProperty)
                                    .GetBackingField();
            Console.WriteLine(backingField.Name.FieldName());
            Console.WriteLine(backingField.Name);
            // output:
            // AutoProperty
            // &lt;AutoProperty&gt;k__BackingField
            </code>
            Note that this method currently depends on the naming convention used by the
            compiler, so it may not be 100% future-proof. If the convention ever does
            change, I anticipate updating this implementation to reflect that.
            </remarks>
        </member>
        <member name="M:Sasa.Types.IsBackingField(System.Reflection.FieldInfo)">
            <summary>
            Checks whether a field was auto-generated from a property declaration.
            </summary>
            <param name="field">The field to check.</param>
            <returns>True if field was auto-generated, false otherwise.</returns>
            <remarks>
            This is an extension method on <see cref="T:System.Reflection.FieldInfo"/> that checks whether a
            field is a compiler-generated backing field for a property:
            <code>
            public class Foo
            {
                public int normalField;
                public int AutoProperty { get; set; }
            }
            var backingField = Types.Property&lt;Foo, int&gt;(x =&gt; x.AutoProperty)
                                    .GetBackingField();
            var normalField = Types.Field&lt;Foo, int&gt;(x =&gt; x.normalField);
            
            Console.WriteLine(backingField.IsBackingField());
            Console.WriteLine(normalField.IsBackingField());
            // output:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Types.FieldName(System.Reflection.FieldInfo)">
            <summary>
            Normalizes a field name.
            </summary>
            <param name="field">The field whose name to normalize.</param>
            <returns>
            If <paramref name="field"/> is an auto-generated field from an auto property, the property name is returned.
            Otherwise the field name is returned.
            </returns>
            <remarks>
            This extension method on <see cref="T:System.Reflection.FieldInfo"/> extracts a "normalized" field name. By
            "normalized", I mean that if the field was a compiler-generated backing field for an auto
            property, then it will extract the property name. Otherwise, it will just return the
            field name itself:
            <code>
            public class Foo
            {
                public int normalField;
                public int AutoProperty { get; set; }
            }
            var backingField = Types.Property&lt;Foo, int&gt;(x =&gt; x.AutoProperty)
                                    .GetBackingField();
            var normalField = Types.Field&lt;Foo, int&gt;(x =&gt; x.normalField);
            
            Console.WriteLine(backingField.FieldName());
            Console.WriteLine(normalField.FieldName());
            // output:
            // AutoProperty
            // normalField
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Types.Field``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Reflect on an instance field.
            </summary>
            <typeparam name="TObject">The type of object being reflected upon.</typeparam>
            <typeparam name="TField">The field type.</typeparam>
            <param name="member">A simple <see cref="T:System.Linq.Expressions.MemberExpression"/> designating the method.</param>
            <returns>A <see cref="T:System.Reflection.FieldInfo"/> describing the designated field.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="member"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="member"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="T:System.Linq.Expressions.MemberExpression"/> does not designate a field.</exception>
            <remarks>
            This extension method is used to extract <see cref="T:System.Reflection.FieldInfo"/> metadata from a simple member
            access expression for that field:
            <code>
            struct Foo
            {
               public int Instance;
               public static string Static;
            }
            ...
            var instanceField = Types.Field&lt;Foo, int&gt;(x =&gt; x.Instance);
            var staticField = Types.Field&lt;int&gt;(() =&gt; Foo.Static);
            Console.WriteLine(instanceField);
            Console.WriteLine(staticField);
            // output:
            // Int32 Instance
            // String Static
            </code>
            The first overload is for static field, and the second overload is for instance fields since
            it accepts an expression taking an instance and returning the field value.
            
            The one caveat is that the C# can't enforce that you properly reference fields, or that
            you're using the write overload to access static vs. instance fields. Instance fields
            require an instance in order to reference them, so you must use the overload that accepts
            two generic arguments. Static fields only require the use of one generic argument.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Field``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Reflect over a type's static field.
            </summary>
            <typeparam name="T">The field type.</typeparam>
            <param name="member">A simple <see cref="T:System.Linq.Expressions.MemberExpression"/> designating the field.</param>
            <returns>A <see cref="T:System.Reflection.FieldInfo"/> describing the designated field.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="member"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="member"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="T:System.Linq.Expressions.MemberExpression"/> does not designate a field.</exception>
            <remarks>
            This extension method is used to extract <see cref="T:System.Reflection.FieldInfo"/> metadata from a simple member
            access expression for that field:
            <code>
            struct Foo
            {
               public int Instance;
               public static string Static;
            }
            ...
            var instanceField = Types.Field&lt;Foo, int&gt;(x =&gt; x.Instance);
            var staticField = Types.Field&lt;int&gt;(() =&gt; Foo.Static);
            Console.WriteLine(instanceField);
            Console.WriteLine(staticField);
            // output:
            // Int32 Instance
            // String Static
            </code>
            The first overload is for static field, and the second overload is for instance fields since
            it accepts an expression taking an instance and returning the field value.
            
            The one caveat is that the C# can't enforce that you properly reference fields, or that
            you're using the write overload to access static vs. instance fields. Instance fields
            require an instance in order to reference them, so you must use the overload that accepts
            two generic arguments. Static fields only require the use of one generic argument.
            </remarks>
        </member>
        <member name="M:Sasa.Types.Member``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Reflect over a type's static member.
            </summary>
            <typeparam name="T">The member type.</typeparam>
            <param name="member">A simple <see cref="T:System.Linq.Expressions.MemberExpression"/> designating the member.</param>
            <returns>A <see cref="T:System.Reflection.MemberInfo"/> describing the designated member.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="member"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="member"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
        </member>
        <member name="M:Sasa.Types.Member``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Reflect on an instance member.
            </summary>
            <typeparam name="TObject">The type of object being reflected upon.</typeparam>
            <typeparam name="TMember">The member type.</typeparam>
            <param name="member">A simple <see cref="T:System.Linq.Expressions.MemberExpression"/> designating the method.</param>
            <returns>A <see cref="T:System.Reflection.MemberInfo"/> describing the designated member.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="member"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="member"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
        </member>
        <member name="M:Sasa.Types.Member``4(System.Linq.Expressions.Expression{``3})">
            <summary>
            Obtain information on a specific member.
            </summary>
            <typeparam name="TInfo">The specific type of <see cref="T:System.Reflection.MemberInfo"/> to obtain.</typeparam>
            <typeparam name="TConstraint">The constraint on <typeparamref name="TMember"/>.</typeparam>
            <typeparam name="TMember">The type of the member.</typeparam>
            <typeparam name="TExp">The type of the expression delegate.</typeparam>
            <param name="member">The expression referencing the member.</param>
            <returns>The designated <see cref="T:System.Reflection.MemberInfo"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="member"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="member"/> is not a <see cref="T:System.Linq.Expressions.MemberExpression"/>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="T:System.Linq.Expressions.MemberExpression"/> is not of the type <typeparamref name="TInfo"/>.</exception>
        </member>
        <member name="M:Sasa.Types.GetTypeTree(System.Type)">
            <summary>
            Generates a serialized tree of all type constructors and their type arguments.
            </summary>
            <param name="type">The type to process.</param>
            <returns>A flat list of all non-generic type arguments used in <paramref name="type"/>.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="type"/> is null.</exception>
            <remarks>
            This extension method on <see cref="T:System.Type"/> extracts the whole sequence of
            generic type instances, declarations and arguments that make up a type:
            <code>
            var args = typeof(Pair&lt;int, Pair&lt;string,char&gt;&gt;).GetTypeTree();
            // args = new[]
            // {
            //     typeof(Pair&lt;int, Pair&lt;string, char&gt;&gt;),
            //     typeof(Pair&lt;,&gt;),
            //          typeof(int),
            //          typeof(Pair&lt;string, char&gt;),
            //          typeof(Pair&lt;,&gt;),
            //              typeof(string), typeof(char)
            // };
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Types.Create(System.String,System.Boolean,System.Action{System.Reflection.Emit.TypeBuilder})">
            <summary>
            Generate a dynamic type.
            </summary>
            <param name="name">The type name.</param>
            <param name="saveAssembly">Flag indicating whether the dynamic assembly should be saved.</param>
            <param name="generate">The callback used to generate the type.</param>
            <returns>The created type.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This is a static method used to create a dynamic type in a dynamic assembly, often for
            code generation purposes. It automates various steps and provides a boolean parameter
            indicating whether to save the assembly to a file, so you can run verification passes on it:
            <code>
            var newType = Types.Create("TypeFoo",
                                       saveAssembly:true,
                                       generate: typeBuilder =&gt;
            {
                // see docs on TypeBuilder
                ...
            });
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Uris">
            <summary>
            Extension on <seealso cref="T:System.Uri"/>.
            </summary>
        </member>
        <member name="M:Sasa.Uris.QueryParam(System.Uri,System.String)">
            <summary>
            Extract the value of a named query parameter.
            </summary>
            <param name="uri">The URI to search.</param>
            <param name="paramName">The query parameter name.</param>
            <returns>The query parameter values if any exist, or no results otherwise.</returns>
            <remarks>
            Extract a named query parameter from a <see cref="T:System.Uri"/>:
            <code>
            var uri = new Uri("http://foo.com?x=1&amp;y=y&amp;x=foo");
            foreach(var x in uri.QueryParam("x"))
                Console.WriteLine(x);
            Console.WriteLine(uri.QueryParam("y").Single());
            // output:
            // 1
            // foo
            // y
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Uris.QueryParam(System.String,System.String)">
            <summary>
            Extract the value of a named query parameter.
            </summary>
            <param name="query">The queryt string to search.</param>
            <param name="paramName">The query parameter name.</param>
            <returns>The query parameter values if any exist, or no results otherwise.</returns>
            <remarks>
            Extract a named query parameter from a query string:
            <code>
            var query = "?x=1&amp;y=y&amp;x=foo";
            foreach(var x in Uris.QueryParam(query, "x"))
                Console.WriteLine(x);
            Console.WriteLine(Uris.QueryParam(query, "y").Single());
            // output:
            // 1
            // foo
            // y
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Uris.IsUnreserved(System.Char)">
            <summary>
            Determines whether character requires encoding.
            </summary>
            <param name="x">The character to check.</param>
            <returns>True if character requires URI encoding, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Uris.IsUnreserved(System.Byte)">
            <summary>
            Determines whether the byte requires encoding.
            </summary>
            <param name="x">The byte to check.</param>
            <returns>True if byte requires URI encoding, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Uris.UriEncode(System.Text.StringBuilder,System.Char)">
            <summary>
            URI-encode a character into a buffer.
            </summary>
            <param name="buffer">The buffer in which to write the encoded value.</param>
            <param name="x">The bytes to encode.</param>
            <returns>The string builder.</returns>
        </member>
        <member name="M:Sasa.Uris.UriEncode(System.Text.StringBuilder,System.Byte)">
            <summary>
            URI-encode a character into a buffer.
            </summary>
            <param name="buffer">The buffer in which to write the encoded value.</param>
            <param name="x">The bytes to encode.</param>
            <returns>The string builder.</returns>
        </member>
        <member name="M:Sasa.Uris.UriEncode(System.Text.StringBuilder,System.String)">
            <summary>
            URI-encode a string value into a buffer.
            </summary>
            <param name="buffer">The buffer in which to write the encoded value.</param>
            <param name="value">The string value to encode.</param>
            <returns>The string builder.</returns>
        </member>
        <member name="M:Sasa.Uris.UriEncode(System.Text.StringBuilder,System.String,System.Int32,System.Int32)">
            <summary>
            URI-encode a string value into a buffer.
            </summary>
            <param name="buffer">The buffer in which to write the encoded value.</param>
            <param name="value">The string value to encode.</param>
            <param name="start">The starting index in the string.</param>
            <param name="count">The number of characters to read from <paramref name="value"/>.</param>
            <returns>The string builder.</returns>
        </member>
        <member name="M:Sasa.Uris.UriEncode(System.Text.StringBuilder,System.Byte[])">
            <summary>
            URI-encode bytes into a buffer.
            </summary>
            <param name="buffer">The buffer in which to write the encoded value.</param>
            <param name="value">The bytes to encode.</param>
            <returns>The string builder.</returns>
        </member>
        <member name="M:Sasa.Uris.UriEncode(System.Text.StringBuilder,System.Byte[],System.Int32,System.Int32)">
            <summary>
            URI-encode bytes into a buffer.
            </summary>
            <param name="buffer">The buffer in which to write the encoded value.</param>
            <param name="value">The bytes to encode.</param>
            <param name="start">The starting index in the byte array.</param>
            <param name="count">The number of bytes to write to the buffer.</param>
            <returns>The string builder.</returns>
        </member>
        <member name="T:Sasa.Uris.Encoder">
            <summary>
            URI encoder.
            </summary>
            <remarks>
            This is the most efficient way to encode URIs, particularly if
            you're composing a URI from multiple fragments.
            </remarks>
        </member>
        <member name="P:Sasa.Uris.Encoder.Buffer">
            <summary>
            The internal <see cref="T:System.Text.StringBuilder"/> containing the URI.
            </summary>
        </member>
        <member name="M:Sasa.Uris.Encoder.#ctor(System.Text.StringBuilder)">
            <summary>
            Construct a URI encoder.
            </summary>
            <param name="buffer">The URI buffer.</param>
        </member>
        <member name="M:Sasa.Uris.Encoder.Encode(System.Byte)">
            <summary>
            URI-encode a byte into a buffer.
            </summary>
            <param name="x">The byte to encode.</param>
            <returns>The string builder.</returns>
        </member>
        <member name="M:Sasa.Uris.Encoder.Encode(System.Char)">
            <summary>
            URI-encode a character.
            </summary>
            <param name="x">The character to encode.</param>
        </member>
        <member name="M:Sasa.Uris.Encoder.Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            URI-encode bytes into a buffer.
            </summary>
            <param name="value">The bytes to encode.</param>
            <param name="start">The starting index in the byte array.</param>
            <param name="count">The number of bytes to write to the buffer.</param>
        </member>
        <member name="M:Sasa.Uris.Encoder.Encode(System.String,System.Int32,System.Int32)">
            <summary>
            URI-encode a string value into a buffer.
            </summary>
            <param name="value">The string value to encode.</param>
            <param name="start">The starting index in the string.</param>
            <param name="count">The number of characters to read from <paramref name="value"/>.</param>
        </member>
        <member name="M:Sasa.Uris.Encoder.Encode(System.Byte[])">
            <summary>
            URI-encode bytes into a buffer.
            </summary>
            <param name="value">The bytes to encode.</param>
        </member>
        <member name="M:Sasa.Uris.Encoder.Encode(System.String)">
            <summary>
            URI-encode a string.
            </summary>
            <param name="value">The string to encode.</param>
        </member>
        <member name="M:Sasa.Uris.Encoder.ToString">
            <summary>
            Return the underlying buffer.
            </summary>
            <returns>The generated URI.</returns>
        </member>
        <member name="M:Sasa.Uris.UriDecode(System.Text.StringBuilder,System.String,System.Int32,System.Int32)">
            <summary>
            URI Decode a string.
            </summary>
            <param name="buffer">The string buffer in which to decode.</param>
            <param name="uri">The URI we are decoding.</param>
            <param name="start">The starting index in the URI.</param>
            <param name="count">The number of characters to decode.</param>
            <returns>The <see cref="T:System.Text.StringBuilder"/> in which output is written.</returns>
        </member>
        <member name="M:Sasa.Uris.UriDecode(System.Text.StringBuilder,System.String)">
            <summary>
            URI Decode a string.
            </summary>
            <param name="buffer">The string buffer in which to decode.</param>
            <param name="uri">The URI we are decoding.</param>
            <returns>The <see cref="T:System.Text.StringBuilder"/> in which output is written.</returns>
        </member>
        <member name="T:Sasa.Uris.Decoder">
            <summary>
            A URI decoder.
            </summary>
            <remarks>
            This is the most efficient way to decode URIs, particularly if
            you're composing a URI from multiple fragments.
            </remarks>
        </member>
        <member name="P:Sasa.Uris.Decoder.Buffer">
            <summary>
            The internal <see cref="T:System.Text.StringBuilder"/> containing the decoded URI.
            </summary>
        </member>
        <member name="M:Sasa.Uris.Decoder.#ctor(System.Text.StringBuilder)">
            <summary>
            Construct a URI decoder.
            </summary>
            <param name="buffer">The decoded buffer.</param>
        </member>
        <member name="M:Sasa.Uris.Decoder.Decode(System.String,System.Int32,System.Int32)">
            <summary>
            URI Decode a string.
            </summary>
            <param name="uri">The URI we are decoding.</param>
            <param name="start">The starting index in the URI.</param>
            <param name="count">The number of characters to decode.</param>
        </member>
        <member name="M:Sasa.Uris.Decoder.Decode(System.String)">
            <summary>
            URI Decode a string.
            </summary>
            <param name="uri">The URI we are decoding.</param>
        </member>
        <member name="M:Sasa.Uris.Decoder.ToString">
            <summary>
            Return the underlying buffer.
            </summary>
            <returns>The decoded URI.</returns>
        </member>
        <member name="T:Sasa.Web.Url64">
            <summary>
            Encodes bytes into a Base64 alphabet that is safe to embed into URLs.
            </summary>
            <remarks>
            This is essentially the same as the Base64 URL-safe encoding specified in section 5
            of RFC4648 [1], except the lower case numbers come first, and no padding character
            is needed.
            
            [1] http://tools.ietf.org/html/rfc4648#section-5
            </remarks>
        </member>
        <member name="M:Sasa.Web.Url64.ToUrl64(System.Byte[])">
            <summary>
            Convert bytes to a Url64 string.
            </summary>
            <param name="data">The binary data.</param>
            <returns>The equivalent Url64 encoded string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This simple extension method on byte arrays convert raw bytes to a Url64-encoded string:
            <code>
            byte[] data = BitConverter.GetBytes(int.MinValue);
            Console.WriteLine(data.ToUrl64());
            
            int i = BitConverter.ToInt32(data.FromUrl64());
            Console.WriteLine(i);
            // output:
            // aaaaGa
            // -2147483648
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Web.Url64.ToUrl64(System.Byte[],System.Text.StringBuilder)">
            <summary>
            Convert bytes to a Url64 string.
            </summary>
            <param name="data">The binary data.</param>
            <param name="output">The output string.</param>
            <returns>The equivalent Url64 encoded string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This simple extension method on byte arrays convert raw bytes to a Url64-encoded string:
            <code>
            byte[] data = BitConverter.GetBytes(int.MinValue);
            Console.WriteLine(data.ToUrl64());
            
            int i = BitConverter.ToInt32(data.FromUrl64());
            Console.WriteLine(i);
            // output:
            // aaaaGa
            // -2147483648
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Web.Url64.ToUrl64(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Convert bytes to a Url64 string.
            </summary>
            <param name="data">The bytes to convert.</param>
            <param name="startIndex">The starting index into the byte array.</param>
            <param name="count">The number of bytes to convert.</param>
            <param name="output">The encoded bytes are output to this StringBuilder.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This simple extension method on byte arrays convert raw bytes to a Url64-encoded string:
            <code>
            byte[] data = BitConverter.GetBytes(int.MinValue);
            Console.WriteLine(data.ToUrl64());
            
            int i = BitConverter.ToInt32(data.FromUrl64());
            Console.WriteLine(i);
            // output:
            // aaaaGa
            // -2147483648
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Web.Url64.FromUrl64(System.String)">
            <summary>
            Convert from a Url64 string representation back to binary.
            </summary>
            <param name="data">The string in Url64 form.</param>
            <returns>The decoded bytes corresponding to the given string.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if argument is null.</exception>
            <remarks>
            This simple extension method on strings converts a Url64-encoded string to a byte array:
            <code>
            byte[] data = BitConverter.GetBytes(int.MinValue);
            Console.WriteLine(data.ToUrl64());
            
            int i = BitConverter.ToInt32(data.FromUrl64());
            Console.WriteLine(i);
            // output:
            // aaaaGa
            // -2147483648
            </code>
            </remarks>
        </member>
        <member name="T:Sasa.Values">
            <summary>
            Generic value extensions.
            </summary>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,``0)">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="arg0">The first value to compare against.</param>
            <returns>True if <paramref name="value"/> is equal to one of the other parameters, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,``0,``0)">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="arg0">The first value to compare against.</param>
            <param name="arg1">The second value to compare against.</param>
            <returns>True if <paramref name="value"/> is equal to one of the other parameters, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,``0,``0,``0)">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="arg0">The first value to compare against.</param>
            <param name="arg1">The second value to compare against.</param>
            <param name="arg2">The third value to compare against.</param>
            <returns>True if <paramref name="value"/> is equal to one of the other parameters, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,``0,``0,``0,``0)">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="arg0">The first value to compare against.</param>
            <param name="arg1">The second value to compare against.</param>
            <param name="arg2">The third value to compare against.</param>
            <param name="arg3">The fourth value to compare against.</param>
            <returns>True if <paramref name="value"/> is equal to one of the other parameters, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,``0[])">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="set">The set to check for membership.</param>
            <returns>True if <paramref name="value"/> is in the set, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,System.Collections.Generic.IEqualityComparer{``0},``0)">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to use.</param>
            <param name="arg0">The first value to compare against.</param>
            <returns>True if <paramref name="value"/> is equal to one of the other parameters, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,System.Collections.Generic.IEqualityComparer{``0},``0,``0)">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to use.</param>
            <param name="arg0">The first value to compare against.</param>
            <param name="arg1">The second value to compare against.</param>
            <returns>True if <paramref name="value"/> is equal to one of the other parameters, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,System.Collections.Generic.IEqualityComparer{``0},``0,``0,``0)">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to use.</param>
            <param name="arg0">The first value to compare against.</param>
            <param name="arg1">The second value to compare against.</param>
            <param name="arg2">The third value to compare against.</param>
            <returns>True if <paramref name="value"/> is equal to one of the other parameters, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,System.Collections.Generic.IEqualityComparer{``0},``0,``0,``0,``0)">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to use.</param>
            <param name="arg0">The first value to compare against.</param>
            <param name="arg1">The second value to compare against.</param>
            <param name="arg2">The third value to compare against.</param>
            <param name="arg3">The fourth value to compare against.</param>
            <returns>True if <paramref name="value"/> is equal to one of the other parameters, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.IsIn``1(``0,System.Collections.Generic.IEqualityComparer{``0},``0[])">
            <summary>
            Checks for membership in a set.
            </summary>
            <typeparam name="T">The type of value to check for.</typeparam>
            <param name="value">The value to check for membership.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to use.</param>
            <param name="set">The set to check for membership.</param>
            <returns>True if <paramref name="value"/> is in the set, false otherwise.</returns>
            <remarks>
            This extension method used to check if a value is contained within a collection of other items. Logically,
            it's equivalent to SQL's "IN" operator. In it's most general form, IsIn is a shorthand for
            <see cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>, but the more specific overloads are far more efficient and don't
            require the construction of a collection to check membership:
            <code>
            Console.WriteLine(3.IsIn(1,2,3,4));
            Console.WriteLine("xxx".IsIn("hello", "world!"));
            // output:
            // true
            // false
            </code>
            As explained before, you can already perform this check in standard C#, but it's far more verbose. You
            either have to create a switch statement, or a set of logical conjunctions in an if-statement, or you
            have to construct a collection and call Contains like so:
            <code>
            Console.WriteLine(new[] { 1,2,3,4 }.Contains(3));
            Console.WriteLine(new[] { "hello", "world!" }.Contains("xxx"));
            // output:
            // true
            // false
            </code>
            Using the IsIn extension is far more concise, and I'd argue, much clearer.
            </remarks>
        </member>
        <member name="M:Sasa.Values.Swap``1(``0@,``0@)">
            <summary>
            Swap the values of two references.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="arg0">The first reference to swap.</param>
            <param name="arg1">The second reference to swap.</param>
            <remarks>
            This method is not thread-safe when called from multiple threads with the same references.
            </remarks>
        </member>
        <member name="M:Sasa.Values.Swap``1(``0[],System.Int32,System.Int32)">
            <summary>
            Swap the values of two array entries.
            </summary>
            <typeparam name="T">The type of value being swapped.</typeparam>
            <param name="array">The array to operate on.</param>
            <param name="i">The first index.</param>
            <param name="j">The second index.</param>
            <remarks>
            This method is not thread-safe when called from multiple threads with the same array.
            </remarks>
        </member>
        <member name="M:Sasa.Values.NonNull``1(``0)">
            <summary>
            Construct a new non-null instance.
            </summary>
            <typeparam name="T">The type of the non-null reference.</typeparam>
            <param name="value">The reference to check for null.</param>
            <returns>An assuredly non-null reference.</returns>
        </member>
        <member name="T:Sasa.Weak`1">
            <summary>
            Exposes a strongly typed interface to an encapsulated WeakReference.
            </summary>
            <typeparam name="T">The type of the object in the WeakReference.</typeparam>
        </member>
        <member name="M:Sasa.Weak`1.#ctor(System.WeakReference)">
            <summary>
            Construct a typed weak reference from the given WeakReference.
            </summary>
            <param name="reference">The WeakReference to encapsulate.</param>
            <exception cref="T:System.InvalidCastException">If the provided WeakReference does not point
            to an object of type T.</exception>
        </member>
        <member name="M:Sasa.Weak`1.#ctor(`0)">
            <summary>
            Encapsulate the given object in a Weak ref.
            </summary>
            <param name="value">The object to encapsulate in a Weak reference.</param>
        </member>
        <member name="P:Sasa.Weak`1.Value">
            <summary>
            Access the underlying value, if it still exists.
            </summary>
            <remarks>
            This property obtains the current value encapsulated in the weak reference, or null if the object has been collected:
            <code>
            string original = new string("hello world!".ToCharArray());
            Weak&lt;string&gt; foo = original;
            Console.WriteLine(foo.Value);
            
            // lose all live references and run collection
            original = null;
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Console.WriteLine(foo.Value ?? "&lt;null&gt;");
            
            // outputs:
            // hello world!
            // &lt;null&gt;
            </code>
            This property also fulfills the requirements for the <see cref="T:Sasa.IValue`1"/> interface.
            </remarks>
        </member>
        <member name="P:Sasa.Weak`1.IsAlive">
            <summary>
            True if the reference is still alive.
            </summary>
            <remarks>
            This property checks whether the target of the weak reference has yet to be collected:
            <code>
            string original = new string("hello world!".ToCharArray());
            Weak&lt;string&gt; foo = original;
            Console.WriteLine(foo.IsAlive);
            
            // lose all live references and run collection
            original = null;
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Console.WriteLine(foo.IsAlive);
            
            // outputs:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Weak`1.HasValue">
            <summary>
            True if the reference is still alive.
            </summary>
            <remarks>
            This property has the same purpose as <see cref="P:Sasa.Weak`1.IsAlive"/>, but fulfills the requirements to
            satisfy the <see cref="T:Sasa.IResolvable`1"/> interface:
            <code>
            string original = new string("hello world!".ToCharArray());
            Weak&lt;string&gt; foo = original;
            Console.WriteLine(foo.HasValue);
            
            // lose all live references and run collection
            original = null;
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Console.WriteLine(foo.HasValue);
            
            // outputs:
            // true
            // false
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Weak`1.TryGetValue(`0@)">
            <summary>
            Extract the value behind the weak reference.
            </summary>
            <param name="value">The underlying value.</param>
            <returns>True if the value is alive, false otherwise.</returns>
            <remarks>
            This method checks whether a weak reference to a target is alive, and returns a live reference to that target in one step:
            <code>
            string original = new string("hello world!".ToCharArray());
            Weak&lt;string&gt; foo = original;
            Console.WriteLine(foo.TryGetValue(out original));
            Console.WriteLine(original);
            
            // lose all live references and run collection
            original = null;
            GC.Collect();
            GC.WaitForPendingFinalizers();
            Console.WriteLine(foo.TryGetValue(out original));
            Console.WriteLine(original ?? "&lt;null&gt;");
            
            // outputs:
            // true
            // hello world!
            // false
            // &lt;null&gt;
            </code>
            This method also satisfies the requirements for the <see cref="T:Sasa.IVolatile`1"/> interface.
            </remarks>
        </member>
        <member name="M:Sasa.Weak`1.Equals(`0)">
            <summary>
            Compares the given object for equality.
            </summary>
            <param name="other">The object to compare against.</param>
            <returns>True if the underlying object is equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Weak`1.Equals(Sasa.Weak{`0})">
            <summary>
            Compares the given object for equality.
            </summary>
            <param name="other">The object to compare against.</param>
            <returns>True if the underlying object is equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Weak`1.Equals(System.Object)">
            <summary>
            Equality test.
            </summary>
            <param name="obj">The object to compare for equality.</param>
            <returns>True if the objects are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Weak`1.GetHashCode">
            <summary>
            Hashcode override.
            </summary>
            <returns>The integer hash code.</returns>
        </member>
        <member name="M:Sasa.Weak`1.Equals(System.WeakReference)">
            <summary>
            Compares the given object for equality.
            </summary>
            <param name="other">The object to compare against.</param>
            <returns>True if the underlying object is equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Weak`1.op_Implicit(`0)~Sasa.Weak{`0}">
            <summary>
            Implicitly convert a value of type T to a Weak ref if needed.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>A Weak reference to the value.</returns>
        </member>
        <member name="M:Sasa.Weak`1.op_Implicit(Sasa.Weak{`0})~`0">
            <summary>
            Implicitly extract the value encapsulated in the Weak ref.
            </summary>
            <param name="weak">The Weak reference from which to extract the value.</param>
            <returns>The value encapsulated in the Weak ref.</returns>
        </member>
        <member name="M:Sasa.Weak`1.op_Implicit(Sasa.Weak{`0})~System.WeakReference">
            <summary>
            Implicitly extract the WeakReference encapsulated in the Weak value.
            </summary>
            <param name="weak">The Weak reference from which to extract the WeakReference.</param>
            <returns>The WeakReference encapsulated in the Weak value.</returns>
        </member>
        <member name="M:Sasa.Weak`1.op_Equality(Sasa.Weak{`0},Sasa.Weak{`0})">
            <summary>
            Compares two weak references for equality.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Weak`1.op_Inequality(Sasa.Weak{`0},Sasa.Weak{`0})">
            <summary>
            Compares two weak references for inequality.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>True if not equal, false otherwise.</returns>
        </member>
        <member name="T:Sasa.Triple`3">
            <summary>
            A three-element tuple.
            </summary>
            <typeparam name="T0">First type.</typeparam>
            <typeparam name="T1">Second type.</typeparam>
            <typeparam name="T2">Third type.</typeparam>
            <remarks>
            It's common to return multiple values from functions, and there are two common ways to
            do so in .NET: out parameters, and ordinary objects like structs and classes.
            
            Unfortunately, defining a whole class just to return two or three values is often overkill. Also,
            out parameters have some limitations, like inability to use them in lambdas, even when it's safe
            to do so.
            
            Enter tuples, which are types containing only generic parameters whose only purpose is to group
            some items together to address these difficulties. Sasa's ITuple interfaces define the abstract
            contracts satisfied by Sasa's tuple types.
            
            However, unlike .NET's newly released tuples, Sasa's implementation tuples don't use the "tuple"
            name. They are instead split into <see cref="T:Sasa.Pair`2"/>, <see cref="T:Sasa.Triple`3"/> and
            <see cref="T:Sasa.Quad`4"/> because I found the shared "tuple" name often confusing when
            auditing code. Particularly where nested generics are concerned, like enumerable sequences of
            tuples, it's often hard to distinguish Tuple&lt;string,int,int&gt;
            from Tuple&lt;string,int,int,int&gt; while refactoring.
            </remarks>
        </member>
        <member name="M:Sasa.Triple`3.#ctor(`0,`1,`2)">
            <summary>
            Construct a new Triple.
            </summary>
            <param name="first">The first value.</param>
            <param name="second">The second value.</param>
            <param name="third">The third value.</param>
        </member>
        <member name="P:Sasa.Triple`3.First">
            <summary>
            First element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the first item in a triple:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M);
            Console.WriteLine(x.First);
            // output:
            // 3
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Triple`3.Second">
            <summary>
            Second element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the second item in a triple:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M);
            Console.WriteLine(x.Second);
            // output:
            // foo
            </code>
            </remarks>
        </member>
        <member name="P:Sasa.Triple`3.Third">
            <summary>
            Third element of the tuple.
            </summary>
            <remarks>
            This property permits clients to access the third item in a triple:
            <code>
            var x = Tuples.Create(3, "foo", 123.4M);
            Console.WriteLine(x.Third);
            // output:
            // 123.4
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Triple`3.Bind(`0@,`1@,`2@)">
            <summary>
            Bind all values to locals.
            </summary>
            <param name="first">The first value.</param>
            <param name="second">The second value.</param>
            <param name="third">The third value.</param>
            <remarks>
            This method extracts all of a Triple's values in one step using "out" parameters.
            So even if you prefer out parameters to tuples, you can easily use an interface
            that uses Sasa's tuples:
            <code>
            int i;
            string foo;
            decimal d;
            Tuples.Create(3, "foo", 123.4M)
                  .Bind(out i, out foo, out d);
            </code>
            </remarks>
        </member>
        <member name="M:Sasa.Triple`3.Equals(Sasa.Triple{`0,`1,`2})">
            <summary>
            Test Triple equality element-wise.
            </summary>
            <param name="other">The Triple to test for equality.</param>
            <returns>True if equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Triple`3.Equals(System.Object)">
            <summary>
            Test equality.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>True if objects are equal, false otherwise.</returns>
        </member>
        <member name="M:Sasa.Triple`3.GetHashCode">
            <summary>
            Compute hash code.
            </summary>
            <returns>Hash of the encapsulated values.</returns>
        </member>
        <member name="M:Sasa.Triple`3.CompareTo(Sasa.Triple{`0,`1,`2})">
            <summary>
            Compare the two values, sequentially Triple.First, then Triple.Second if
            Triple.First are equal, then Triple.Third if Triple.Second is equal.
            </summary>
            <param name="other">The Triple to compare against.</param>
            <returns>
            Returns zero if the tuples are equal element-wise, returns a number greater than zero if
            the current tuple is greater than <paramref name="other"/> element-wise, else returns a
            number greater than zero.
            </returns>
        </member>
        <member name="M:Sasa.Triple`3.ToString">
            <summary>
            Return a string representation of this Triple.
            </summary>
            <returns>String representation of this Triple.</returns>
        </member>
        <member name="M:Sasa.Triple`3.op_Equality(Sasa.Triple{`0,`1,`2},Sasa.Triple{`0,`1,`2})">
            <summary>
            Compares two Triples for equality.
            </summary>
            <param name="left">The first Triple.</param>
            <param name="right">The second Triple.</param>
            <returns>Returns true if the Triples are equal, and false otherwise.</returns>
        </member>
        <member name="M:Sasa.Triple`3.op_Inequality(Sasa.Triple{`0,`1,`2},Sasa.Triple{`0,`1,`2})">
            <summary>
            Compares two Triples for inequality.
            </summary>
            <param name="left">The first Triple.</param>
            <param name="right">The second Triple.</param>
            <returns>Returns true if the Triples are not equal, and false otherwise.</returns>
        </member>
        <member name="M:Sasa.Triple`3.op_LessThan(Sasa.Triple{`0,`1,`2},Sasa.Triple{`0,`1,`2})">
            <summary>
            Orders two tuples.
            </summary>
            <param name="left">The first tuple.</param>
            <param name="right">The second tuple.</param>
            <returns>
            True if <paramref name="left"/> is less than <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Triple`3.op_GreaterThan(Sasa.Triple{`0,`1,`2},Sasa.Triple{`0,`1,`2})">
            <summary>
            Orders two tuples.
            </summary>
            <param name="left">The first tuple.</param>
            <param name="right">The second tuple.</param>
            <returns>
            True if <paramref name="left"/> is greater than <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Triple`3.op_LessThanOrEqual(Sasa.Triple{`0,`1,`2},Sasa.Triple{`0,`1,`2})">
            <summary>
            Orders two tuples.
            </summary>
            <param name="left">The first tuple.</param>
            <param name="right">The second tuple.</param>
            <returns>
            True if <paramref name="left"/> is less than or equal to <paramref name="right"/>, false otherwise.
            </returns>
        </member>
        <member name="M:Sasa.Triple`3.op_GreaterThanOrEqual(Sasa.Triple{`0,`1,`2},Sasa.Triple{`0,`1,`2})">
            <summary>
            Orders two tuples.
            </summary>
            <param name="left">The first tuple.</param>
            <param name="right">The second tuple.</param>
            <returns>
            True if <paramref name="left"/> is greater than or equal to <paramref name="right"/>, false otherwise.
            </returns>
        </member>
    </members>
</doc>
